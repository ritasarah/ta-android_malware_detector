package com.catfiz.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Environment;
import android.support.v4.content.LocalBroadcastManager;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import android.widget.Toast;
import com.catfiz.R;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.media.MediaScanOnlyNotifier;
import com.catfiz.pool.PoolDataStorage;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.svcpersistent.DataStorageDownloadBase;
import com.catfiz.svcpersistent.DataStorageDownloadInfo.DataStorageStreamType;
import com.catfiz.util.Log;
import com.catfiz.util.ObjectLockManager;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import org.apache.http.HttpStatus;

public class MessageSlinkDataDownloadExecutor extends DataStorageDownloadBase implements IDropableRunnable, Runnable {
    private static final String TAG = "MessageSlinkDataDownloadExecutor";
    public static final String mParentPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/download/");
    private final int CHAT = 1;
    private final int POOL = 2;
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = 0;
    private int mByteend = 0;
    private int mBytestart = 0;
    private boolean mCancelDownload;
    private BroadcastReceiver mCancelDownloadReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            long longExtra = intent.getLongExtra(ServerMessageDataStorage.SEQUENCE, 0);
            if (longExtra == 0) {
                Log.d(MessageSlinkDataDownloadExecutor.TAG, "INVALID SEQUENCE: DO NOT CANCEL");
            } else if (MessageSlinkDataDownloadExecutor.this.mSequence == 0 || MessageSlinkDataDownloadExecutor.this.mSequence != longExtra) {
                Log.d(MessageSlinkDataDownloadExecutor.TAG, "Current Object Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(MessageSlinkDataDownloadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + longExtra);
                MessageSlinkDataDownloadExecutor.this.mCancelDownload = true;
            }
        }
    };
    private int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    private byte[] mChunkbuffer = null;
    private FileOutputStream mChunkstream = null;
    private ICatfishClientInterface mClient;
    private File mDataFile = null;
    private String mDataPath = null;
    private int mDatasize = 0;
    private String mFileName = null;
    public String mLockKey = null;
    public String mLockObj = null;
    private int mOriginPlace = 0;
    private String mSenderpin = null;
    private long mSequence = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private boolean mShowProgress = false;
    private String mSlink = null;
    private String mTopicKey = null;
    private String mUserpin = null;
    private int mWriten = 0;
    private boolean returnToUI = false;
    public int scheduleNum = 0;

    class GetDataSlinkChunks implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private GetDataSlinkChunks() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            Log.d(MessageSlinkDataDownloadExecutor.TAG, "Slink (" + MessageSlinkDataDownloadExecutor.this.mSlink + ") Data Download: DROP BY SERVICE");
            ObjectLockManager.releaseLockKey(MessageSlinkDataDownloadExecutor.this.mLockKey);
            MessageSlinkDataDownloadExecutor.this.deleteTaskState(MessageSlinkDataDownloadExecutor.this.mSlink, false);
            try {
                MessageSlinkDataDownloadExecutor.this.mChunkstream.flush();
                MessageSlinkDataDownloadExecutor.this.mChunkstream.close();
            } catch (IOException e) {
            }
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (!ObjectLockManager.isLockKeyLocked(MessageSlinkDataDownloadExecutor.this.mLockKey)) {
                Log.e(MessageSlinkDataDownloadExecutor.TAG, "GetProfilePhotoChunks: INCONSISTENT LOCK!!!: DROP");
                try {
                    MessageSlinkDataDownloadExecutor.this.mChunkstream.flush();
                    MessageSlinkDataDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e) {
                }
                MessageSlinkDataDownloadExecutor.this.invokeClientCallbackFailed();
            } else if (ObjectLockManager.checkLockKeyString(MessageSlinkDataDownloadExecutor.this.mLockKey, MessageSlinkDataDownloadExecutor.this.mLockObj)) {
                Log.d(MessageSlinkDataDownloadExecutor.TAG, "GetProfilePhotoChunks: WE HAVE HELD THE LOCK: Continue...");
                Log.d(MessageSlinkDataDownloadExecutor.TAG, "Get byte range: bs=" + String.valueOf(MessageSlinkDataDownloadExecutor.this.mBytestart) + ", " + "be=" + String.valueOf(MessageSlinkDataDownloadExecutor.this.mByteend) + ", " + "size=" + String.valueOf(MessageSlinkDataDownloadExecutor.this.mDatasize) + ", " + "mWriten=" + String.valueOf(MessageSlinkDataDownloadExecutor.this.mWriten));
                Intent intent;
                if (MessageSlinkDataDownloadExecutor.this.mCancelDownload) {
                    intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_FIZZLINK);
                    intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                    intent.putExtra(ServerMessageDataStorage.SEQUENCE, MessageSlinkDataDownloadExecutor.this.mSequence);
                    intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                    LocalBroadcastManager.getInstance(MessageSlinkDataDownloadExecutor.this.mService).sendBroadcast(intent);
                    LocalBroadcastManager.getInstance(MessageSlinkDataDownloadExecutor.this.mService).unregisterReceiver(MessageSlinkDataDownloadExecutor.this.mCancelDownloadReceiver);
                    ObjectLockManager.releaseLockKey(MessageSlinkDataDownloadExecutor.this.mLockKey);
                    return;
                }
                CatfishResult downloadSLinkDataChunk = this.catfishRestAPI.downloadSLinkDataChunk(MessageSlinkDataDownloadExecutor.this.mServer, MessageSlinkDataDownloadExecutor.this.mUserpin, MessageSlinkDataDownloadExecutor.this.mSlink, MessageSlinkDataDownloadExecutor.this.mBytestart, MessageSlinkDataDownloadExecutor.this.mByteend, MessageSlinkDataDownloadExecutor.this.mChunkstream);
                if (MessageSlinkDataDownloadExecutor.this.mCancelDownload) {
                    intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_FIZZLINK);
                    intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                    intent.putExtra(ServerMessageDataStorage.SEQUENCE, MessageSlinkDataDownloadExecutor.this.mSequence);
                    intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                    LocalBroadcastManager.getInstance(MessageSlinkDataDownloadExecutor.this.mService).sendBroadcast(intent);
                    LocalBroadcastManager.getInstance(MessageSlinkDataDownloadExecutor.this.mService).unregisterReceiver(MessageSlinkDataDownloadExecutor.this.mCancelDownloadReceiver);
                    ObjectLockManager.releaseLockKey(MessageSlinkDataDownloadExecutor.this.mLockKey);
                    return;
                }
                if (downloadSLinkDataChunk.hasSuccess()) {
                    this.mAge = System.currentTimeMillis();
                    if (downloadSLinkDataChunk.chunksize > 0) {
                        MessageSlinkDataDownloadExecutor.this.mWriten = MessageSlinkDataDownloadExecutor.this.mWriten + downloadSLinkDataChunk.chunksize;
                    }
                    if (MessageSlinkDataDownloadExecutor.this.mWriten < MessageSlinkDataDownloadExecutor.this.mDatasize) {
                        int access$800 = (int) ((((long) MessageSlinkDataDownloadExecutor.this.mWriten) * 100) / ((long) MessageSlinkDataDownloadExecutor.this.mDatasize));
                        MessageSlinkDataDownloadExecutor.this.invokeClientCallback(access$800, true);
                        Log.d(MessageSlinkDataDownloadExecutor.TAG, "Progress: " + access$800 + ", Chunksize: " + String.valueOf(downloadSLinkDataChunk.chunksize));
                        MessageSlinkDataDownloadExecutor.this.mChunkMaxSize = CatfishRESTAPI.growChunkSize(MessageSlinkDataDownloadExecutor.this.mChunkMaxSize);
                        MessageSlinkDataDownloadExecutor.this.mBytestart = MessageSlinkDataDownloadExecutor.this.mWriten;
                        MessageSlinkDataDownloadExecutor.this.mByteend = (MessageSlinkDataDownloadExecutor.this.mWriten + MessageSlinkDataDownloadExecutor.this.mChunkMaxSize) - 1;
                        MessageSlinkDataDownloadExecutor.this.mService.postToServiceHandler(this, 2);
                        downloadSLinkDataChunk.cleaningup();
                        return;
                    }
                    Log.d(MessageSlinkDataDownloadExecutor.TAG, "GetDataSlinkChunks: Get Data Chunk: DONE");
                    MessageSlinkDataDownloadExecutor.this.mService.postRunnableToDbThread(new SLinkUpdateDB());
                    ObjectLockManager.releaseLockKey(MessageSlinkDataDownloadExecutor.this.mLockKey);
                    MessageSlinkDataDownloadExecutor.this.deleteTaskState(MessageSlinkDataDownloadExecutor.this.mSlink, false);
                    MessageSlinkDataDownloadExecutor.this.invokeClientCallback(0, false);
                } else if (downloadSLinkDataChunk.hasFailure()) {
                    Log.d(MessageSlinkDataDownloadExecutor.TAG, "GetDataSlinkChunks: Get Data Chunk: FAIL: Reschedule");
                    if (downloadSLinkDataChunk.chunksize > 0) {
                        this.mAge = System.currentTimeMillis();
                        MessageSlinkDataDownloadExecutor.this.mWriten = MessageSlinkDataDownloadExecutor.this.mWriten + downloadSLinkDataChunk.chunksize;
                        if (MessageSlinkDataDownloadExecutor.this.mWriten < MessageSlinkDataDownloadExecutor.this.mDatasize) {
                            MessageSlinkDataDownloadExecutor.this.mBytestart = MessageSlinkDataDownloadExecutor.this.mWriten;
                            MessageSlinkDataDownloadExecutor.this.mByteend = (MessageSlinkDataDownloadExecutor.this.mWriten + MessageSlinkDataDownloadExecutor.this.mChunkMaxSize) - 1;
                            MessageSlinkDataDownloadExecutor.this.mService.postToServiceHandler(this, 2);
                            downloadSLinkDataChunk.cleaningup();
                            return;
                        }
                        Log.d(MessageSlinkDataDownloadExecutor.TAG, "GetDataSlinkChunks (In FAILURE): Get Data Chunk: DONE");
                        MessageSlinkDataDownloadExecutor.this.invokeClientCallback((int) ((((long) MessageSlinkDataDownloadExecutor.this.mWriten) * 100) / ((long) MessageSlinkDataDownloadExecutor.this.mDatasize)), false);
                        Log.d(MessageSlinkDataDownloadExecutor.TAG, "Chunksize: " + String.valueOf(downloadSLinkDataChunk.chunksize));
                        MessageSlinkDataDownloadExecutor.this.mService.postRunnableToDbThread(new SLinkUpdateDB());
                        ObjectLockManager.releaseLockKey(MessageSlinkDataDownloadExecutor.this.mLockKey);
                        MessageSlinkDataDownloadExecutor.this.deleteTaskState(MessageSlinkDataDownloadExecutor.this.mSlink, false);
                        try {
                            MessageSlinkDataDownloadExecutor.this.mChunkstream.flush();
                            MessageSlinkDataDownloadExecutor.this.mChunkstream.close();
                        } catch (IOException e2) {
                        }
                        downloadSLinkDataChunk.cleaningup();
                        return;
                    }
                    MessageSlinkDataDownloadExecutor.this.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(MessageSlinkDataDownloadExecutor.this.mChunkMaxSize);
                    MessageSlinkDataDownloadExecutor.this.mByteend = (MessageSlinkDataDownloadExecutor.this.mWriten + MessageSlinkDataDownloadExecutor.this.mChunkMaxSize) - 1;
                    MessageSlinkDataDownloadExecutor.this.mServer = CatfishService.getServerHost();
                    MessageSlinkDataDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    downloadSLinkDataChunk.cleaningup();
                    return;
                } else {
                    Log.d(MessageSlinkDataDownloadExecutor.TAG, "GetDataSlinkChunks: Get Data Chunk: ERROR: DROP");
                    MessageSlinkDataDownloadExecutor.this.invokeClientCallbackFailed();
                    ObjectLockManager.releaseLockKey(MessageSlinkDataDownloadExecutor.this.mLockKey);
                }
                try {
                    MessageSlinkDataDownloadExecutor.this.mChunkstream.flush();
                    MessageSlinkDataDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e3) {
                }
                MessageSlinkDataDownloadExecutor.this.mChunkbuffer = null;
                downloadSLinkDataChunk.cleaningup();
            } else {
                Log.d(MessageSlinkDataDownloadExecutor.TAG, "GetProfilePhotoChunks: OOPS LOCK ITS NOT MINE: CANCEL");
                ObjectLockManager.releaseLockKey(MessageSlinkDataDownloadExecutor.this.mLockKey);
                try {
                    MessageSlinkDataDownloadExecutor.this.mChunkstream.flush();
                    MessageSlinkDataDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e4) {
                }
                MessageSlinkDataDownloadExecutor.this.invokeClientCallbackFailed();
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class SLinkUpdateDB implements Runnable {
        private SLinkUpdateDB() {
        }

        public void run() {
            String extension = Utils.getExtension(MessageSlinkDataDownloadExecutor.this.mDataFile.getAbsolutePath());
            MediaScanOnlyNotifier mediaScanOnlyNotifier = new MediaScanOnlyNotifier(MessageSlinkDataDownloadExecutor.this.mService, MessageSlinkDataDownloadExecutor.this.mDataFile.getAbsolutePath(), extension == null ? "*/*" : Utils.getmimetypeFromExtension(extension));
            if (MessageSlinkDataDownloadExecutor.this.mTopicKey == null || MessageSlinkDataDownloadExecutor.this.mTopicKey.isEmpty()) {
                new CatfishDataStorage(MessageSlinkDataDownloadExecutor.this.getCatfishService()).updateMessageFizzlinkDownloaded(MessageSlinkDataDownloadExecutor.this.mSenderpin, MessageSlinkDataDownloadExecutor.this.mSequence, MessageSlinkDataDownloadExecutor.this.mDataFile.getAbsolutePath());
                Log.d(MessageSlinkDataDownloadExecutor.TAG, "Slink Download complete");
                return;
            }
            new PoolDataStorage(MessageSlinkDataDownloadExecutor.this.getCatfishService()).updateMessageFizzlinkDownloaded(MessageSlinkDataDownloadExecutor.this.mTopicKey, MessageSlinkDataDownloadExecutor.this.mSequence, MessageSlinkDataDownloadExecutor.this.mDataFile.getAbsolutePath());
            Log.d(MessageSlinkDataDownloadExecutor.TAG, "Slink Download (GROUP) complete");
        }
    }

    public MessageSlinkDataDownloadExecutor(CatfishService catfishService, String str, String str2, String str3, ICatfishClientInterface iCatfishClientInterface, int i, String str4, String str5, boolean z, long j, String str6, String str7) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mSlink = str3;
        this.mDatasize = i;
        this.mDataPath = str4;
        this.mFileName = str5;
        this.mClient = iCatfishClientInterface;
        this.mLockKey = "download:" + this.mSlink;
        this.mLockObj = String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence());
        this.mSenderpin = str6;
        this.mTopicKey = str7;
        this.mSequence = j;
        this.mShowProgress = z;
        ObjectLockManager.acquireLockKey(this.mLockKey, this.mLockObj);
        this.mAge = System.currentTimeMillis();
        invokeClientCallback(0, true);
    }

    private void invokeClientCallback(int i, boolean z) {
        if (z) {
            Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_FIZZLINK);
            intent.putExtra(CatfishService.PROGRESS_VALUE, i);
            intent.putExtra(CatfishService.PROGRESS_STATE, 1);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
            LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
            return;
        }
        intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_FIZZLINK);
        intent.putExtra(CatfishService.PROGRESS_STATE, 2);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
    }

    private void invokeClientCallbackFailed() {
        Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_FIZZLINK);
        intent.putExtra(CatfishService.PROGRESS_STATE, 4);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
    }

    public void dropRunnable() {
        ObjectLockManager.releaseLockKey(this.mLockKey);
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelDownloadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_FIZZLINK_DOWNLOAD));
        if (!ObjectLockManager.isLockKeyLocked(this.mLockKey)) {
            Log.e(TAG, "INCONSISTENT LOCK!!!: DROP");
            invokeClientCallbackFailed();
        } else if (ObjectLockManager.checkLockKeyString(this.mLockKey, this.mLockObj)) {
            Log.d(TAG, "WE HAVE HELD THE LOCK: Continue...");
            try {
                this.mDataFile = new File(this.mDataPath);
                Log.d(TAG, "slink data path: " + this.mDataPath);
                String externalStorageState = Environment.getExternalStorageState();
                if (externalStorageState.equals("mounted")) {
                    File parentFile = this.mDataFile.getParentFile();
                    if (parentFile == null || parentFile.exists() || parentFile.mkdirs()) {
                        this.mByteend = this.mChunkMaxSize - 1;
                        try {
                            if (isResumeProcess() && this.mDataFile.exists()) {
                                this.mChunkstream = new FileOutputStream(this.mDataFile, true);
                                this.mWriten = (int) this.mDataFile.length();
                                this.mBytestart = this.mWriten;
                                this.mByteend = (this.mBytestart + this.mChunkMaxSize) - 1;
                            } else {
                                this.mChunkstream = new FileOutputStream(this.mDataFile);
                            }
                            updateTaskState(this.mSlink, this.mDataFile.getAbsolutePath(), this.mDatasize, DataStorageStreamType.FIZZLINK_DATA.ordinal(), null, false);
                            this.mService.postToServiceHandler(new GetDataSlinkChunks(), 2);
                            return;
                        } catch (FileNotFoundException e) {
                            Log.e(TAG, "DOWNLOADEXECUTOR: " + e.toString());
                            ObjectLockManager.releaseLockKey(this.mLockKey);
                            try {
                                this.mChunkstream.flush();
                                this.mChunkstream.close();
                            } catch (Exception e2) {
                            }
                            invokeClientCallbackFailed();
                            return;
                        }
                    }
                    Log.e(TAG, "DOWNLOADEXECUTOR: Path to file could not be created.");
                    ObjectLockManager.releaseLockKey(this.mLockKey);
                    invokeClientCallbackFailed();
                    return;
                }
                Log.e(TAG, "DOWNLOADEXECUTOR: media not mounted in is state: " + externalStorageState + ":DROP !!!");
                Toast.makeText(this.mService, this.mService.getString(R.string.media_mounted_error), 0).show();
                ObjectLockManager.releaseLockKey(this.mLockKey);
                invokeClientCallbackFailed();
            } catch (Exception e3) {
                Log.e(TAG, "ERROR: invalid path: " + this.mDataPath);
                ObjectLockManager.releaseLockKey(this.mLockKey);
                invokeClientCallbackFailed();
            }
        } else {
            Log.d(TAG, "OOPS LOCK ITS NOT MINE: CANCEL");
            ObjectLockManager.releaseLockKey(this.mLockKey);
            invokeClientCallbackFailed();
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

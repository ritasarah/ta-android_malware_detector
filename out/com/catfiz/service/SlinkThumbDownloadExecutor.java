package com.catfiz.service;

import android.os.Environment;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.util.Log;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class SlinkThumbDownloadExecutor implements IDropableRunnable, Runnable {
    private static final String TAG = "SlinkThumbDownloadExecutor";
    private static final String THUMB_NAME = "flt_";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    public static final String mParentPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/thumbs/");
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = 0;
    private int mByteend = 0;
    private int mBytestart = 0;
    private byte[] mChunkbuffer = null;
    private FileOutputStream mChunkstream = null;
    private ICatfishClientInterface mClient;
    private File mDataFile = null;
    private String mDataPath = null;
    private int mDatasize = 0;
    private String mObjOwner = null;
    private long mObjSequence = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private String mSlink = null;
    private String mTipe = null;
    private String mUserpin = null;
    private int mWriten = 0;
    public int scheduleNum = 0;

    class FizzlinkThumbDLUpdateDB implements Runnable {
        private FizzlinkThumbDLUpdateDB() {
        }

        public void run() {
            Log.d(SlinkThumbDownloadExecutor.TAG, "--- Download thumb finish, update db for cache ---");
            new FizzlinkDataStorage(SlinkThumbDownloadExecutor.this.mService).updateFizzlinkDownloadData(SlinkThumbDownloadExecutor.this.mSlink, SlinkThumbDownloadExecutor.this.mDataPath);
            SlinkThumbDownloadExecutor.this.NotifyUI();
        }
    }

    class GetDataStorageChunks implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private volatile long mAge = System.currentTimeMillis();
        public int scheduleNum = 0;

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            Log.d(SlinkThumbDownloadExecutor.TAG, "Get byte range: bs=" + String.valueOf(SlinkThumbDownloadExecutor.this.mBytestart) + ", " + "be=" + String.valueOf(SlinkThumbDownloadExecutor.this.mByteend) + ", " + "size=" + String.valueOf(SlinkThumbDownloadExecutor.this.mDatasize) + ", " + "mWriten=" + String.valueOf(SlinkThumbDownloadExecutor.this.mWriten));
            CatfishResult downloadDataChunk = this.catfishRestAPI.downloadDataChunk(SlinkThumbDownloadExecutor.this.mServer, SlinkThumbDownloadExecutor.this.mUserpin, SlinkThumbDownloadExecutor.this.mObjOwner, SlinkThumbDownloadExecutor.this.mObjSequence, SlinkThumbDownloadExecutor.this.mBytestart, SlinkThumbDownloadExecutor.this.mByteend, SlinkThumbDownloadExecutor.this.mChunkstream);
            Log.d(SlinkThumbDownloadExecutor.TAG, "Chunksize: " + String.valueOf(downloadDataChunk.chunksize));
            if (downloadDataChunk.hasSuccess()) {
                this.mAge = System.currentTimeMillis();
                if (downloadDataChunk.chunksize > 0) {
                    SlinkThumbDownloadExecutor.this.mWriten = SlinkThumbDownloadExecutor.this.mWriten + downloadDataChunk.chunksize;
                }
                if (SlinkThumbDownloadExecutor.this.mWriten < SlinkThumbDownloadExecutor.this.mDatasize) {
                    SlinkThumbDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.growChunkSize(SlinkThumbDownloadExecutor.mChunkMaxSize);
                    SlinkThumbDownloadExecutor.this.mBytestart = SlinkThumbDownloadExecutor.this.mWriten;
                    SlinkThumbDownloadExecutor.this.mByteend = (SlinkThumbDownloadExecutor.this.mBytestart + SlinkThumbDownloadExecutor.mChunkMaxSize) - 1;
                    this.mAge = System.currentTimeMillis();
                    SlinkThumbDownloadExecutor.this.mService.postToServiceHandler(this, 2);
                    downloadDataChunk.cleaningup();
                    return;
                }
                Log.d(SlinkThumbDownloadExecutor.TAG, "FIZZLINK THUMB RECEIVE: Get Data Chunk: DONE");
                SlinkThumbDownloadExecutor.this.mService.postRunnableToDbThread(new FizzlinkThumbDLUpdateDB());
            } else if (downloadDataChunk.hasFailure()) {
                Log.d(SlinkThumbDownloadExecutor.TAG, "FIZZLINK THUMB RECEIVE: Get Data Chunk: FAIL: Reschedule");
                if (downloadDataChunk.chunksize > 0) {
                    this.mAge = System.currentTimeMillis();
                    SlinkThumbDownloadExecutor.this.mWriten = SlinkThumbDownloadExecutor.this.mWriten + downloadDataChunk.chunksize;
                    if (SlinkThumbDownloadExecutor.this.mWriten < SlinkThumbDownloadExecutor.this.mDatasize) {
                        SlinkThumbDownloadExecutor.this.mBytestart = SlinkThumbDownloadExecutor.this.mWriten;
                        SlinkThumbDownloadExecutor.this.mByteend = (SlinkThumbDownloadExecutor.this.mWriten + SlinkThumbDownloadExecutor.mChunkMaxSize) - 1;
                        this.mAge = System.currentTimeMillis();
                        SlinkThumbDownloadExecutor.this.mService.postToServiceHandler(this, 2);
                        downloadDataChunk.cleaningup();
                        return;
                    }
                    Log.d(SlinkThumbDownloadExecutor.TAG, "FIZZLINK THUMB RECEIVE (In FAILURE): Get Data Chunk: DONE");
                    SlinkThumbDownloadExecutor.this.mService.postRunnableToDbThread(new FizzlinkThumbDLUpdateDB());
                    try {
                        SlinkThumbDownloadExecutor.this.mChunkstream.flush();
                        SlinkThumbDownloadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    downloadDataChunk.cleaningup();
                    return;
                }
                SlinkThumbDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(SlinkThumbDownloadExecutor.mChunkMaxSize);
                SlinkThumbDownloadExecutor.this.mServer = CatfishService.getServerHost();
                SlinkThumbDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
                downloadDataChunk.cleaningup();
                return;
            } else {
                Log.d(SlinkThumbDownloadExecutor.TAG, "FIZZLINK THUMB RECEIVE: Get Data Chunk: ERROR: DROP");
            }
            try {
                SlinkThumbDownloadExecutor.this.mChunkstream.flush();
                SlinkThumbDownloadExecutor.this.mChunkstream.close();
            } catch (IOException e2) {
            }
            SlinkThumbDownloadExecutor.this.mChunkbuffer = null;
            downloadDataChunk.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public SlinkThumbDownloadExecutor(CatfishService catfishService, String str, String str2, String str3, ICatfishClientInterface iCatfishClientInterface, long j, String str4, String str5) {
        this.mSlink = str4;
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mObjOwner = str3;
        this.mObjSequence = j;
        this.mAge = System.currentTimeMillis();
        this.mClient = iCatfishClientInterface;
        this.mDataPath = mParentPath + THUMB_NAME + getThumbFileName(str5);
        Log.d(TAG, "path: " + this.mDataPath);
        this.mDataFile = new File(this.mDataPath);
    }

    private void NotifyUI() {
        if (!this.mClient.isFinish()) {
            this.mClient.onFizzlinkThumbReady(this.mSlink, this.mDataPath);
        }
    }

    private String getThumbFileName(String str) {
        int lastIndexOf = str.lastIndexOf(".");
        if (0 >= lastIndexOf) {
            lastIndexOf = str.length();
        }
        return str.substring(0, lastIndexOf) + ".png";
    }

    public void dropRunnable() {
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        String externalStorageState = Environment.getExternalStorageState();
        if (externalStorageState.equals("mounted")) {
            File parentFile = this.mDataFile.getParentFile();
            if (parentFile.exists() || parentFile.mkdirs()) {
                Log.d(TAG, "!@@@ objsequencethumb:" + this.mObjSequence + " ownerpin:" + this.mObjOwner + " mUserpin:" + this.mUserpin);
                CatfishResult slinkInfo = this.catfishRestAPI.getSlinkInfo(this.mUserpin, this.mObjOwner, this.mObjSequence);
                if (slinkInfo.hasFailure()) {
                    Log.d(TAG, "FIZZLINK THUMB RECEIVE: Get Info FAIL: Reschedule !!!");
                    this.mServer = CatfishService.getServerHost();
                    this.mService.scheduleRunnableToService(this, 2);
                    slinkInfo.cleaningup();
                    return;
                } else if (slinkInfo.hasNotFound()) {
                    Log.e(TAG, "FIZZLINK THUMB RECEIVE: NOT FOUND: DROP !!!");
                    slinkInfo.cleaningup();
                    return;
                } else if (!slinkInfo.hasSuccess()) {
                    Log.e(TAG, "FIZZLINK THUMB RECEIVE: ERROR: DROP !!!");
                    slinkInfo.cleaningup();
                    return;
                } else if (slinkInfo.datasize != slinkInfo.currentdatasize) {
                    Log.e(TAG, "FIZZLINK THUMB RECEIVE: INVALID DATA SIZE: DROP !!!");
                    slinkInfo.cleaningup();
                    return;
                } else {
                    this.mDatasize = slinkInfo.datasize;
                    this.mByteend = mChunkMaxSize - 1;
                    try {
                        this.mChunkstream = new FileOutputStream(this.mDataFile);
                        this.mService.postToServiceHandler(new GetDataStorageChunks(), 2);
                        return;
                    } catch (FileNotFoundException e) {
                        Log.e(TAG, "FIZZLINK THUMB RECEIVE: " + e.toString());
                        return;
                    }
                }
            }
            Log.e(TAG, "FIZZLINK THUMB RECEIVE: Path to file could not be created.");
            return;
        }
        Log.e(TAG, "FIZZLINK THUMB RECEIVE: media not mounted in is state: " + externalStorageState + ":DROP !!!");
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

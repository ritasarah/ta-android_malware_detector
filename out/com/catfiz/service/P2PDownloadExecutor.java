package com.catfiz.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.Environment;
import android.preference.PreferenceManager;
import android.support.v4.content.LocalBroadcastManager;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.catfiz.R;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.media.MediaScanOnlyNotifier;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.svcpersistent.P2PDownloadBase;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.CFURLSpan;
import com.catfiz.util.Log;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import org.apache.commons.logging.impl.SimpleLog;
import org.apache.http.conn.routing.HttpRouteDirector;

public class P2PDownloadExecutor extends P2PDownloadBase implements IDropableRunnable, Runnable {
    private static final String TAG = "P2PDownloadExecutor";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    private long mAge = System.currentTimeMillis();
    private int mByteEnd = 0;
    private int mByteStart = 0;
    private int mByteStreamType = 0;
    private boolean mCancel;
    private BroadcastReceiver mCancelReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            long longExtra = intent.getLongExtra(ServerMessageDataStorage.SEQUENCE, 0);
            if (longExtra == 0) {
                Log.d(P2PDownloadExecutor.TAG, "INVALID SEQUENCE: DO NOT CANCEL");
            } else if (P2PDownloadExecutor.this.mSequence == 0 || P2PDownloadExecutor.this.mSequence != longExtra) {
                Log.d(P2PDownloadExecutor.TAG, "Current Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(P2PDownloadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + longExtra);
                P2PDownloadExecutor.this.mCancel = true;
            }
        }
    };
    private CatfishRESTAPI mCatfishRestAPI = null;
    private long mChannelId = 0;
    private int mChunkSize = 0;
    private int mDataSize = 0;
    private FileOutputStream mFileOutputStream = null;
    private File mPath = null;
    private File mRcvFile = null;
    private String mSenderpin = null;
    private long mSequence = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private String mUserpin = null;
    private int mWriten = 0;
    public int scheduleNum = 0;

    class DownloadDataChunks implements IDropableRunnable, IP2PChunkData, IP2PDropableRunnable, Runnable {
        private volatile long mAge;
        private CatfishRESTAPI mCatfishRestAPI;
        private boolean mChannelCompleted;
        private boolean mInWaitBlock;
        public int scheduleNum;

        public DownloadDataChunks() {
            this.mChannelCompleted = false;
            this.mAge = 0;
            this.mInWaitBlock = false;
            this.mCatfishRestAPI = null;
            this.scheduleNum = 0;
            this.mAge = System.currentTimeMillis();
            this.mInWaitBlock = false;
        }

        public void dropRunnable() {
            /* JADX: method processing error */
/*
Error: java.util.NoSuchElementException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1431)
	at java.util.HashMap$KeyIterator.next(HashMap.java:1453)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.applyRemove(BlockFinallyExtract.java:535)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.extractFinally(BlockFinallyExtract.java:175)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.processExceptionHandler(BlockFinallyExtract.java:80)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.visit(BlockFinallyExtract.java:51)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:31)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:17)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:280)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler$1.run(JadxDecompiler.java:167)
*/
            /*
            r4 = this;
            r0 = "P2PDownloadExecutor";
            r1 = "P2P Download: DROP BY SERVICE !!!";
            com.catfiz.util.Log.d(r0, r1);
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r1.mSequence;
            r1 = java.lang.String.valueOf(r2);
            r2 = 0;
            r0.deleteTaskState(r1, r2);
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mService;
            r0 = android.support.v4.content.LocalBroadcastManager.getInstance(r0);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mCancelReceiver;
            r0.unregisterReceiver(r1);
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mFileOutputStream;
            if (r0 != 0) goto L_0x0033;
        L_0x0032:
            return;
        L_0x0033:
            r0 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r0 = r0.mFileOutputStream;	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r0.flush();	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r0 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r0 = r0.mFileOutputStream;	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r0.close();	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r0 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r1 = 0;	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r0.mFileOutputStream = r1;	 Catch:{ IOException -> 0x0061, all -> 0x0078 }
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mRcvFile;
            r0 = r0.exists();
            if (r0 == 0) goto L_0x0032;
        L_0x0057:
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mRcvFile;
            r0.delete();
            goto L_0x0032;
        L_0x0061:
            r0 = move-exception;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mRcvFile;
            r0 = r0.exists();
            if (r0 == 0) goto L_0x0032;
        L_0x006e:
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mRcvFile;
            r0.delete();
            goto L_0x0032;
        L_0x0078:
            r0 = move-exception;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x008e;
        L_0x0085:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
        L_0x008e:
            throw r0;
            */
            throw new UnsupportedOperationException("Method not decompiled: com.catfiz.service.P2PDownloadExecutor.DownloadDataChunks.dropRunnable():void");
        }

        public long getAge() {
            return this.mAge;
        }

        public String getChannelId() {
            return String.valueOf(P2PDownloadExecutor.this.mChannelId);
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public boolean isInDeepWait() {
            return false;
        }

        public void proceedToCompleted() {
            P2PDownloadExecutor.this.mService.cancelWaitP2PReceiver(P2PDownloadExecutor.this.mChannelId);
            try {
                P2PDownloadExecutor.this.mFileOutputStream.flush();
                P2PDownloadExecutor.this.mFileOutputStream.close();
                P2PDownloadExecutor.this.mFileOutputStream = null;
            } catch (IOException e) {
            }
            String extension = Utils.getExtension(P2PDownloadExecutor.this.mRcvFile.getAbsolutePath());
            MediaScanOnlyNotifier mediaScanOnlyNotifier = new MediaScanOnlyNotifier(P2PDownloadExecutor.this.mService, P2PDownloadExecutor.this.mRcvFile.getAbsolutePath(), extension == null ? "*/*" : Utils.getmimetypeFromExtension(extension));
            switch (P2PDownloadExecutor.this.mByteStreamType) {
                case e.b /*1*/:
                    new ImageThumbnailer(P2PDownloadExecutor.this.mService, P2PDownloadExecutor.this.mSenderpin, P2PDownloadExecutor.this.mByteStreamType) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(uri));
                                Log.d(P2PDownloadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                                return;
                            }
                            P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(null));
                            Log.d(P2PDownloadExecutor.TAG, "Thumbnail FAIL to create");
                        }
                    }.execute(new Uri[]{Uri.fromFile(P2PDownloadExecutor.this.mRcvFile)});
                    return;
                case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                    new ImageThumbnailer(P2PDownloadExecutor.this.mService, P2PDownloadExecutor.this.mSenderpin, P2PDownloadExecutor.this.mByteStreamType, true, P2PDownloadExecutor.this.mRcvFile.getAbsolutePath()) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(uri));
                                Log.d(P2PDownloadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                                return;
                            }
                            Log.d(P2PDownloadExecutor.TAG, "Thumbnail FAIL to create");
                            P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(null));
                        }
                    }.execute(new Uri[]{Uri.fromFile(P2PDownloadExecutor.this.mRcvFile)});
                    return;
                case HttpRouteDirector.LAYER_PROTOCOL /*5*/:
                    extension = P2PDownloadExecutor.this.mRcvFile.getName();
                    Log.d(P2PDownloadExecutor.TAG, "url :" + extension);
                    if (Utils.getFileTypeFromPath(extension) == 1) {
                        new ImageThumbnailer(P2PDownloadExecutor.this.mService, P2PDownloadExecutor.this.mSenderpin, P2PDownloadExecutor.this.mByteStreamType) {
                            protected void onPostExecute(Uri uri) {
                                if (uri != null) {
                                    P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(uri));
                                    Log.d(P2PDownloadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                                    return;
                                }
                                P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(null));
                                Log.d(P2PDownloadExecutor.TAG, "Thumbnail FAIL to create");
                            }
                        }.execute(new Uri[]{Uri.fromFile(P2PDownloadExecutor.this.mRcvFile)});
                        return;
                    } else if (Utils.getFileTypeFromPath(extension) == 6) {
                        Log.d(P2PDownloadExecutor.TAG, "video lewat data masuk ga");
                        new ImageThumbnailer(P2PDownloadExecutor.this.mService, P2PDownloadExecutor.this.mSenderpin, P2PDownloadExecutor.this.mByteStreamType, true, P2PDownloadExecutor.this.mRcvFile.getAbsolutePath()) {
                            protected void onPostExecute(Uri uri) {
                                if (uri != null) {
                                    P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(uri));
                                    Log.d(P2PDownloadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                                    return;
                                }
                                Log.d(P2PDownloadExecutor.TAG, "Thumbnail FAIL to create");
                                P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(null));
                            }
                        }.execute(new Uri[]{Uri.fromFile(P2PDownloadExecutor.this.mRcvFile)});
                        return;
                    } else {
                        P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(null));
                        return;
                    }
                default:
                    P2PDownloadExecutor.this.mService.postRunnableToDbThread(new SetNotificationMessageInDB(null));
                    return;
            }
        }

        public void run() {
            /* JADX: method processing error */
/*
Error: java.util.NoSuchElementException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1431)
	at java.util.HashMap$KeyIterator.next(HashMap.java:1453)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.applyRemove(BlockFinallyExtract.java:535)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.extractFinally(BlockFinallyExtract.java:175)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.processExceptionHandler(BlockFinallyExtract.java:80)
	at jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.visit(BlockFinallyExtract.java:51)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:31)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:17)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:280)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler$1.run(JadxDecompiler.java:167)
*/
            /*
            r13 = this;
            r12 = 2;
            r11 = 0;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mCancel;
            if (r0 == 0) goto L_0x0088;
        L_0x000a:
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r1.mSequence;
            r1 = java.lang.String.valueOf(r2);
            r0.deleteTaskState(r1, r11);
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mService;
            r0 = android.support.v4.content.LocalBroadcastManager.getInstance(r0);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mCancelReceiver;
            r0.unregisterReceiver(r1);
            r0 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r0 = r0.mFileOutputStream;	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r0.flush();	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r0 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r0 = r0.mFileOutputStream;	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r0.close();	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r0 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r1 = 0;	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r0.mFileOutputStream = r1;	 Catch:{ IOException -> 0x005a, all -> 0x0071 }
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mRcvFile;
            r0 = r0.exists();
            if (r0 == 0) goto L_0x0059;
        L_0x0050:
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mRcvFile;
            r0.delete();
        L_0x0059:
            return;
        L_0x005a:
            r0 = move-exception;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mRcvFile;
            r0 = r0.exists();
            if (r0 == 0) goto L_0x0059;
        L_0x0067:
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mRcvFile;
            r0.delete();
            goto L_0x0059;
        L_0x0071:
            r0 = move-exception;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x0087;
        L_0x007e:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
        L_0x0087:
            throw r0;
        L_0x0088:
            r1 = r13.mCatfishRestAPI;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r0.mServer;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r3 = r0.mUserpin;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r4 = r0.mSenderpin;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r5 = r0.mByteStreamType;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r6 = r0.mChannelId;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r8 = r0.mByteStart;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r9 = r0.mByteEnd;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r10 = r0.mFileOutputStream;
            r0 = r1.p2pGet(r2, r3, r4, r5, r6, r8, r9, r10);
            r1 = r0.hasFailure();
            if (r1 == 0) goto L_0x01a8;
        L_0x00c4:
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download: FAIL: Re schedule in P2P !!!";
            com.catfiz.util.Log.d(r1, r2);
            r1 = r0.chunksize;
            if (r1 <= 0) goto L_0x0180;
        L_0x00cf:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r3 = r0.chunksize;
            r2 = r2 + r3;
            r1.mWriten = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r1.mByteStart = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r3 = com.catfiz.service.P2PDownloadExecutor.mChunkMaxSize;
            r2 = r2 + r3;
            r2 = r2 + -1;
            r1.mByteEnd = r2;
            r1 = "P2PDownloadExecutor";
            r2 = new java.lang.StringBuilder;
            r2.<init>();
            r3 = "(IN FAILURE): DataSize = ";
            r2 = r2.append(r3);
            r3 = com.catfiz.service.P2PDownloadExecutor.this;
            r3 = r3.mDataSize;
            r3 = java.lang.String.valueOf(r3);
            r2 = r2.append(r3);
            r3 = ", Writen = ";
            r2 = r2.append(r3);
            r3 = com.catfiz.service.P2PDownloadExecutor.this;
            r3 = r3.mWriten;
            r3 = java.lang.String.valueOf(r3);
            r2 = r2.append(r3);
            r2 = r2.toString();
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mWriten;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mDataSize;
            if (r1 < r2) goto L_0x016f;
        L_0x013e:
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download: COMPLETE (In Failure)";
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mSequence;
            r2 = java.lang.String.valueOf(r2);
            r1.deleteTaskState(r2, r11);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r1 = android.support.v4.content.LocalBroadcastManager.getInstance(r1);
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mCancelReceiver;
            r1.unregisterReceiver(r2);
            r13.proceedToCompleted();
            r0.cleaningup();
            goto L_0x0059;
        L_0x016f:
            r0 = java.lang.System.currentTimeMillis();
            r13.mAge = r0;
            r0 = com.catfiz.service.P2PDownloadExecutor.this;
            r0 = r0.mService;
            r0.postToServiceHandler(r13, r12);
            goto L_0x0059;
        L_0x0180:
            r1 = com.catfiz.service.P2PDownloadExecutor.mChunkMaxSize;
            r1 = com.catfiz.service.CatfishRESTAPI.fallbackChunkSize(r1);
            com.catfiz.service.P2PDownloadExecutor.mChunkMaxSize = r1;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.CatfishService.getServerHost();
            r1.mServer = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mChannelId;
            r1.putWaitP2PReceiver(r2, r13);
        L_0x01a3:
            r0.cleaningup();
            goto L_0x0059;
        L_0x01a8:
            r1 = r0.hasWaitBlock();
            if (r1 == 0) goto L_0x02f6;
        L_0x01ae:
            r1 = r13.mChannelCompleted;
            if (r1 == 0) goto L_0x02f6;
        L_0x01b2:
            r1 = r0.chunksize;
            if (r1 <= 0) goto L_0x01e7;
        L_0x01b6:
            r2 = java.lang.System.currentTimeMillis();
            r13.mAge = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r3 = r0.chunksize;
            r2 = r2 + r3;
            r1.mWriten = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r1.mByteStart = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r3 = com.catfiz.service.P2PDownloadExecutor.mChunkMaxSize;
            r2 = r2 + r3;
            r2 = r2 + -1;
            r1.mByteEnd = r2;
        L_0x01e7:
            r1 = "P2PDownloadExecutor";
            r2 = new java.lang.StringBuilder;
            r2.<init>();
            r3 = "DataSize = ";
            r2 = r2.append(r3);
            r3 = com.catfiz.service.P2PDownloadExecutor.this;
            r3 = r3.mDataSize;
            r3 = java.lang.String.valueOf(r3);
            r2 = r2.append(r3);
            r3 = ", Writen = ";
            r2 = r2.append(r3);
            r3 = com.catfiz.service.P2PDownloadExecutor.this;
            r3 = r3.mWriten;
            r3 = java.lang.String.valueOf(r3);
            r2 = r2.append(r3);
            r2 = r2.toString();
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mWriten;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mDataSize;
            if (r1 < r2) goto L_0x0259;
        L_0x022b:
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download: COMPLETE (Last Block)";
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mSequence;
            r2 = java.lang.String.valueOf(r2);
            r1.deleteTaskState(r2, r11);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r1 = android.support.v4.content.LocalBroadcastManager.getInstance(r1);
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mCancelReceiver;
            r1.unregisterReceiver(r2);
            r13.proceedToCompleted();
            goto L_0x01a3;
        L_0x0259:
            r1 = r0.chunksize;
            if (r1 <= 0) goto L_0x026f;
        L_0x025d:
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download: SELF POST TO GET NEXT CHUNk";
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r1.postToServiceHandler(r13, r12);
            goto L_0x01a3;
        L_0x026f:
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download(1): ERROR: NULL DATA: DROP !!!";
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mSequence;
            r2 = java.lang.String.valueOf(r2);
            r1.deleteTaskState(r2, r11);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r1 = android.support.v4.content.LocalBroadcastManager.getInstance(r1);
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mCancelReceiver;
            r1.unregisterReceiver(r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r1 = r1.mFileOutputStream;	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r1.flush();	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r1 = r1.mFileOutputStream;	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r1.close();	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r2 = 0;	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r1.mFileOutputStream = r2;	 Catch:{ IOException -> 0x02c7, all -> 0x02df }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x01a3;
        L_0x02bc:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
            goto L_0x01a3;
        L_0x02c7:
            r1 = move-exception;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x01a3;
        L_0x02d4:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
            goto L_0x01a3;
        L_0x02df:
            r0 = move-exception;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x02f5;
        L_0x02ec:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
        L_0x02f5:
            throw r0;
        L_0x02f6:
            r1 = r0.hasSuccess();
            if (r1 != 0) goto L_0x0306;
        L_0x02fc:
            r1 = r0.hasWaitBlock();
            if (r1 != 0) goto L_0x0306;
        L_0x0302:
            r1 = r13.mChannelCompleted;
            if (r1 == 0) goto L_0x0479;
        L_0x0306:
            r2 = java.lang.System.currentTimeMillis();
            r13.mAge = r2;
            r1 = r0.chunksize;
            if (r1 <= 0) goto L_0x0346;
        L_0x0310:
            r1 = com.catfiz.service.P2PDownloadExecutor.mChunkMaxSize;
            r1 = com.catfiz.service.CatfishRESTAPI.growChunkSize(r1);
            com.catfiz.service.P2PDownloadExecutor.mChunkMaxSize = r1;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r3 = r0.chunksize;
            r2 = r2 + r3;
            r1.mWriten = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r1.mByteStart = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mWriten;
            r3 = com.catfiz.service.P2PDownloadExecutor.mChunkMaxSize;
            r2 = r2 + r3;
            r2 = r2 + -1;
            r1.mByteEnd = r2;
        L_0x0346:
            r1 = "P2PDownloadExecutor";
            r2 = new java.lang.StringBuilder;
            r2.<init>();
            r3 = "DataSize = ";
            r2 = r2.append(r3);
            r3 = com.catfiz.service.P2PDownloadExecutor.this;
            r3 = r3.mDataSize;
            r3 = java.lang.String.valueOf(r3);
            r2 = r2.append(r3);
            r3 = ", Writen = ";
            r2 = r2.append(r3);
            r3 = com.catfiz.service.P2PDownloadExecutor.this;
            r3 = r3.mWriten;
            r3 = java.lang.String.valueOf(r3);
            r2 = r2.append(r3);
            r2 = r2.toString();
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mWriten;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mDataSize;
            if (r1 >= r2) goto L_0x044b;
        L_0x038a:
            r1 = r0.hasWaitBlock();
            if (r1 == 0) goto L_0x03a8;
        L_0x0390:
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download: WAIT";
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mChannelId;
            r1.putWaitP2PReceiver(r2, r13);
            goto L_0x01a3;
        L_0x03a8:
            r1 = r0.chunksize;
            if (r1 <= 0) goto L_0x03c4;
        L_0x03ac:
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download: SELF POST TO GET NEXT CHUNk";
            com.catfiz.util.Log.d(r1, r2);
            r2 = java.lang.System.currentTimeMillis();
            r13.mAge = r2;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r1.postToServiceHandler(r13, r12);
            goto L_0x01a3;
        L_0x03c4:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mSequence;
            r2 = java.lang.String.valueOf(r2);
            r1.deleteTaskState(r2, r11);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r1 = android.support.v4.content.LocalBroadcastManager.getInstance(r1);
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mCancelReceiver;
            r1.unregisterReceiver(r2);
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download(2): ERROR: NULL DATA: DROP !!!";
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r1 = r1.mFileOutputStream;	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r1.flush();	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r1 = r1.mFileOutputStream;	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r1.close();	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r2 = 0;	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r1.mFileOutputStream = r2;	 Catch:{ IOException -> 0x041c, all -> 0x0434 }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x01a3;
        L_0x0411:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
            goto L_0x01a3;
        L_0x041c:
            r1 = move-exception;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x01a3;
        L_0x0429:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
            goto L_0x01a3;
        L_0x0434:
            r0 = move-exception;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x044a;
        L_0x0441:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
        L_0x044a:
            throw r0;
        L_0x044b:
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download: COMPLETE";
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mSequence;
            r2 = java.lang.String.valueOf(r2);
            r1.deleteTaskState(r2, r11);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r1 = android.support.v4.content.LocalBroadcastManager.getInstance(r1);
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mCancelReceiver;
            r1.unregisterReceiver(r2);
            r13.proceedToCompleted();
            goto L_0x01a3;
        L_0x0479:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mSequence;
            r2 = java.lang.String.valueOf(r2);
            r1.deleteTaskState(r2, r11);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mService;
            r1 = android.support.v4.content.LocalBroadcastManager.getInstance(r1);
            r2 = com.catfiz.service.P2PDownloadExecutor.this;
            r2 = r2.mCancelReceiver;
            r1.unregisterReceiver(r2);
            r1 = "P2PDownloadExecutor";
            r2 = "P2P Download: ERROR: DROP !!!";
            com.catfiz.util.Log.d(r1, r2);
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r1 = r1.mFileOutputStream;	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r1.flush();	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r1 = r1.mFileOutputStream;	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r1.close();	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r2 = 0;	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r1.mFileOutputStream = r2;	 Catch:{ IOException -> 0x04d1, all -> 0x04e9 }
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x01a3;
        L_0x04c6:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
            goto L_0x01a3;
        L_0x04d1:
            r1 = move-exception;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x01a3;
        L_0x04de:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
            goto L_0x01a3;
        L_0x04e9:
            r0 = move-exception;
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1 = r1.exists();
            if (r1 == 0) goto L_0x04ff;
        L_0x04f6:
            r1 = com.catfiz.service.P2PDownloadExecutor.this;
            r1 = r1.mRcvFile;
            r1.delete();
        L_0x04ff:
            throw r0;
            */
            throw new UnsupportedOperationException("Method not decompiled: com.catfiz.service.P2PDownloadExecutor.DownloadDataChunks.run():void");
        }

        public void setChannelCompleted(boolean z) {
            this.mChannelCompleted = z;
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.mCatfishRestAPI = catfishRESTAPI;
        }
    }

    class SendDeliveredNotificationToSender implements IDropableRunnable, Runnable {
        private long mAge;
        private CatfishRESTAPI mCatfishRestAPI;
        public int scheduleNum;

        private SendDeliveredNotificationToSender() {
            this.mAge = System.currentTimeMillis();
            this.mCatfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult notifyMessageDelivered = this.mCatfishRestAPI.notifyMessageDelivered(P2PDownloadExecutor.this.mServer, P2PDownloadExecutor.this.mUserpin, P2PDownloadExecutor.this.mSenderpin, P2PDownloadExecutor.this.mSequence);
            if (notifyMessageDelivered.hasFailure()) {
                Log.d(P2PDownloadExecutor.TAG, "P2P Notification Message to Sender: FAIL !!!: Re schedule");
                P2PDownloadExecutor.this.mServer = CatfishService.getServerHost();
                P2PDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else if (!notifyMessageDelivered.hasSuccess()) {
                Log.d(P2PDownloadExecutor.TAG, "P2P Notification Message to Sender: ERROR: DROP");
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.mCatfishRestAPI = catfishRESTAPI;
        }
    }

    class SetNotificationMessageInDB implements Runnable {
        private Uri mThumbUri = null;

        public SetNotificationMessageInDB(Uri uri) {
            this.mThumbUri = uri;
        }

        public void run() {
            String str;
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(P2PDownloadExecutor.this.mService);
            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(P2PDownloadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            Log.d(P2PDownloadExecutor.TAG, "mSenderpin : " + P2PDownloadExecutor.this.mSenderpin);
            obtain.userpin = P2PDownloadExecutor.this.mUserpin;
            obtain.senderpin = P2PDownloadExecutor.this.mSenderpin;
            obtain.messagetype = MessageType.MESSAGE;
            obtain.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
            obtain.deliverystatus = MessageDeliveryStatus.RECEIVED;
            obtain.sequence = P2PDownloadExecutor.this.mSequence;
            if (this.mThumbUri != null) {
                obtain.imagethumb_uri = this.mThumbUri.toString();
            }
            obtain.conversation_key = P2PDownloadExecutor.this.mUserpin + ":" + P2PDownloadExecutor.this.mSenderpin;
            switch (P2PDownloadExecutor.this.mByteStreamType) {
                case e.b /*1*/:
                    obtain.image_path = P2PDownloadExecutor.this.mRcvFile.getAbsolutePath();
                    obtain.message = P2PDownloadExecutor.this.mService.getResources().getString(R.string.photo_share);
                    break;
                case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                    obtain.datafile_path = P2PDownloadExecutor.this.mRcvFile.getAbsolutePath();
                    obtain.message = "Video chat " + P2PDownloadExecutor.this.mService.getResources().getString(R.string.file_received);
                    break;
                case HttpRouteDirector.TUNNEL_PROXY /*4*/:
                    obtain.voicefilepath = P2PDownloadExecutor.this.mRcvFile.getAbsolutePath();
                    obtain.message = P2PDownloadExecutor.this.mService.getResources().getString(R.string.voice_chat);
                    break;
                case HttpRouteDirector.LAYER_PROTOCOL /*5*/:
                    obtain.datafile_path = P2PDownloadExecutor.this.mRcvFile.getAbsolutePath();
                    obtain.message = P2PDownloadExecutor.this.mRcvFile.getName() + ":" + P2PDownloadExecutor.this.mService.getResources().getString(R.string.file_received);
                    if (P2PDownloadExecutor.this.mRcvFile.getName().endsWith("svg") || P2PDownloadExecutor.this.mRcvFile.getName().endsWith("svgz") || P2PDownloadExecutor.this.mRcvFile.getName().endsWith("svg.gz") || P2PDownloadExecutor.this.mRcvFile.getName().endsWith(".sticker")) {
                        obtain.message = "";
                        break;
                    }
                case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                    String longMessage = LongMessageExecutor.getLongMessage(P2PDownloadExecutor.this.mSequence);
                    str = "";
                    if (!(longMessage == null || longMessage.isEmpty())) {
                        str = longMessage.substring(0, LongMessageExecutor.LONG_MESSAGE_CHAR_PREVIEW);
                    }
                    obtain.message = str;
                    obtain.datafile_path = null;
                    obtain.messagetype = MessageType.LONG_MESSAGE;
                    break;
            }
            Log.d(P2PDownloadExecutor.TAG, "-- READY TO SAVE P2P DATA --");
            catfishDataStorage.storeSingleMessage(obtain);
            obtain.conversation_key = P2PDownloadExecutor.this.mUserpin + ":" + P2PDownloadExecutor.this.mSenderpin;
            P2PDownloadExecutor.this.sendBroadcastIntent(obtain);
            friendListDataStorage.setFriendLastActivity(P2PDownloadExecutor.this.mSenderpin, obtain.rcvtimestamp);
            friendListDataStorage.updateActivityCount(P2PDownloadExecutor.this.mSenderpin, 600);
            Log.d(P2PDownloadExecutor.TAG, "ADD MESSAGE WITH SEQUENCE: " + String.valueOf(P2PDownloadExecutor.this.mSequence) + ", URI: " + obtain.imagethumb_uri);
            P2PDownloadExecutor.this.saveToNotificationDataList(obtain);
            str = Utils.getExtension(P2PDownloadExecutor.this.mRcvFile.getAbsolutePath());
            if (str == null) {
                str = "image/*";
            } else {
                Utils.getmimetypeFromExtension(str);
            }
            switch (P2PDownloadExecutor.this.mByteStreamType) {
                case e.b /*1*/:
                    P2PDownloadExecutor.this.mService.signalImageFileReceived(P2PDownloadExecutor.this.mRcvFile.getAbsolutePath(), "image/*");
                    break;
                case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                    P2PDownloadExecutor.this.mService.signalDataFileReceived(P2PDownloadExecutor.this.mSenderpin);
                    break;
                case HttpRouteDirector.TUNNEL_PROXY /*4*/:
                    P2PDownloadExecutor.this.mService.signalVoiceChatReceived(P2PDownloadExecutor.this.mSenderpin);
                    break;
                case HttpRouteDirector.LAYER_PROTOCOL /*5*/:
                    P2PDownloadExecutor.this.mService.signalDataFileReceived(P2PDownloadExecutor.this.mSenderpin);
                    break;
                case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                    P2PDownloadExecutor.this.mService.signalDataFileReceived(P2PDownloadExecutor.this.mSenderpin);
                    break;
            }
            obtain.recycle();
            this.mThumbUri = null;
            P2PDownloadExecutor.this.mService.postToServiceHandler(new SendDeliveredNotificationToSender(), 2);
        }
    }

    public P2PDownloadExecutor(CatfishService catfishService, String str, String str2, String str3, long j, long j2) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mSenderpin = str3;
        this.mChannelId = j;
        this.mSequence = j2;
        this.mByteStart = 0;
        this.mByteEnd = mChunkMaxSize - 1;
        this.mAge = System.currentTimeMillis();
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_CHAT_DOWNLOAD));
    }

    private File getSafeFileName(File file, String str) {
        File file2 = new File(file, str);
        if (!file2.exists()) {
            return file2;
        }
        String[] split = str.split("\\.", 2);
        File file3 = file2;
        int i = 1;
        while (file3.exists()) {
            file3 = new File(file, split[0] + "-" + String.valueOf(i) + "." + split[1]);
            i++;
        }
        return file3;
    }

    public void dropRunnable() {
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        Log.d(TAG, "P2P Download: GET CHANNEL INFO: sender: ," + this.mSenderpin + ", channelid: " + String.valueOf(this.mChannelId));
        CatfishResult p2pGetChannelInfo = this.mCatfishRestAPI.p2pGetChannelInfo(this.mServer, this.mUserpin, this.mSenderpin, this.mChannelId);
        if (p2pGetChannelInfo.hasSuccess()) {
            if (this.mSenderpin.compareTo(p2pGetChannelInfo.p2p_senderpin) != 0) {
                Log.d(TAG, "P2P Download: INVALID SENDER: DROP !!!");
                p2pGetChannelInfo.cleaningup();
                return;
            }
            Log.d(TAG, "P2P Download: Create Output Stream");
            this.mByteStreamType = p2pGetChannelInfo.p2p_binarystream_type;
            this.mDataSize = p2pGetChannelInfo.p2p_datasize;
            File file;
            switch (this.mByteStreamType) {
                case e.b /*1*/:
                    try {
                        this.mPath = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/Pictures");
                        this.mPath.mkdirs();
                        this.mRcvFile = getSafeFileName(this.mPath, p2pGetChannelInfo.p2p_dataname);
                        break;
                    } catch (Exception e) {
                        Log.e(TAG, "Error: " + e.toString());
                        return;
                    }
                case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                    try {
                        this.mPath = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/com.catfiz/video");
                        this.mPath.mkdirs();
                        this.mRcvFile = getSafeFileName(this.mPath, p2pGetChannelInfo.p2p_dataname);
                        file = new File(this.mPath, ".nomedia");
                        if (!file.exists()) {
                            file.createNewFile();
                            break;
                        }
                    } catch (IOException e2) {
                        Log.e(TAG, "Error: " + e2.toString());
                        return;
                    }
                    break;
                case HttpRouteDirector.TUNNEL_PROXY /*4*/:
                    try {
                        this.mPath = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/com.catfiz/voice");
                        this.mPath.mkdirs();
                        this.mRcvFile = getSafeFileName(this.mPath, p2pGetChannelInfo.p2p_dataname);
                        file = new File(this.mPath, ".nomedia");
                        if (!file.exists()) {
                            file.createNewFile();
                            break;
                        }
                    } catch (IOException e22) {
                        Log.e(TAG, "Error: " + e22.toString());
                        return;
                    }
                    break;
                case HttpRouteDirector.LAYER_PROTOCOL /*5*/:
                    try {
                        this.mPath = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + CFURLSpan.CATFIZ_DOWNLOAD_PATH);
                        this.mPath.mkdirs();
                        this.mRcvFile = getSafeFileName(this.mPath, p2pGetChannelInfo.p2p_dataname);
                        break;
                    } catch (Exception e3) {
                        Log.e(TAG, "Error: " + e3.toString());
                        return;
                    }
                case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                    try {
                        this.mPath = new File(LongMessageExecutor.getTextDirPath());
                        this.mPath.mkdirs();
                        this.mRcvFile = getSafeFileName(this.mPath, String.valueOf(this.mSequence));
                        file = new File(this.mPath, ".nomedia");
                        if (!file.exists()) {
                            file.createNewFile();
                            break;
                        }
                    } catch (IOException e222) {
                        Log.e(TAG, "Error: " + e222.toString());
                        return;
                    }
                    break;
                default:
                    Log.d(TAG, "P2P Download: UNSUPPORTED STREAM TYPE: DROP !!!");
                    p2pGetChannelInfo.cleaningup();
                    return;
            }
            try {
                if (isResumeProcess()) {
                    this.mRcvFile = new File(this.mPath, p2pGetChannelInfo.p2p_dataname);
                    if (this.mRcvFile.exists()) {
                        this.mFileOutputStream = new FileOutputStream(this.mRcvFile, true);
                        this.mWriten = (int) this.mRcvFile.length();
                        this.mByteStart = this.mWriten;
                        this.mByteEnd = (this.mByteStart + mChunkMaxSize) - 1;
                    } else {
                        this.mFileOutputStream = new FileOutputStream(this.mRcvFile);
                    }
                } else {
                    this.mFileOutputStream = new FileOutputStream(this.mRcvFile);
                }
            } catch (FileNotFoundException e4) {
            }
            updateTaskState(String.valueOf(this.mSequence), this.mRcvFile.getAbsolutePath(), this.mDataSize, this.mByteStreamType, String.valueOf(this.mChannelId), this.mSenderpin, false);
            Log.d(TAG, "P2P Download: Wait to download Chunks");
            this.mService.putWaitP2PReceiver(this.mChannelId, new DownloadDataChunks());
        } else if (p2pGetChannelInfo.hasFailure()) {
            Log.d(TAG, "P2P Download: FAIL: Re schedule !!!");
            this.mServer = CatfishService.getServerHost();
            this.mService.scheduleRunnableToService(this, 2);
        } else {
            Log.d(TAG, "P2P Download: ERROR: DROP !!!");
        }
        p2pGetChannelInfo.cleaningup();
    }

    public void saveToNotificationDataList(CatfishMessageObject catfishMessageObject) {
        ArrayList notificationMsgList = this.mService.getNotificationMsgList();
        ArrayList notificationNameList = this.mService.getNotificationNameList();
        String str = "";
        str = "";
        str = catfishMessageObject.sendername;
        if (catfishMessageObject.senderpin != null && catfishMessageObject.senderpin.equals(CatfishService.OFFICIAL_PIN)) {
            str = this.mService.getResources().getString(R.string.official_name);
        }
        if (str == null || str.isEmpty()) {
            Cursor friend = new FriendListDataStorage(this.mService).getFriend(catfishMessageObject.senderpin);
            if (friend == null || friend.getCount() <= 0) {
                str = catfishMessageObject.senderpin;
            } else {
                friend.moveToFirst();
                str = friend.getString(friend.getColumnIndex(FriendListDataStorage.FRIENDNAME));
                friend.close();
            }
        }
        if (!notificationNameList.contains(str)) {
            notificationNameList.add(str);
        }
        String str2 = catfishMessageObject.senderpin;
        str = str + '\u0007' + catfishMessageObject.message;
        Log.d(TAG, "mo.messagetype:" + catfishMessageObject.messagetype + " mo.messagetype.ordinal():" + catfishMessageObject.messagetype.ordinal());
        if (str == null || str.isEmpty()) {
            Log.d(TAG, "msg null on save message to notification msg");
        } else {
            notificationMsgList.add(str);
        }
        if (notificationMsgList.size() > 6) {
            notificationMsgList.remove(0);
        }
        this.mService.setNotificationMsgList(notificationMsgList);
        this.mService.setNotificationNameList(notificationNameList);
        SharedPreferences defaultSharedPreferences = PreferenceManager.getDefaultSharedPreferences(this.mService);
        defaultSharedPreferences.edit().putInt("chatNotificationCount", defaultSharedPreferences.getInt("chatNotificationCount", 0) + 1).commit();
        defaultSharedPreferences.edit().putString("chatNotificationLastUser", str2).commit();
    }

    public void sendBroadcastIntent(CatfishMessageObject catfishMessageObject) {
        if (catfishMessageObject == null || catfishMessageObject.message == null || !catfishMessageObject.message.equals(StatusDataBcastUploadExecutor.ID_LONGMESSAGE)) {
            Intent intent = new Intent();
            intent.putExtra(TaskDataStorage.SENDERPIN, catfishMessageObject.senderpin);
            intent.putExtra(ServerMessageDataStorage.SENDERNAME, catfishMessageObject.sendername);
            intent.putExtra("conversation_key", catfishMessageObject.conversation_key);
            intent.putExtra("image_path", catfishMessageObject.image_path);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, catfishMessageObject.sequence);
            intent.putExtra("imagethumb_uri", catfishMessageObject.imagethumb_uri);
            intent.putExtra(ServerMessageDataStorage.VOICEFILEPATH, catfishMessageObject.voicefilepath);
            intent.putExtra("datafile_path", catfishMessageObject.datafile_path);
            intent.putExtra(ServerMessageDataStorage.MESSAGE, "");
            intent.putExtra(TaskDataStorage.MESSAGETYPE, catfishMessageObject.messagetype.ordinal());
            intent.putExtra("rcvtimestamp", catfishMessageObject.rcvtimestamp);
            intent.putExtra("object_owner", catfishMessageObject.object_owner);
            intent.putExtra("object_sequence", catfishMessageObject.object_sequence);
            intent.setAction(BroadcastIntents.ACTION_CHAT_MEDIA);
            this.mService.sendBroadcast(intent);
            Log.d(TAG, "convkey : " + catfishMessageObject.conversation_key);
            Log.e(TAG, "SEND BROADCAST MEDIA FROM CHAT : P2P");
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.mCatfishRestAPI = catfishRESTAPI;
    }
}

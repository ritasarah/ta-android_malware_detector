package com.catfiz.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.support.v4.content.LocalBroadcastManager;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.albus.util.AlbusModelObject;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.media.CatfishPhotoStorage;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.objectcomment.ObjectCommentDataStorage;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.Log;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import org.apache.http.HttpStatus;
import org.json.JSONObject;

public class StatusDataBcastDLoadExecutor implements IDropableRunnable, Runnable {
    private static final String LONG_MESSAGE = "_longmessage_";
    private static final String TAG = "StatusDataBcastDLoadExecutor";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    public static final String mParentPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ);
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = 0;
    private int mByteend = 0;
    private int mBytestart = 0;
    private BroadcastReceiver mCancelDownloadReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String stringExtra = intent.getStringExtra(CatfishRESTAPI.CFCOMPACT_STICKERID);
            Log.d(StatusDataBcastDLoadExecutor.TAG, "id : " + stringExtra);
            if (stringExtra == null) {
                Log.d(StatusDataBcastDLoadExecutor.TAG, "INVALID ID (NULL): DO NOT CANCEL");
            } else if (StatusDataBcastDLoadExecutor.this.mIdRecord == null || !StatusDataBcastDLoadExecutor.this.mIdRecord.equals(stringExtra)) {
                Log.d(StatusDataBcastDLoadExecutor.TAG, "Current ID is NULL: DO NOT CANCEL");
            } else {
                Log.d(StatusDataBcastDLoadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- id-NYA = " + stringExtra + " midrecord=" + StatusDataBcastDLoadExecutor.this.mIdRecord);
                StatusDataBcastDLoadExecutor.this.mbCancelDownload = true;
            }
        }
    };
    private byte[] mChunkbuffer = null;
    private FileOutputStream mChunkstream = null;
    private File mDataFile = null;
    private String mDataPath = null;
    private int mDatasize = 0;
    private String mIdRecord = null;
    private String mMessage = null;
    private String mObjOwner = null;
    private long mObjSequence = 0;
    private String mSendername = null;
    private String mSenderpin = null;
    private long mSequence = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private String mSlink = null;
    private long mStsSequence = 0;
    private String mTipe = null;
    private String mUserpin = null;
    private int mWriten = 0;
    private boolean mbCancelDownload = false;
    public int scheduleNum = 0;

    class DeleteDownloadFlag implements Runnable {
        private DeleteDownloadFlag() {
        }

        public void run() {
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(StatusDataBcastDLoadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            obtain.message = StatusDataBcastDLoadExecutor.this.mIdRecord;
            catfishDataStorage.setStatusDownloadFlag(obtain, Extra.ERROR);
            obtain.recycle();
        }
    }

    class GetDataStorageChunks implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private GetDataStorageChunks() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).unregisterReceiver(StatusDataBcastDLoadExecutor.this.mCancelDownloadReceiver);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            Log.d(StatusDataBcastDLoadExecutor.TAG, "cancel download is :" + StatusDataBcastDLoadExecutor.this.mbCancelDownload);
            if (StatusDataBcastDLoadExecutor.this.mbCancelDownload) {
                LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).unregisterReceiver(StatusDataBcastDLoadExecutor.this.mCancelDownloadReceiver);
                Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
                intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                intent.putExtra(CatfishService.PROGRESS_ID, StatusDataBcastDLoadExecutor.this.mIdRecord);
                LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).sendBroadcast(intent);
                try {
                    StatusDataBcastDLoadExecutor.this.mChunkstream.flush();
                    StatusDataBcastDLoadExecutor.this.mChunkstream.close();
                } catch (IOException e) {
                }
                if (StatusDataBcastDLoadExecutor.this.mDataFile != null && StatusDataBcastDLoadExecutor.this.mDataFile.exists()) {
                    StatusDataBcastDLoadExecutor.this.mDataFile.delete();
                }
                StatusDataBcastDLoadExecutor.this.mChunkbuffer = null;
                StatusDataBcastDLoadExecutor.this.mService.postRunnableToDbThread(new DeleteDownloadFlag());
                return;
            }
            Log.d(StatusDataBcastDLoadExecutor.TAG, "Get byte range: bs=" + String.valueOf(StatusDataBcastDLoadExecutor.this.mBytestart) + ", " + "be=" + String.valueOf(StatusDataBcastDLoadExecutor.this.mByteend) + ", " + "size=" + String.valueOf(StatusDataBcastDLoadExecutor.this.mDatasize) + ", " + "mWriten=" + String.valueOf(StatusDataBcastDLoadExecutor.this.mWriten));
            CatfishResult downloadDataChunk = this.catfishRestAPI.downloadDataChunk(StatusDataBcastDLoadExecutor.this.mServer, StatusDataBcastDLoadExecutor.this.mUserpin, StatusDataBcastDLoadExecutor.this.mSenderpin, StatusDataBcastDLoadExecutor.this.mObjSequence, StatusDataBcastDLoadExecutor.this.mBytestart, StatusDataBcastDLoadExecutor.this.mByteend, StatusDataBcastDLoadExecutor.this.mChunkstream);
            if (StatusDataBcastDLoadExecutor.this.mbCancelDownload) {
                LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).unregisterReceiver(StatusDataBcastDLoadExecutor.this.mCancelDownloadReceiver);
                intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
                intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                intent.putExtra(CatfishService.PROGRESS_ID, StatusDataBcastDLoadExecutor.this.mIdRecord);
                LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).sendBroadcast(intent);
                try {
                    StatusDataBcastDLoadExecutor.this.mChunkstream.flush();
                    StatusDataBcastDLoadExecutor.this.mChunkstream.close();
                } catch (IOException e2) {
                }
                if (StatusDataBcastDLoadExecutor.this.mDataFile != null && StatusDataBcastDLoadExecutor.this.mDataFile.exists()) {
                    StatusDataBcastDLoadExecutor.this.mDataFile.delete();
                }
                StatusDataBcastDLoadExecutor.this.mChunkbuffer = null;
                StatusDataBcastDLoadExecutor.this.mService.postRunnableToDbThread(new DeleteDownloadFlag());
                return;
            }
            Log.d(StatusDataBcastDLoadExecutor.TAG, "Chunksize: " + String.valueOf(downloadDataChunk.chunksize));
            int access$1200;
            Intent intent2;
            if (downloadDataChunk.hasSuccess()) {
                this.mAge = System.currentTimeMillis();
                if (downloadDataChunk.chunksize > 0) {
                    StatusDataBcastDLoadExecutor.this.mWriten = StatusDataBcastDLoadExecutor.this.mWriten + downloadDataChunk.chunksize;
                }
                access$1200 = (StatusDataBcastDLoadExecutor.this.mWriten * 100) / StatusDataBcastDLoadExecutor.this.mDatasize;
                intent2 = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
                intent2.putExtra(CatfishService.PROGRESS_VALUE, access$1200);
                intent2.putExtra(CatfishService.PROGRESS_ID, StatusDataBcastDLoadExecutor.this.mIdRecord);
                LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).sendBroadcast(intent2);
                if (StatusDataBcastDLoadExecutor.this.mWriten < StatusDataBcastDLoadExecutor.this.mDatasize) {
                    StatusDataBcastDLoadExecutor.mChunkMaxSize = CatfishRESTAPI.growChunkSize(StatusDataBcastDLoadExecutor.mChunkMaxSize);
                    StatusDataBcastDLoadExecutor.this.mBytestart = StatusDataBcastDLoadExecutor.this.mWriten;
                    StatusDataBcastDLoadExecutor.this.mByteend = (StatusDataBcastDLoadExecutor.this.mBytestart + StatusDataBcastDLoadExecutor.mChunkMaxSize) - 1;
                    StatusDataBcastDLoadExecutor.this.mService.postToServiceHandler(this, 2);
                    downloadDataChunk.cleaningup();
                    return;
                }
                Log.d(StatusDataBcastDLoadExecutor.TAG, "STATCOMM RECEIVE: Get Data Chunk: DONE");
                LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).unregisterReceiver(StatusDataBcastDLoadExecutor.this.mCancelDownloadReceiver);
                StatusDataBcastDLoadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(), 2);
                StatusDataBcastDLoadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDLUpdateDB());
                try {
                    StatusDataBcastDLoadExecutor.this.mChunkstream.flush();
                    StatusDataBcastDLoadExecutor.this.mChunkstream.close();
                } catch (IOException e3) {
                }
                StatusDataBcastDLoadExecutor.this.mChunkbuffer = null;
                downloadDataChunk.cleaningup();
            } else if (downloadDataChunk.hasFailure()) {
                Log.d(StatusDataBcastDLoadExecutor.TAG, "STATCOMM RECEIVE: Get Data Chunk: FAIL: Reschedule");
                if (downloadDataChunk.chunksize > 0) {
                    this.mAge = System.currentTimeMillis();
                    StatusDataBcastDLoadExecutor.this.mWriten = StatusDataBcastDLoadExecutor.this.mWriten + downloadDataChunk.chunksize;
                    access$1200 = (StatusDataBcastDLoadExecutor.this.mWriten * 100) / StatusDataBcastDLoadExecutor.this.mDatasize;
                    intent2 = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
                    intent2.putExtra(CatfishService.PROGRESS_VALUE, access$1200);
                    intent2.putExtra(CatfishService.PROGRESS_ID, StatusDataBcastDLoadExecutor.this.mIdRecord);
                    LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).sendBroadcast(intent2);
                    if (StatusDataBcastDLoadExecutor.this.mWriten < StatusDataBcastDLoadExecutor.this.mDatasize) {
                        StatusDataBcastDLoadExecutor.this.mBytestart = StatusDataBcastDLoadExecutor.this.mWriten;
                        StatusDataBcastDLoadExecutor.this.mByteend = (StatusDataBcastDLoadExecutor.this.mWriten + StatusDataBcastDLoadExecutor.mChunkMaxSize) - 1;
                        StatusDataBcastDLoadExecutor.this.mService.postToServiceHandler(this, 2);
                        downloadDataChunk.cleaningup();
                        return;
                    }
                    Log.d(StatusDataBcastDLoadExecutor.TAG, "STATCOMM RECEIVE (In FAILURE): Get Data Chunk: DONE");
                    LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).unregisterReceiver(StatusDataBcastDLoadExecutor.this.mCancelDownloadReceiver);
                    StatusDataBcastDLoadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(), 2);
                    try {
                        StatusDataBcastDLoadExecutor.this.mChunkstream.flush();
                        StatusDataBcastDLoadExecutor.this.mChunkstream.close();
                    } catch (IOException e4) {
                    }
                    downloadDataChunk.cleaningup();
                    return;
                }
                StatusDataBcastDLoadExecutor.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(StatusDataBcastDLoadExecutor.mChunkMaxSize);
                StatusDataBcastDLoadExecutor.this.mServer = CatfishService.getServerHost();
                StatusDataBcastDLoadExecutor.this.mService.scheduleRunnableToService(this, 2);
                downloadDataChunk.cleaningup();
            } else {
                Log.d(StatusDataBcastDLoadExecutor.TAG, "STATCOMM RECEIVE: Get Data Chunk: ERROR: DROP");
                LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).unregisterReceiver(StatusDataBcastDLoadExecutor.this.mCancelDownloadReceiver);
                Intent intent3 = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
                intent3.putExtra(CatfishService.PROGRESS_VALUE, 0);
                intent3.putExtra(CatfishService.PROGRESS_ID, StatusDataBcastDLoadExecutor.this.mIdRecord);
                intent3.putExtra(CatfishService.PROGRESS_STATE, 4);
                LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).sendBroadcast(intent3);
                try {
                    StatusDataBcastDLoadExecutor.this.mChunkstream.flush();
                    StatusDataBcastDLoadExecutor.this.mChunkstream.close();
                } catch (IOException e5) {
                }
                if (StatusDataBcastDLoadExecutor.this.mDataFile != null && StatusDataBcastDLoadExecutor.this.mDataFile.exists()) {
                    StatusDataBcastDLoadExecutor.this.mDataFile.delete();
                }
                StatusDataBcastDLoadExecutor.this.mChunkbuffer = null;
                StatusDataBcastDLoadExecutor.this.mService.postRunnableToDbThread(new DeleteDownloadFlag());
                downloadDataChunk.cleaningup();
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class GetSlinkFromServer implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        private boolean mIsSent;
        public int scheduleNum;
        private boolean send;

        private GetSlinkFromServer() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.send = true;
            this.mIsSent = false;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult slink = this.catfishRestAPI.getSlink(StatusDataBcastDLoadExecutor.this.mServer, StatusDataBcastDLoadExecutor.this.mUserpin, StatusDataBcastDLoadExecutor.this.mSenderpin, StatusDataBcastDLoadExecutor.this.mObjSequence);
            if (slink.hasSuccess()) {
                Log.e(StatusDataBcastDLoadExecutor.TAG, "slink content:" + StatusDataBcastDLoadExecutor.this.mSlink + " from result:" + slink.slink);
                StatusDataBcastDLoadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDLUpdateDB());
            } else if (slink.hasFailure()) {
                Log.d(StatusDataBcastDLoadExecutor.TAG, "----STATCOMM: FAILURE !!!: Re Schedule");
                StatusDataBcastDLoadExecutor.this.mServer = CatfishService.getServerHost();
                StatusDataBcastDLoadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(StatusDataBcastDLoadExecutor.TAG, "----STATCOMM: ERROR: DROP");
            }
            slink.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class VoiceBcastDLUpdateDB implements Runnable {
        private VoiceBcastDLUpdateDB() {
        }

        public void run() {
            int i = 0;
            if (StatusDataBcastDLoadExecutor.this.mTipe.equals(AlbusModelObject.IMAGE)) {
                ImageThumbnailer anonymousClass1 = new ImageThumbnailer(StatusDataBcastDLoadExecutor.this.mService, StatusDataBcastDLoadExecutor.this.mSenderpin, 1, 2.0f) {
                    protected void onPostExecute(Uri uri) {
                        if (uri != null) {
                            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(StatusDataBcastDLoadExecutor.this.mService);
                            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(StatusDataBcastDLoadExecutor.this.mService);
                            CatfishMessageObject obtain = CatfishMessageObject.obtain();
                            obtain.senderpin = StatusDataBcastDLoadExecutor.this.mSenderpin;
                            obtain.userpin = StatusDataBcastDLoadExecutor.this.mUserpin;
                            obtain.messagetype = MessageType.BCASTIMAGESTATUS;
                            obtain.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                            obtain.message = StatusDataBcastDLoadExecutor.this.mMessage;
                            obtain.deliverystatus = MessageDeliveryStatus.BCASTRECEIVED;
                            obtain.sequence = StatusDataBcastDLoadExecutor.this.mSequence;
                            obtain.object_sequence = StatusDataBcastDLoadExecutor.this.mObjSequence;
                            obtain.image_path = StatusDataBcastDLoadExecutor.this.mDataPath;
                            obtain.conversation_key = "sc:" + StatusDataBcastDLoadExecutor.this.mObjOwner + ":" + StatusDataBcastDLoadExecutor.this.mStsSequence;
                            obtain.sendername = StatusDataBcastDLoadExecutor.this.mSendername;
                            obtain.imagethumb_uri = uri.toString();
                            obtain.data_json = StatusDataBcastDLoadExecutor.this.mIdRecord;
                            obtain.slink = StatusDataBcastDLoadExecutor.this.mSlink;
                            if (StatusDataBcastDLoadExecutor.this.mIdRecord == null) {
                                catfishDataStorage.storeSingleMessage(obtain);
                            } else {
                                catfishDataStorage.updateStatusComent(obtain, AlbusModelObject.IMAGE);
                            }
                            StatusDataBcastDLoadExecutor.this.sendBroadcastIntent(obtain);
                            friendListDataStorage.updateActivityCount(StatusDataBcastDLoadExecutor.this.mUserpin, 100);
                            if ((StatusDataBcastDLoadExecutor.this.mObjOwner.compareTo(CatfishService.getUserPIN()) == 0 ? 1 : 0) != 0) {
                                StatusDataBcastDLoadExecutor.this.mService.signalHasCommentonStatus();
                            } else {
                                Bundle bundle = new Bundle();
                                bundle.putInt(StatusDataBcastDLoadExecutor.this.mSenderpin, MessageType.BCASTIMAGESTATUS.ordinal());
                                bundle.putString(obtain.senderpin + AlbusModelObject.OWNER, StatusDataBcastDLoadExecutor.this.mObjOwner);
                                StatusDataBcastDLoadExecutor.this.mService.signalHasNewMessage(1, bundle);
                                friendListDataStorage.setUnReadStatCommStatus(StatusDataBcastDLoadExecutor.this.mObjOwner, 1, obtain.rcvtimestamp);
                            }
                            obtain.recycle();
                        } else {
                            Log.d(StatusDataBcastDLoadExecutor.TAG, "Thumbnail FAIL to create");
                        }
                        try {
                            File file = new File(CatfishPhotoStorage.getImageStorageDir(StatusDataBcastDLoadExecutor.this.mService), ".nomedia");
                            if (!file.exists()) {
                                file.createNewFile();
                            }
                        } catch (IOException e) {
                            Log.e(StatusDataBcastDLoadExecutor.TAG, "Error:" + e.toString());
                        }
                    }
                };
                File file = new File(StatusDataBcastDLoadExecutor.this.mDataPath);
                anonymousClass1.execute(new Uri[]{Uri.fromFile(file)});
            } else if (StatusDataBcastDLoadExecutor.this.mTipe.equals(AlbusModelObject.DATA_TYPE_VIDEO)) {
                r0 = new CatfishDataStorage(StatusDataBcastDLoadExecutor.this.mService);
                r1 = new FriendListDataStorage(StatusDataBcastDLoadExecutor.this.mService);
                r2 = CatfishMessageObject.obtain();
                r2.senderpin = StatusDataBcastDLoadExecutor.this.mSenderpin;
                r2.userpin = StatusDataBcastDLoadExecutor.this.mUserpin;
                r2.messagetype = MessageType.BCASTVIDEOSTATUS;
                r2.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                r2.message = StatusDataBcastDLoadExecutor.this.mMessage;
                r2.deliverystatus = MessageDeliveryStatus.BCASTRECEIVED;
                r2.sequence = StatusDataBcastDLoadExecutor.this.mSequence;
                r2.object_sequence = StatusDataBcastDLoadExecutor.this.mObjSequence;
                r2.datafile_path = StatusDataBcastDLoadExecutor.this.mDataPath;
                r2.conversation_key = "sc:" + StatusDataBcastDLoadExecutor.this.mObjOwner + ":" + StatusDataBcastDLoadExecutor.this.mStsSequence;
                r2.sendername = StatusDataBcastDLoadExecutor.this.mSendername;
                r2.data_json = StatusDataBcastDLoadExecutor.this.mIdRecord;
                Log.e(StatusDataBcastDLoadExecutor.TAG, "slink to db:" + StatusDataBcastDLoadExecutor.this.mSlink);
                r2.slink = StatusDataBcastDLoadExecutor.this.mSlink;
                if (StatusDataBcastDLoadExecutor.this.mIdRecord == null) {
                    r0.storeSingleMessage(r2);
                } else {
                    r0.updateStatusComent(r2, AlbusModelObject.DATA_TYPE_VIDEO);
                }
                StatusDataBcastDLoadExecutor.this.sendBroadcastIntent(r2);
                r1.updateActivityCount(StatusDataBcastDLoadExecutor.this.mUserpin, 100);
                if (StatusDataBcastDLoadExecutor.this.mObjOwner.compareTo(CatfishService.getUserPIN()) == 0) {
                    i = 1;
                }
                if (i != 0) {
                    StatusDataBcastDLoadExecutor.this.mService.signalHasCommentonStatus();
                } else {
                    r0 = new Bundle();
                    r0.putInt(StatusDataBcastDLoadExecutor.this.mSenderpin, MessageType.BCASTVOICESTATUS.ordinal());
                    r0.putString(r2.senderpin + AlbusModelObject.OWNER, StatusDataBcastDLoadExecutor.this.mObjOwner);
                    StatusDataBcastDLoadExecutor.this.mService.signalHasNewMessage(1, r0);
                    r1.setUnReadStatCommStatus(StatusDataBcastDLoadExecutor.this.mObjOwner, 1, r2.rcvtimestamp);
                }
                r2.recycle();
            } else if (StatusDataBcastDLoadExecutor.this.mTipe.equals(AlbusModelObject.TEXT)) {
                Log.d(StatusDataBcastDLoadExecutor.TAG, "Long message:" + StatusDataBcastDLoadExecutor.this.mSequence + " " + StatusDataBcastDLoadExecutor.this.mMessage);
                CatfishDataStorage catfishDataStorage = new CatfishDataStorage(StatusDataBcastDLoadExecutor.this.mService);
                FriendListDataStorage friendListDataStorage = new FriendListDataStorage(StatusDataBcastDLoadExecutor.this.mService);
                CatfishMessageObject obtain = CatfishMessageObject.obtain();
                obtain.senderpin = StatusDataBcastDLoadExecutor.this.mSenderpin;
                obtain.userpin = StatusDataBcastDLoadExecutor.this.mUserpin;
                obtain.messagetype = MessageType.LONGSTATUSCOMMENT;
                obtain.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                obtain.message = StatusDataBcastDLoadExecutor.this.mMessage;
                obtain.deliverystatus = MessageDeliveryStatus.BCASTRECEIVED;
                obtain.sequence = StatusDataBcastDLoadExecutor.this.mSequence;
                obtain.object_sequence = StatusDataBcastDLoadExecutor.this.mObjSequence;
                obtain.datafile_path = null;
                obtain.conversation_key = "sc:" + StatusDataBcastDLoadExecutor.this.mObjOwner + ":" + StatusDataBcastDLoadExecutor.this.mStsSequence;
                obtain.sendername = StatusDataBcastDLoadExecutor.this.mSendername;
                obtain.data_json = StatusDataBcastDLoadExecutor.this.mIdRecord;
                String longMessage = LongMessageExecutor.getLongMessage(StatusDataBcastDLoadExecutor.this.mSequence);
                String str = "";
                if (!(longMessage == null || longMessage.isEmpty())) {
                    str = longMessage.substring(0, LongMessageExecutor.LONG_MESSAGE_CHAR_PREVIEW);
                }
                obtain.message = str;
                if (StatusDataBcastDLoadExecutor.this.mIdRecord == null) {
                    catfishDataStorage.storeSingleMessage(obtain);
                } else {
                    catfishDataStorage.updateStatusComent(obtain, AlbusModelObject.TEXT);
                }
                StatusDataBcastDLoadExecutor.this.sendBroadcastIntent(obtain);
                friendListDataStorage.updateActivityCount(StatusDataBcastDLoadExecutor.this.mUserpin, 100);
                if (StatusDataBcastDLoadExecutor.this.mObjOwner.compareTo(CatfishService.getUserPIN()) == 0) {
                    i = 1;
                }
                if (i != 0) {
                    StatusDataBcastDLoadExecutor.this.mService.signalHasCommentonStatus();
                } else {
                    r0 = new Bundle();
                    r0.putInt(StatusDataBcastDLoadExecutor.this.mSenderpin, MessageType.LONGSTATUSCOMMENT.ordinal());
                    r0.putString(obtain.senderpin + AlbusModelObject.OWNER, StatusDataBcastDLoadExecutor.this.mObjOwner);
                    StatusDataBcastDLoadExecutor.this.mService.signalHasNewMessage(1, r0);
                    friendListDataStorage.setUnReadStatCommStatus(StatusDataBcastDLoadExecutor.this.mObjOwner, 1, obtain.rcvtimestamp);
                }
                obtain.recycle();
            } else {
                r0 = new CatfishDataStorage(StatusDataBcastDLoadExecutor.this.mService);
                r1 = new FriendListDataStorage(StatusDataBcastDLoadExecutor.this.mService);
                r2 = CatfishMessageObject.obtain();
                r2.senderpin = StatusDataBcastDLoadExecutor.this.mSenderpin;
                r2.userpin = StatusDataBcastDLoadExecutor.this.mUserpin;
                r2.messagetype = MessageType.BCASTVOICESTATUS;
                r2.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                r2.message = StatusDataBcastDLoadExecutor.this.mMessage;
                r2.deliverystatus = MessageDeliveryStatus.BCASTRECEIVED;
                r2.sequence = StatusDataBcastDLoadExecutor.this.mSequence;
                r2.object_sequence = StatusDataBcastDLoadExecutor.this.mObjSequence;
                r2.voicefilepath = StatusDataBcastDLoadExecutor.this.mDataPath;
                r2.conversation_key = "sc:" + StatusDataBcastDLoadExecutor.this.mObjOwner + ":" + StatusDataBcastDLoadExecutor.this.mStsSequence;
                r2.sendername = StatusDataBcastDLoadExecutor.this.mSendername;
                r2.data_json = StatusDataBcastDLoadExecutor.this.mIdRecord;
                if (StatusDataBcastDLoadExecutor.this.mIdRecord == null) {
                    r0.storeSingleMessage(r2);
                } else {
                    r0.updateStatusComent(r2, AlbusModelObject.DATA_TYPE_VOICE);
                }
                StatusDataBcastDLoadExecutor.this.sendBroadcastIntent(r2);
                r1.updateActivityCount(StatusDataBcastDLoadExecutor.this.mUserpin, 100);
                if ((StatusDataBcastDLoadExecutor.this.mObjOwner.compareTo(CatfishService.getUserPIN()) == 0 ? 1 : 0) != 0) {
                    StatusDataBcastDLoadExecutor.this.mService.signalHasCommentonStatus();
                } else {
                    r0 = new Bundle();
                    r0.putInt(StatusDataBcastDLoadExecutor.this.mSenderpin, MessageType.BCASTVOICESTATUS.ordinal());
                    r0.putString(r2.senderpin + AlbusModelObject.OWNER, StatusDataBcastDLoadExecutor.this.mObjOwner);
                    StatusDataBcastDLoadExecutor.this.mService.signalHasNewMessage(1, r0);
                    r1.setUnReadStatCommStatus(StatusDataBcastDLoadExecutor.this.mObjOwner, 1, r2.rcvtimestamp);
                }
                r2.recycle();
            }
            Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
            intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
            intent.putExtra(CatfishService.PROGRESS_STATE, 2);
            intent.putExtra(CatfishService.PROGRESS_ID, StatusDataBcastDLoadExecutor.this.mIdRecord);
            LocalBroadcastManager.getInstance(StatusDataBcastDLoadExecutor.this.mService).sendBroadcast(intent);
        }
    }

    public StatusDataBcastDLoadExecutor(CatfishService catfishService, String str, String str2, String str3, String str4, String str5, long j, long j2, String str6, String str7) {
        long j3;
        Exception e;
        Intent intent;
        String str8 = "";
        this.mObjOwner = str6;
        this.mIdRecord = str7;
        try {
            JSONObject jSONObject = new JSONObject(str4);
            str8 = jSONObject.getString(ServerMessageDataStorage.MESSAGE);
            j3 = jSONObject.getLong(ObjectCommentDataStorage.OBJECTSEQUENCE);
            try {
                this.mTipe = jSONObject.getString("tipe");
                this.mSlink = jSONObject.getString(ServerMessageDataStorage.SLINK);
            } catch (Exception e2) {
                e = e2;
                Log.e(TAG, "Error : " + e.toString());
                this.mService = catfishService;
                this.mServer = str;
                this.mUserpin = str2;
                this.mSendername = str5;
                this.mSenderpin = str3;
                this.mMessage = str8;
                this.mSequence = j;
                this.mObjSequence = j3;
                this.mAge = System.currentTimeMillis();
                this.mStsSequence = j2;
                intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
                intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                intent.putExtra(CatfishService.PROGRESS_ID, this.mIdRecord);
                LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
                if (this.mTipe == null) {
                }
                if (this.mTipe == null) {
                }
                if (this.mTipe == null) {
                }
                this.mDataPath = mParentPath + "/voice/rvc" + str2 + String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence()) + ".3gp";
                this.mDataFile = new File(this.mDataPath);
                LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelDownloadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_STATUS_DOWNLOAD));
            }
        } catch (Exception e3) {
            e = e3;
            j3 = 0;
            Log.e(TAG, "Error : " + e.toString());
            this.mService = catfishService;
            this.mServer = str;
            this.mUserpin = str2;
            this.mSendername = str5;
            this.mSenderpin = str3;
            this.mMessage = str8;
            this.mSequence = j;
            this.mObjSequence = j3;
            this.mAge = System.currentTimeMillis();
            this.mStsSequence = j2;
            intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
            intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
            intent.putExtra(CatfishService.PROGRESS_ID, this.mIdRecord);
            LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
            if (this.mTipe == null) {
            }
            if (this.mTipe == null) {
            }
            if (this.mTipe == null) {
            }
            this.mDataPath = mParentPath + "/voice/rvc" + str2 + String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence()) + ".3gp";
            this.mDataFile = new File(this.mDataPath);
            LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelDownloadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_STATUS_DOWNLOAD));
        }
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mSendername = str5;
        this.mSenderpin = str3;
        this.mMessage = str8;
        this.mSequence = j;
        this.mObjSequence = j3;
        this.mAge = System.currentTimeMillis();
        this.mStsSequence = j2;
        intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
        intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
        intent.putExtra(CatfishService.PROGRESS_ID, this.mIdRecord);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        if (this.mTipe == null && this.mTipe.equals(AlbusModelObject.IMAGE)) {
            this.mDataPath = mParentPath + "/image/img" + str2 + String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence()) + ".jpg";
        } else if (this.mTipe == null && this.mTipe.equals(AlbusModelObject.DATA_TYPE_VIDEO)) {
            this.mDataPath = mParentPath + "/video/rvc" + str2 + String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence()) + ".3gp";
        } else if (this.mTipe == null && this.mTipe.equals(AlbusModelObject.TEXT)) {
            this.mDataPath = LongMessageExecutor.getTextDirPath() + String.valueOf(this.mSequence);
        } else {
            this.mDataPath = mParentPath + "/voice/rvc" + str2 + String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence()) + ".3gp";
        }
        this.mDataFile = new File(this.mDataPath);
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelDownloadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_STATUS_DOWNLOAD));
    }

    public void dropRunnable() {
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        String externalStorageState = Environment.getExternalStorageState();
        if (externalStorageState.equals("mounted")) {
            File parentFile = this.mDataFile.getParentFile();
            if (parentFile.exists() || parentFile.mkdirs()) {
                CatfishResult dataStorageInfo = this.catfishRestAPI.getDataStorageInfo(this.mServer, this.mUserpin, this.mSenderpin, this.mObjSequence);
                Log.d(TAG, "cancel download is " + this.mbCancelDownload);
                if (this.mbCancelDownload) {
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                    if (this.mDataFile != null && this.mDataFile.exists()) {
                        this.mDataFile.delete();
                    }
                    this.mService.postRunnableToDbThread(new DeleteDownloadFlag());
                    dataStorageInfo.cleaningup();
                    Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_STATUS);
                    intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                    intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                    intent.putExtra(CatfishService.PROGRESS_ID, this.mIdRecord);
                    LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
                    return;
                } else if (dataStorageInfo.hasFailure()) {
                    Log.d(TAG, "STATCOMM RECEIVE: Get Info FAIL: Reschedule !!!");
                    this.mServer = CatfishService.getServerHost();
                    this.mService.scheduleRunnableToService(this, 2);
                    dataStorageInfo.cleaningup();
                    return;
                } else if (dataStorageInfo.hasNotFound()) {
                    Log.d(TAG, "STATCOMM RECEIVE: NOT FOUND: DROP");
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                    if (this.mDataFile != null && this.mDataFile.exists()) {
                        this.mDataFile.delete();
                    }
                    this.mService.postRunnableToDbThread(new DeleteDownloadFlag());
                    dataStorageInfo.cleaningup();
                    return;
                } else if (!dataStorageInfo.hasSuccess()) {
                    Log.e(TAG, "STATCOMM RECEIVE: ERROR: DROP !!!");
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                    if (this.mDataFile != null && this.mDataFile.exists()) {
                        this.mDataFile.delete();
                    }
                    this.mService.postRunnableToDbThread(new DeleteDownloadFlag());
                    dataStorageInfo.cleaningup();
                    return;
                } else if (dataStorageInfo.datasize != dataStorageInfo.currentdatasize) {
                    Log.e(TAG, "STATCOMM RECEIVE: INVALID DATA SIZE: ds=" + dataStorageInfo.datasize + ", cds=" + dataStorageInfo.currentdatasize + ": DROP !!!");
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                    if (this.mDataFile != null && this.mDataFile.exists()) {
                        this.mDataFile.delete();
                    }
                    this.mService.postRunnableToDbThread(new DeleteDownloadFlag());
                    dataStorageInfo.cleaningup();
                    return;
                } else {
                    this.mDatasize = dataStorageInfo.datasize;
                    this.mByteend = mChunkMaxSize - 1;
                    try {
                        this.mChunkstream = new FileOutputStream(this.mDataFile);
                        this.mService.postToServiceHandler(new GetDataStorageChunks(), 2);
                        return;
                    } catch (FileNotFoundException e) {
                        Log.e(TAG, "STATCOMM RECEIVE: " + e.toString());
                        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                        if (this.mDataFile != null && this.mDataFile.exists()) {
                            this.mDataFile.delete();
                            return;
                        }
                        return;
                    }
                }
            }
            Log.e(TAG, "STATCOMM RECEIVE: Path to file could not be created.");
            LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
            return;
        }
        Log.e(TAG, "STATCOMM RECEIVE: media not mounted in is state: " + externalStorageState + ":DROP !!!");
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
    }

    public void sendBroadcastIntent(CatfishMessageObject catfishMessageObject) {
        if (catfishMessageObject == null || catfishMessageObject.message == null || !catfishMessageObject.message.equals(LONG_MESSAGE)) {
            Intent intent = new Intent();
            intent.putExtra(TaskDataStorage.SENDERPIN, catfishMessageObject.senderpin);
            intent.putExtra(ServerMessageDataStorage.SENDERNAME, catfishMessageObject.sendername);
            intent.putExtra("conversation_key", catfishMessageObject.conversation_key);
            intent.putExtra("image_path", catfishMessageObject.image_path);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, catfishMessageObject.sequence);
            intent.putExtra("imagethumb_uri", catfishMessageObject.imagethumb_uri);
            intent.putExtra(ServerMessageDataStorage.VOICEFILEPATH, catfishMessageObject.voicefilepath);
            intent.putExtra("datafile_path", catfishMessageObject.datafile_path);
            intent.putExtra(ServerMessageDataStorage.MESSAGE, catfishMessageObject.message);
            intent.putExtra(TaskDataStorage.MESSAGETYPE, catfishMessageObject.messagetype.ordinal());
            intent.putExtra("rcvtimestamp", catfishMessageObject.rcvtimestamp);
            intent.putExtra("object_owner", catfishMessageObject.object_owner);
            intent.putExtra("object_sequence", catfishMessageObject.object_sequence);
            intent.putExtra(ServerMessageDataStorage.SLINK, catfishMessageObject.slink);
            intent.setAction(BroadcastIntents.ACTION_STATUS_MEDIA);
            this.mService.sendBroadcast(intent);
            Log.d(TAG, "SEND BROADCAST MEDIA FROM STATUSCOMMENT");
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

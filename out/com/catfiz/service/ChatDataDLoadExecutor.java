package com.catfiz.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.preference.PreferenceManager;
import android.support.v4.content.LocalBroadcastManager;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.albus.util.AlbusModelObject;
import com.catfiz.R;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.localstorage.ChunkStorage;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.media.MediaScanOnlyNotifier;
import com.catfiz.media.StorageDir;
import com.catfiz.objectcomment.ObjectCommentDataStorage;
import com.catfiz.pool.PoolDataStorage;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.service.CatfishServiceExecutor.MessageSender;
import com.catfiz.service.CatfishServiceExecutor.SendDeliveredSignal;
import com.catfiz.service.uisvcexec.GetStreamThumbnailExecutor;
import com.catfiz.svcpersistent.DataStorageDownloadBase;
import com.catfiz.svcpersistent.DataStorageDownloadInfo.DataStorageStreamType;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.Log;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Locale;
import org.apache.commons.logging.impl.SimpleLog;
import org.apache.http.conn.routing.HttpRouteDirector;
import org.json.JSONException;
import org.json.JSONObject;

public class ChatDataDLoadExecutor extends DataStorageDownloadBase implements IDropableRunnable, Runnable {
    private static final String LONG_MESSAGE = "_longmessage_";
    private static final String TAG = "ChatDataDLoadExecutor";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    public static String mParentPath = StorageDir.getPrivateChatDir(3);
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = 0;
    private int mByteend = 0;
    private int mBytestart = 0;
    private boolean mCancel;
    private BroadcastReceiver mCancelReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            long longExtra = intent.getLongExtra(ServerMessageDataStorage.SEQUENCE, 0);
            if (longExtra == 0) {
                Log.d(ChatDataDLoadExecutor.TAG, "INVALID SEQUENCE: DO NOT CANCEL");
            } else if (ChatDataDLoadExecutor.this.mSequence == 0 || ChatDataDLoadExecutor.this.mSequence != longExtra) {
                Log.d(ChatDataDLoadExecutor.TAG, "Current Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(ChatDataDLoadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + longExtra + " OBJSEQ=" + ChatDataDLoadExecutor.this.mObjSequence + " SEQ " + ChatDataDLoadExecutor.this.mSequence);
                ChatDataDLoadExecutor.this.mCancel = true;
            }
        }
    };
    private byte[] mChunkbuffer = null;
    private FileOutputStream mChunkstream = null;
    private File mDataFile = null;
    private String mDataPath = null;
    private int mDatasize = 0;
    private String mFileName = null;
    private String mMessage = null;
    private String mObjOwner = null;
    private long mObjSequence = 0;
    private String mRawMessage = null;
    private String mSendername = null;
    private String mSenderpin = null;
    private long mSequence = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private String mSlink = null;
    private String mTipe = null;
    private String mUserpin = null;
    private int mWriten = 0;
    public int scheduleNum = 0;

    /* synthetic */ class AnonymousClass2 {
        static final /* synthetic */ int[] $SwitchMap$com$catfiz$service$CatfishRESTAPI$MessageType = new int[MessageType.values().length];

        static {
            try {
                $SwitchMap$com$catfiz$service$CatfishRESTAPI$MessageType[MessageType.PHOTOSEND_WCOMMENT.ordinal()] = 1;
            } catch (NoSuchFieldError e) {
            }
            try {
                $SwitchMap$com$catfiz$service$CatfishRESTAPI$MessageType[MessageType.DATASEND_WCOMMENT.ordinal()] = 2;
            } catch (NoSuchFieldError e2) {
            }
            try {
                $SwitchMap$com$catfiz$service$CatfishRESTAPI$MessageType[MessageType.VIDEO_STREAMING.ordinal()] = 3;
            } catch (NoSuchFieldError e3) {
            }
        }
    }

    class ChatMediaDLUpdateDB implements Runnable {
        private ChatMediaDLUpdateDB() {
        }

        public void run() {
            ChatDataDLoadExecutor.this.checkForceFileType();
            if (ChatDataDLoadExecutor.this.mTipe.equals(AlbusModelObject.IMAGE)) {
                ImageThumbnailer anonymousClass1 = new ImageThumbnailer(ChatDataDLoadExecutor.this.mService, ChatDataDLoadExecutor.this.mSenderpin, 1, 2.0f) {
                    protected void onPostExecute(Uri uri) {
                        if (uri != null) {
                            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(ChatDataDLoadExecutor.this.mService);
                            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(ChatDataDLoadExecutor.this.mService);
                            CatfishMessageObject obtain = CatfishMessageObject.obtain();
                            Log.d(ChatDataDLoadExecutor.TAG, "mSenderpin : " + ChatDataDLoadExecutor.this.mSenderpin);
                            obtain.senderpin = ChatDataDLoadExecutor.this.mSenderpin;
                            obtain.userpin = ChatDataDLoadExecutor.this.mUserpin;
                            obtain.messagetype = MessageType.PHOTOSEND_WCOMMENT;
                            obtain.rcvtimestamp = ChatDataDLoadExecutor.this.mSequence;
                            obtain.message = ChatDataDLoadExecutor.this.mMessage;
                            obtain.deliverystatus = MessageDeliveryStatus.RECEIVED;
                            obtain.sequence = ChatDataDLoadExecutor.this.mSequence;
                            obtain.object_sequence = 0;
                            obtain.image_path = ChatDataDLoadExecutor.mParentPath + ChatDataDLoadExecutor.this.mFileName;
                            obtain.sendername = friendListDataStorage.getFriendname(ChatDataDLoadExecutor.this.mSenderpin);
                            obtain.imagethumb_uri = uri.toString();
                            obtain.slink = ChatDataDLoadExecutor.this.mSlink;
                            catfishDataStorage.storeSingleMessage(obtain);
                            ChatDataDLoadExecutor.this.sendBroadcastIntent(obtain);
                            friendListDataStorage.updateActivityCount(ChatDataDLoadExecutor.this.mSenderpin, 600);
                            friendListDataStorage.setFriendLastActivity(ChatDataDLoadExecutor.this.mSenderpin, obtain.rcvtimestamp);
                            Bundle bundle = new Bundle();
                            bundle.putInt(obtain.senderpin, obtain.messagetype.ordinal());
                            ChatDataDLoadExecutor.this.saveToNotificationDataList(obtain);
                            ChatDataDLoadExecutor.this.mService.signalHasNewMessage(1, bundle);
                            ChatDataDLoadExecutor.this.mDataFile.renameTo(new File(ChatDataDLoadExecutor.mParentPath + ChatDataDLoadExecutor.this.mFileName));
                            String extension = Utils.getExtension(ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath());
                            MediaScanOnlyNotifier mediaScanOnlyNotifier = new MediaScanOnlyNotifier(ChatDataDLoadExecutor.this.mService, ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath(), extension == null ? "*/*" : Utils.getmimetypeFromExtension(extension));
                            obtain.recycle();
                            return;
                        }
                        Log.d(ChatDataDLoadExecutor.TAG, "Thumbnail FAIL to create");
                    }
                };
                File file = new File(ChatDataDLoadExecutor.this.mDataPath);
                anonymousClass1.execute(new Uri[]{Uri.fromFile(file)});
            } else if (ChatDataDLoadExecutor.this.mTipe.equals(AlbusModelObject.DATA_TYPE_VOICE)) {
                r0 = new CatfishDataStorage(ChatDataDLoadExecutor.this.mService);
                r1 = new FriendListDataStorage(ChatDataDLoadExecutor.this.mService);
                Log.d(ChatDataDLoadExecutor.TAG, "mSenderpin : " + ChatDataDLoadExecutor.this.mSenderpin);
                r2 = CatfishMessageObject.obtain();
                r2.senderpin = ChatDataDLoadExecutor.this.mSenderpin;
                r2.userpin = ChatDataDLoadExecutor.this.mUserpin;
                r2.messagetype = MessageType.DATASEND_WCOMMENT;
                ChatDataDLoadExecutor.this.catfishRestAPI;
                r2.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                r2.message = ChatDataDLoadExecutor.this.mMessage;
                r2.deliverystatus = MessageDeliveryStatus.RECEIVED;
                r2.sequence = ChatDataDLoadExecutor.this.mSequence;
                r2.object_sequence = 0;
                r2.voicefilepath = ChatDataDLoadExecutor.this.mDataPath;
                r2.sendername = r1.getFriendname(ChatDataDLoadExecutor.this.mSenderpin);
                r2.slink = ChatDataDLoadExecutor.this.mSlink;
                r0.storeSingleMessage(r2);
                ChatDataDLoadExecutor.this.sendBroadcastIntent(r2);
                r1.updateActivityCount(ChatDataDLoadExecutor.this.mSenderpin, 600);
                r1.setFriendLastActivity(ChatDataDLoadExecutor.this.mSenderpin, r2.rcvtimestamp);
                ChatDataDLoadExecutor.this.saveToNotificationDataList(r2);
                r0 = new Bundle();
                r0.putInt(r2.senderpin, r2.messagetype.ordinal());
                ChatDataDLoadExecutor.this.mService.signalHasNewMessage(1, r0);
                r0 = Utils.getExtension(ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath());
                r1 = new MediaScanOnlyNotifier(ChatDataDLoadExecutor.this.mService, ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath(), r0 == null ? "*/*" : Utils.getmimetypeFromExtension(r0));
                r2.recycle();
            } else if (Utils.getFileTypeFromPath(ChatDataDLoadExecutor.this.mDataPath) == 1) {
                new ImageThumbnailer(ChatDataDLoadExecutor.this.mService, CatfishService.getUserPIN(), 0, false, ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath(), 2.0f) {
                    protected void onPostExecute(Uri uri) {
                        CatfishDataStorage catfishDataStorage = new CatfishDataStorage(ChatDataDLoadExecutor.this.mService);
                        FriendListDataStorage friendListDataStorage = new FriendListDataStorage(ChatDataDLoadExecutor.this.mService);
                        Log.d(ChatDataDLoadExecutor.TAG, "mSenderpin : " + ChatDataDLoadExecutor.this.mSenderpin);
                        CatfishMessageObject obtain = CatfishMessageObject.obtain();
                        obtain.senderpin = ChatDataDLoadExecutor.this.mSenderpin;
                        obtain.userpin = ChatDataDLoadExecutor.this.mUserpin;
                        obtain.messagetype = MessageType.DATASEND_WCOMMENT;
                        ChatDataDLoadExecutor.this.catfishRestAPI;
                        obtain.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                        obtain.message = ChatDataDLoadExecutor.this.mMessage;
                        obtain.deliverystatus = MessageDeliveryStatus.RECEIVED;
                        obtain.sequence = ChatDataDLoadExecutor.this.mSequence;
                        obtain.object_sequence = 0;
                        obtain.datafile_path = ChatDataDLoadExecutor.this.mDataPath;
                        obtain.sendername = friendListDataStorage.getFriendname(ChatDataDLoadExecutor.this.mSenderpin);
                        obtain.slink = ChatDataDLoadExecutor.this.mSlink;
                        if (uri != null) {
                            obtain.imagethumb_uri = uri.toString();
                        }
                        catfishDataStorage.storeSingleMessage(obtain);
                        ChatDataDLoadExecutor.this.sendBroadcastIntent(obtain);
                        friendListDataStorage.updateActivityCount(ChatDataDLoadExecutor.this.mSenderpin, 600);
                        friendListDataStorage.setFriendLastActivity(ChatDataDLoadExecutor.this.mSenderpin, obtain.rcvtimestamp);
                        Bundle bundle = new Bundle();
                        bundle.putInt(obtain.senderpin, obtain.messagetype.ordinal());
                        ChatDataDLoadExecutor.this.saveToNotificationDataList(obtain);
                        ChatDataDLoadExecutor.this.mService.signalHasNewMessage(1, bundle);
                        String extension = Utils.getExtension(ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath());
                        MediaScanOnlyNotifier mediaScanOnlyNotifier = new MediaScanOnlyNotifier(ChatDataDLoadExecutor.this.mService, ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath(), extension == null ? "*/*" : Utils.getmimetypeFromExtension(extension));
                        obtain.recycle();
                    }
                }.execute(new Uri[]{Uri.fromFile(ChatDataDLoadExecutor.this.mDataFile)});
            } else {
                r0 = new CatfishDataStorage(ChatDataDLoadExecutor.this.mService);
                r1 = new FriendListDataStorage(ChatDataDLoadExecutor.this.mService);
                Log.d(ChatDataDLoadExecutor.TAG, "mSenderpin : " + ChatDataDLoadExecutor.this.mSenderpin);
                r2 = CatfishMessageObject.obtain();
                r2.senderpin = ChatDataDLoadExecutor.this.mSenderpin;
                r2.userpin = ChatDataDLoadExecutor.this.mUserpin;
                ChatDataDLoadExecutor.this.catfishRestAPI;
                r2.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                r2.message = PoolDataStorage.messageWithMetaInfoBuilder(ChatDataDLoadExecutor.this.mMessage, ChatDataDLoadExecutor.this.mDataFile);
                r2.deliverystatus = MessageDeliveryStatus.RECEIVED;
                r2.sequence = ChatDataDLoadExecutor.this.mSequence;
                r2.object_sequence = 0;
                r2.datafile_path = ChatDataDLoadExecutor.this.mDataPath;
                r2.sendername = r1.getFriendname(ChatDataDLoadExecutor.this.mSenderpin);
                r2.slink = ChatDataDLoadExecutor.this.mSlink;
                if (ChatDataDLoadExecutor.this.mTipe.equals(AlbusModelObject.DATA_TYPE_VIDEO)) {
                    r2.messagetype = MessageType.VIDEO_STREAMING;
                    r2.message = PoolDataStorage.messageWithMetaInfoBuilder(ChatDataDLoadExecutor.this.mMessage, ChatDataDLoadExecutor.this.mDataFile);
                } else {
                    r2.messagetype = MessageType.DATASEND_WCOMMENT;
                }
                r0.storeSingleMessage(r2);
                ChatDataDLoadExecutor.this.sendBroadcastIntent(r2);
                r1.updateActivityCount(ChatDataDLoadExecutor.this.mSenderpin, 600);
                r1.setFriendLastActivity(ChatDataDLoadExecutor.this.mSenderpin, r2.rcvtimestamp);
                ChatDataDLoadExecutor.this.saveToNotificationDataList(r2);
                r0 = new Bundle();
                r0.putInt(r2.senderpin, r2.messagetype.ordinal());
                ChatDataDLoadExecutor.this.mService.signalHasNewMessage(1, r0);
                r0 = Utils.getExtension(ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath());
                r1 = new MediaScanOnlyNotifier(ChatDataDLoadExecutor.this.mService, ChatDataDLoadExecutor.this.mDataFile.getAbsolutePath(), r0 == null ? "*/*" : Utils.getmimetypeFromExtension(r0));
                r2.recycle();
            }
            ArrayList arrayList = new ArrayList();
            MessageSender messageSender = new MessageSender();
            messageSender.senderpin = ChatDataDLoadExecutor.this.mSenderpin;
            messageSender.sequence = ChatDataDLoadExecutor.this.mSequence;
            arrayList.add(messageSender);
            ChatDataDLoadExecutor.this.mService.postToServiceHandler(new SendDeliveredSignal(ChatDataDLoadExecutor.this.mService, ChatDataDLoadExecutor.this.mServer, ChatDataDLoadExecutor.this.mUserpin, arrayList), 2);
        }
    }

    class GetDataStorageChunks implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private volatile long mAge = System.currentTimeMillis();
        public int scheduleNum = 0;

        public void dropRunnable() {
            LocalBroadcastManager.getInstance(ChatDataDLoadExecutor.this.mService).unregisterReceiver(ChatDataDLoadExecutor.this.mCancelReceiver);
            ChatDataDLoadExecutor.this.deleteTaskState(String.valueOf(ChatDataDLoadExecutor.this.mSequence), false);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            Log.d(ChatDataDLoadExecutor.TAG, "Get byte range: bs=" + String.valueOf(ChatDataDLoadExecutor.this.mBytestart) + ", " + "be=" + String.valueOf(ChatDataDLoadExecutor.this.mByteend) + ", " + "size=" + String.valueOf(ChatDataDLoadExecutor.this.mDatasize) + ", " + "mWriten=" + String.valueOf(ChatDataDLoadExecutor.this.mWriten));
            if (ChatDataDLoadExecutor.this.mCancel) {
                Log.d(ChatDataDLoadExecutor.TAG, "canceling download is on progress.....");
                LocalBroadcastManager.getInstance(ChatDataDLoadExecutor.this.mService).unregisterReceiver(ChatDataDLoadExecutor.this.mCancelReceiver);
                ChatDataDLoadExecutor.this.deleteTaskState(String.valueOf(ChatDataDLoadExecutor.this.mSequence), false);
                try {
                    ChatDataDLoadExecutor.this.mChunkstream.flush();
                    ChatDataDLoadExecutor.this.mChunkstream.close();
                    return;
                } catch (IOException e) {
                    return;
                }
            }
            CatfishResult downloadDataChunk = this.catfishRestAPI.downloadDataChunk(ChatDataDLoadExecutor.this.mServer, ChatDataDLoadExecutor.this.mUserpin, ChatDataDLoadExecutor.this.mSenderpin, ChatDataDLoadExecutor.this.mObjSequence, ChatDataDLoadExecutor.this.mBytestart, ChatDataDLoadExecutor.this.mByteend, ChatDataDLoadExecutor.this.mChunkstream);
            Log.d(ChatDataDLoadExecutor.TAG, "Chunksize: " + String.valueOf(downloadDataChunk.chunksize));
            if (downloadDataChunk.hasSuccess()) {
                this.mAge = System.currentTimeMillis();
                if (downloadDataChunk.chunksize > 0) {
                    ChatDataDLoadExecutor.this.mWriten = ChatDataDLoadExecutor.this.mWriten + downloadDataChunk.chunksize;
                }
                if (ChatDataDLoadExecutor.this.mWriten < ChatDataDLoadExecutor.this.mDatasize) {
                    ChatDataDLoadExecutor.mChunkMaxSize = CatfishRESTAPI.growChunkSize(ChatDataDLoadExecutor.mChunkMaxSize);
                    ChatDataDLoadExecutor.this.mBytestart = ChatDataDLoadExecutor.this.mWriten;
                    ChatDataDLoadExecutor.this.mByteend = (ChatDataDLoadExecutor.this.mBytestart + ChatDataDLoadExecutor.mChunkMaxSize) - 1;
                    this.mAge = System.currentTimeMillis();
                    ChatDataDLoadExecutor.this.mService.postToServiceHandler(this, 2);
                    downloadDataChunk.cleaningup();
                    return;
                }
                Log.d(ChatDataDLoadExecutor.TAG, "DBCAST RECEIVE: Get Data Chunk: DONE");
                ChatDataDLoadExecutor.this.mService.postRunnableToDbThread(new ChatMediaDLUpdateDB());
                ChatDataDLoadExecutor.this.deleteTaskState(String.valueOf(ChatDataDLoadExecutor.this.mSequence), false);
                LocalBroadcastManager.getInstance(ChatDataDLoadExecutor.this.mService).unregisterReceiver(ChatDataDLoadExecutor.this.mCancelReceiver);
            } else if (downloadDataChunk.hasFailure()) {
                Log.d(ChatDataDLoadExecutor.TAG, "DBCAST RECEIVE: Get Data Chunk: FAIL: Reschedule");
                if (downloadDataChunk.chunksize > 0) {
                    this.mAge = System.currentTimeMillis();
                    ChatDataDLoadExecutor.this.mWriten = ChatDataDLoadExecutor.this.mWriten + downloadDataChunk.chunksize;
                    if (ChatDataDLoadExecutor.this.mWriten < ChatDataDLoadExecutor.this.mDatasize) {
                        ChatDataDLoadExecutor.this.mBytestart = ChatDataDLoadExecutor.this.mWriten;
                        ChatDataDLoadExecutor.this.mByteend = (ChatDataDLoadExecutor.this.mWriten + ChatDataDLoadExecutor.mChunkMaxSize) - 1;
                        ChatDataDLoadExecutor.this.mService.postToServiceHandler(this, 2);
                        downloadDataChunk.cleaningup();
                        return;
                    }
                    Log.d(ChatDataDLoadExecutor.TAG, "DBCAST RECEIVE (In FAILURE): Get Data Chunk: DONE");
                    LocalBroadcastManager.getInstance(ChatDataDLoadExecutor.this.mService).unregisterReceiver(ChatDataDLoadExecutor.this.mCancelReceiver);
                    ChatDataDLoadExecutor.this.mService.postRunnableToDbThread(new ChatMediaDLUpdateDB());
                    ChatDataDLoadExecutor.this.deleteTaskState(String.valueOf(ChatDataDLoadExecutor.this.mSequence), false);
                    try {
                        ChatDataDLoadExecutor.this.mChunkstream.flush();
                        ChatDataDLoadExecutor.this.mChunkstream.close();
                    } catch (IOException e2) {
                    }
                    downloadDataChunk.cleaningup();
                    return;
                }
                ChatDataDLoadExecutor.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(ChatDataDLoadExecutor.mChunkMaxSize);
                ChatDataDLoadExecutor.this.mServer = CatfishService.getServerHost();
                ChatDataDLoadExecutor.this.mService.scheduleRunnableToService(this, 2);
                downloadDataChunk.cleaningup();
                return;
            } else {
                Log.d(ChatDataDLoadExecutor.TAG, "DBCAST RECEIVE: Get Data Chunk: ERROR: DROP");
                ChatDataDLoadExecutor.this.deleteTaskState(String.valueOf(ChatDataDLoadExecutor.this.mSequence), false);
                LocalBroadcastManager.getInstance(ChatDataDLoadExecutor.this.mService).unregisterReceiver(ChatDataDLoadExecutor.this.mCancelReceiver);
            }
            try {
                ChatDataDLoadExecutor.this.mChunkstream.flush();
                ChatDataDLoadExecutor.this.mChunkstream.close();
            } catch (IOException e3) {
            }
            ChatDataDLoadExecutor.this.mChunkbuffer = null;
            downloadDataChunk.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public ChatDataDLoadExecutor(CatfishService catfishService, String str, String str2, String str3, String str4, String str5, long j, long j2, String str6) {
        String string;
        Exception e;
        String str7 = "";
        this.mObjOwner = str6;
        this.mRawMessage = str4;
        try {
            JSONObject jSONObject = new JSONObject(str4);
            str7 = jSONObject.getString(ServerMessageDataStorage.MESSAGE);
            string = jSONObject.getString(CatfishDataStorage.NIC_NAME);
            try {
                this.mFileName = string;
                this.mTipe = jSONObject.getString("tipe");
                this.mSlink = jSONObject.getString(ServerMessageDataStorage.SLINK);
            } catch (Exception e2) {
                e = e2;
                Log.e(TAG, "Error : " + e.toString());
                this.mService = catfishService;
                this.mServer = str;
                this.mUserpin = str2;
                this.mSendername = str5;
                this.mSenderpin = str3;
                this.mMessage = str7;
                this.mSequence = j;
                this.mObjSequence = j2;
                this.mAge = System.currentTimeMillis();
                LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_CHAT_DOWNLOAD));
                switch (Utils.getFileTypeFromPath(string)) {
                    case e.b /*1*/:
                        mParentPath = StorageDir.getPrivateChatDir(0);
                        break;
                    case e.c /*2*/:
                        mParentPath = StorageDir.getPrivateChatDir(4);
                        break;
                    case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                        mParentPath = StorageDir.getPrivateChatDir(2);
                        break;
                    case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                        mParentPath = StorageDir.getPrivateChatDir(1);
                        break;
                    default:
                        mParentPath = StorageDir.getPrivateChatDir(3);
                        break;
                }
                this.mDataPath = mParentPath + string;
                Log.d(TAG, "file path: " + this.mDataPath);
                this.mDataFile = new File(this.mDataPath);
            }
        } catch (Exception e3) {
            Exception exception = e3;
            string = null;
            e = exception;
            Log.e(TAG, "Error : " + e.toString());
            this.mService = catfishService;
            this.mServer = str;
            this.mUserpin = str2;
            this.mSendername = str5;
            this.mSenderpin = str3;
            this.mMessage = str7;
            this.mSequence = j;
            this.mObjSequence = j2;
            this.mAge = System.currentTimeMillis();
            LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_CHAT_DOWNLOAD));
            switch (Utils.getFileTypeFromPath(string)) {
                case e.b /*1*/:
                    mParentPath = StorageDir.getPrivateChatDir(0);
                    break;
                case e.c /*2*/:
                    mParentPath = StorageDir.getPrivateChatDir(4);
                    break;
                case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                    mParentPath = StorageDir.getPrivateChatDir(2);
                    break;
                case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                    mParentPath = StorageDir.getPrivateChatDir(1);
                    break;
                default:
                    mParentPath = StorageDir.getPrivateChatDir(3);
                    break;
            }
            this.mDataPath = mParentPath + string;
            Log.d(TAG, "file path: " + this.mDataPath);
            this.mDataFile = new File(this.mDataPath);
        }
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mSendername = str5;
        this.mSenderpin = str3;
        this.mMessage = str7;
        this.mSequence = j;
        this.mObjSequence = j2;
        this.mAge = System.currentTimeMillis();
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_CHAT_DOWNLOAD));
        switch (Utils.getFileTypeFromPath(string)) {
            case e.b /*1*/:
                mParentPath = StorageDir.getPrivateChatDir(0);
                break;
            case e.c /*2*/:
                mParentPath = StorageDir.getPrivateChatDir(4);
                break;
            case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                mParentPath = StorageDir.getPrivateChatDir(2);
                break;
            case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                mParentPath = StorageDir.getPrivateChatDir(1);
                break;
            default:
                mParentPath = StorageDir.getPrivateChatDir(3);
                break;
        }
        this.mDataPath = mParentPath + string;
        Log.d(TAG, "file path: " + this.mDataPath);
        this.mDataFile = new File(this.mDataPath);
    }

    private void checkForceFileType() {
        if (this.mDataPath != null) {
            String toLowerCase = this.mDataPath.toLowerCase(Locale.US);
            if (toLowerCase.endsWith(".jpg") || toLowerCase.endsWith(".jpeg")) {
                this.mTipe = AlbusModelObject.IMAGE;
            }
            if (toLowerCase.endsWith(".png") && this.mTipe.equals(ChunkStorage.DATA_TABLE_NAME)) {
                this.mTipe = AlbusModelObject.IMAGE;
            }
        }
    }

    public void dropRunnable() {
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        String externalStorageState = Environment.getExternalStorageState();
        if (externalStorageState.equals("mounted")) {
            File parentFile = this.mDataFile.getParentFile();
            if (parentFile.exists() || parentFile.mkdirs()) {
                CatfishResult dataStorageInfo = this.catfishRestAPI.getDataStorageInfo(this.mServer, this.mUserpin, this.mSenderpin, this.mObjSequence);
                if (dataStorageInfo.hasFailure()) {
                    Log.d(TAG, "DBCAST RECEIVE: Get Info FAIL: Reschedule !!!");
                    this.mServer = CatfishService.getServerHost();
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
                    this.mService.scheduleRunnableToService(this, 2);
                    dataStorageInfo.cleaningup();
                    return;
                } else if (dataStorageInfo.hasNotFound()) {
                    Log.e(TAG, "DBCAST RECEIVE: NOT FOUND : DROP !!!");
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
                    dataStorageInfo.cleaningup();
                    return;
                } else if (!dataStorageInfo.hasSuccess()) {
                    Log.e(TAG, "DBCAST RECEIVE: ERROR: DROP !!!");
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
                    dataStorageInfo.cleaningup();
                    return;
                } else if (dataStorageInfo.datasize != dataStorageInfo.currentdatasize) {
                    Log.e(TAG, "DBCAST RECEIVE: INVALID DATA SIZE: RESCHEDULE !!!");
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
                    this.mService.scheduleRunnableToService(this, 2);
                    dataStorageInfo.cleaningup();
                    return;
                } else {
                    this.mDatasize = dataStorageInfo.datasize;
                    this.mByteend = mChunkMaxSize - 1;
                    if (isResumeProcess() && this.mDataFile.exists()) {
                        this.mChunkstream = new FileOutputStream(this.mDataFile, true);
                        this.mWriten = (int) this.mDataFile.length();
                        this.mBytestart = this.mWriten;
                        this.mByteend = (this.mBytestart + mChunkMaxSize) - 1;
                    } else {
                        try {
                            this.mChunkstream = new FileOutputStream(this.mDataFile);
                        } catch (FileNotFoundException e) {
                            LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
                            Log.e(TAG, "DBCAST RECEIVE: " + e.toString());
                            return;
                        }
                    }
                    JSONObject jSONObject = new JSONObject();
                    try {
                        jSONObject.put(TaskDataStorage.SENDERPIN, this.mSenderpin);
                        jSONObject.put(ServerMessageDataStorage.MESSAGE, this.mRawMessage);
                        jSONObject.put(ServerMessageDataStorage.SENDERNAME, this.mSendername);
                        jSONObject.put(ServerMessageDataStorage.SEQUENCE, this.mSequence);
                        jSONObject.put(ObjectCommentDataStorage.OBJECTSEQUENCE, this.mObjSequence);
                        jSONObject.put(ObjectCommentDataStorage.OBJECTOWNER, this.mObjOwner);
                        updateTaskState(String.valueOf(this.mSequence), this.mDataFile.getAbsolutePath(), this.mDatasize, DataStorageStreamType.CHAT_DATA.ordinal(), jSONObject.toString(), false);
                    } catch (JSONException e2) {
                        e2.printStackTrace();
                    }
                    if (this.mTipe.equals(AlbusModelObject.DATA_TYPE_VIDEO)) {
                        this.mService.postToServiceHandler(new GetStreamThumbnailExecutor(this.mService, this.mSlink), 2);
                        CatfishService catfishService = this.mService;
                        CatfishService catfishService2 = this.mService;
                        long j = this.mSequence;
                        CatfishService catfishService3 = this.mService;
                        catfishService.postRunnableToService(new SlinkFileInfoExecutor(catfishService2, j, CatfishService.getCurrentServerHost(), this.mSlink, false, false), 2);
                        this.mService.postRunnableToDbThread(new ChatMediaDLUpdateDB());
                        deleteTaskState(String.valueOf(this.mSequence), false);
                        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
                        return;
                    }
                    this.mService.postToServiceHandler(new GetDataStorageChunks(), 2);
                    return;
                }
            }
            LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
            Log.e(TAG, "DBCAST RECEIVE: Path to file could not be created.");
            return;
        }
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
        Log.e(TAG, "DBCAST RECEIVE: media not mounted in is state: " + externalStorageState + ":DROP !!!");
    }

    public void saveToNotificationDataList(CatfishMessageObject catfishMessageObject) {
        ArrayList notificationMsgList = this.mService.getNotificationMsgList();
        ArrayList notificationNameList = this.mService.getNotificationNameList();
        String str = "";
        str = "";
        str = catfishMessageObject.sendername;
        if (catfishMessageObject.senderpin != null && catfishMessageObject.senderpin.equals(CatfishService.OFFICIAL_PIN)) {
            str = this.mService.getResources().getString(R.string.official_name);
        }
        if (str == null || str.isEmpty()) {
            Cursor friend = new FriendListDataStorage(this.mService).getFriend(catfishMessageObject.senderpin);
            if (friend == null || friend.getCount() <= 0) {
                str = catfishMessageObject.senderpin;
            } else {
                friend.moveToFirst();
                str = friend.getString(friend.getColumnIndex(FriendListDataStorage.FRIENDNAME));
                friend.close();
            }
        }
        if (!notificationNameList.contains(str)) {
            notificationNameList.add(str);
        }
        String str2 = catfishMessageObject.senderpin;
        Log.d(TAG, "mo.messagetype:" + catfishMessageObject.messagetype + " mo.messagetype.ordinal():" + catfishMessageObject.messagetype.ordinal());
        switch (AnonymousClass2.$SwitchMap$com$catfiz$service$CatfishRESTAPI$MessageType[catfishMessageObject.messagetype.ordinal()]) {
            case e.b /*1*/:
                str = str + '\u0007' + catfishMessageObject.message + " ( " + this.mService.getResources().getString(R.string.photo_share) + " )";
                break;
            case e.c /*2*/:
                str = str + '\u0007' + catfishMessageObject.message + " ( " + this.mService.getResources().getString(R.string.file_share) + " )";
                break;
            case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                str = str + '\u0007' + catfishMessageObject.message + " ( " + this.mService.getResources().getString(R.string.video_share) + " )";
                break;
            default:
                str = null;
                break;
        }
        if (str == null && str.compareTo("") == 0) {
            Log.d(TAG, "msg null on save message to notification msg");
        } else {
            notificationMsgList.add(str);
        }
        if (notificationMsgList.size() > 6) {
            notificationMsgList.remove(0);
        }
        this.mService.setNotificationMsgList(notificationMsgList);
        this.mService.setNotificationNameList(notificationNameList);
        SharedPreferences defaultSharedPreferences = PreferenceManager.getDefaultSharedPreferences(this.mService);
        defaultSharedPreferences.edit().putInt("chatNotificationCount", defaultSharedPreferences.getInt("chatNotificationCount", 0) + 1).commit();
        defaultSharedPreferences.edit().putString("chatNotificationLastUser", str2).commit();
    }

    public void sendBroadcastIntent(CatfishMessageObject catfishMessageObject) {
        if (catfishMessageObject == null || catfishMessageObject.message == null || !catfishMessageObject.message.equals(LONG_MESSAGE)) {
            Intent intent = new Intent();
            String str = catfishMessageObject.userpin + ":" + catfishMessageObject.senderpin;
            intent.putExtra(TaskDataStorage.SENDERPIN, catfishMessageObject.senderpin);
            intent.putExtra(ServerMessageDataStorage.SENDERNAME, catfishMessageObject.sendername);
            intent.putExtra("conversation_key", str);
            intent.putExtra("image_path", catfishMessageObject.image_path);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, catfishMessageObject.sequence);
            intent.putExtra("imagethumb_uri", catfishMessageObject.imagethumb_uri);
            intent.putExtra(ServerMessageDataStorage.VOICEFILEPATH, catfishMessageObject.voicefilepath);
            intent.putExtra("datafile_path", catfishMessageObject.datafile_path);
            intent.putExtra(ServerMessageDataStorage.MESSAGE, catfishMessageObject.message);
            intent.putExtra(TaskDataStorage.MESSAGETYPE, catfishMessageObject.messagetype.ordinal());
            intent.putExtra("rcvtimestamp", catfishMessageObject.rcvtimestamp);
            intent.putExtra("object_owner", catfishMessageObject.object_owner);
            intent.putExtra(ServerMessageDataStorage.SLINK, catfishMessageObject.slink);
            intent.putExtra("object_sequence", catfishMessageObject.object_sequence);
            intent.setAction(BroadcastIntents.ACTION_CHAT_MEDIA);
            this.mService.sendBroadcast(intent);
            Log.d(TAG, "SEND BROADCAST MEDIA FROM CHAT WITH TEXT");
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

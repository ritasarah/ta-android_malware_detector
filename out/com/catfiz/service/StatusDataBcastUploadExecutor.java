package com.catfiz.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.Bitmap.Config;
import android.graphics.BitmapFactory;
import android.graphics.BitmapFactory.Options;
import android.net.Uri;
import android.support.v4.content.LocalBroadcastManager;
import android.webkit.MimeTypeMap;
import com.albus.util.AlbusModelObject;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.media.CatfishPhotoStorage;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.objectcomment.ObjectCommentDataStorage;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.FizzlinkUtil;
import com.catfiz.util.Log;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.http.HttpStatus;
import org.json.JSONException;
import org.json.JSONObject;

public class StatusDataBcastUploadExecutor implements Runnable {
    public static final String ID_LONGMESSAGE = "_longmessage_";
    private static final String TAG = "StatusDataBcastUploadExecutor";
    public static final int mChunkMaxSize = 262144;
    public boolean bNeedRead = true;
    public int mBytestart = 0;
    private File mCacheFile = null;
    private BroadcastReceiver mCancelUploadReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            long longExtra = intent.getLongExtra(ServerMessageDataStorage.SEQUENCE, 0);
            if (longExtra == 0) {
                Log.d(StatusDataBcastUploadExecutor.TAG, "INVALID SEQUENCE: DO NOT CANCEL");
            } else if (StatusDataBcastUploadExecutor.this.mSequence == 0 || StatusDataBcastUploadExecutor.this.mSequence != longExtra) {
                Log.d(StatusDataBcastUploadExecutor.TAG, "Current Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(StatusDataBcastUploadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + longExtra + " OBJSEQ=" + StatusDataBcastUploadExecutor.this.mObjSequence + " SEQ " + StatusDataBcastUploadExecutor.this.mSequence);
                StatusDataBcastUploadExecutor.this.mbCancelUpload = true;
            }
        }
    };
    public byte[] mChunkbuffer = null;
    public int mChunksent = 0;
    public int mChunksize = 0;
    public FileInputStream mChunkstream = null;
    private ICatfishClientInterface mClientInterface = null;
    Context mContext = null;
    private String mConvKey = null;
    public File mDataFile = null;
    private String mDataPath = null;
    public int mDatasize = 0;
    private String mFilename = null;
    private String mImagethumuri = null;
    private String mLongMessagePreview = null;
    private String mMessage = null;
    CatfishMessageObject mMessageObject = null;
    private long mObjSequence = 0;
    private String mRecipient = null;
    private long mSequence = 0;
    private volatile long mSequenceThumb = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private ICatfishUIBinder mServiceBinder = null;
    private String mSlink = null;
    private long mStatusSequence = 0;
    private String mTipe = null;
    private String mUserpin = null;
    private boolean mbCancelUpload = false;

    class BcastCommentToFriendList implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private BcastCommentToFriendList() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            Log.e(StatusDataBcastUploadExecutor.TAG, "SEND STATUS COMMENT: SEND ERROR: DROP BY SERVICE !!!");
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            String string = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
            JSONObject jSONObject = new JSONObject();
            try {
                jSONObject.put(ServerMessageDataStorage.MESSAGE, StatusDataBcastUploadExecutor.this.mMessage);
                jSONObject.put(ObjectCommentDataStorage.OBJECTSEQUENCE, StatusDataBcastUploadExecutor.this.mObjSequence);
                jSONObject.put(ServerMessageDataStorage.SLINK, StatusDataBcastUploadExecutor.this.mSlink);
                if (StatusDataBcastUploadExecutor.this.mTipe.equals(AlbusModelObject.DATA_TYPE_IMAGE)) {
                    jSONObject.put("tipe", AlbusModelObject.IMAGE);
                } else {
                    jSONObject.put("tipe", StatusDataBcastUploadExecutor.this.mTipe);
                }
            } catch (JSONException e) {
                e.printStackTrace();
            }
            Log.d(StatusDataBcastUploadExecutor.TAG, "sender: " + string + " message tipe: " + StatusDataBcastUploadExecutor.this.mMessageObject.messagetype.ordinal());
            CatfishResult friendlistBcast = this.catfishRestAPI.friendlistBcast(StatusDataBcastUploadExecutor.this.mServer, StatusDataBcastUploadExecutor.this.mUserpin, string, StatusDataBcastUploadExecutor.this.mMessageObject.messagetype.ordinal(), StatusDataBcastUploadExecutor.this.mRecipient, jSONObject.toString(), StatusDataBcastUploadExecutor.this.mSequence, StatusDataBcastUploadExecutor.this.mStatusSequence, StatusDataBcastUploadExecutor.this.mRecipient);
            if (friendlistBcast.hasSuccess()) {
                StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTSENT));
            } else if (friendlistBcast.hasFailure()) {
                StatusDataBcastUploadExecutor.this.mServer = CatfishService.getServerHost();
                StatusDataBcastUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(StatusDataBcastUploadExecutor.TAG, "SEND IMAGE STATUS COMMENT: SEND ERROR: DROP !!!");
                StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
            }
            friendlistBcast.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class DataBcastDeliveryStatus implements Runnable {
        private MessageDeliveryStatus mDeliveryStatus = MessageDeliveryStatus.UNDEFINED;

        public DataBcastDeliveryStatus(MessageDeliveryStatus messageDeliveryStatus) {
            this.mDeliveryStatus = messageDeliveryStatus;
        }

        public void run() {
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(StatusDataBcastUploadExecutor.this.mService);
            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(StatusDataBcastUploadExecutor.this.mService);
            StatusDataBcastUploadExecutor.this.mMessageObject.deliverystatus = this.mDeliveryStatus;
            StatusDataBcastUploadExecutor.this.mMessageObject.recipient = StatusDataBcastUploadExecutor.this.mRecipient;
            StatusDataBcastUploadExecutor.this.mMessageObject.conversation_key = StatusDataBcastUploadExecutor.this.mConvKey;
            StatusDataBcastUploadExecutor.this.mMessageObject.slink = StatusDataBcastUploadExecutor.this.mSlink;
            friendListDataStorage.updateActivityCount(StatusDataBcastUploadExecutor.this.mRecipient, 100);
            if (StatusDataBcastUploadExecutor.this.mSlink == null) {
                Log.e(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: mslink null");
                if (catfishDataStorage.updateBCASTSentStatusWKey(StatusDataBcastUploadExecutor.this.mMessageObject)) {
                    StatusDataBcastUploadExecutor.this.mService.postToMainHandler(new InvokeClientCallback(StatusDataBcastUploadExecutor.this.mClientInterface, catfishDataStorage.getChatConversation(StatusDataBcastUploadExecutor.this.mConvKey)));
                    return;
                }
                Log.e(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: FAIL TO UPDATE DELVERY STATUS IN DB");
                return;
            }
            Log.e(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: mslink " + StatusDataBcastUploadExecutor.this.mSlink);
            if (catfishDataStorage.updateBCASTSentStatusNSlinkWKey(StatusDataBcastUploadExecutor.this.mMessageObject)) {
                StatusDataBcastUploadExecutor.this.mService.postToMainHandler(new InvokeClientCallback(StatusDataBcastUploadExecutor.this.mClientInterface, catfishDataStorage.getChatConversation(StatusDataBcastUploadExecutor.this.mConvKey)));
                return;
            }
            Log.e(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: FAIL TO UPDATE DELVERY STATUS IN DB");
        }
    }

    class DataBcastUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        private boolean mIsSent;
        public int scheduleNum;
        private boolean send;

        private DataBcastUploadChunk() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.send = true;
            this.mIsSent = false;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                StatusDataBcastUploadExecutor.this.mCacheFile.delete();
            }
            LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (StatusDataBcastUploadExecutor.this.mChunkstream == null) {
                Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: INVALID CHUNKSTREAM (NULL): CANCELED");
                LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                    StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                    return;
                }
                return;
            }
            try {
                if (StatusDataBcastUploadExecutor.this.bNeedRead) {
                    StatusDataBcastUploadExecutor.this.bNeedRead = false;
                    StatusDataBcastUploadExecutor.this.mChunksize = StatusDataBcastUploadExecutor.this.mChunkstream.read(StatusDataBcastUploadExecutor.this.mChunkbuffer, 0, StatusDataBcastUploadExecutor.mChunkMaxSize);
                    if (!this.mIsSent) {
                        this.mIsSent = true;
                        StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTSENT));
                    }
                }
                Intent intent;
                if (StatusDataBcastUploadExecutor.this.mChunksize <= 0) {
                    Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: SENT COMPLETE");
                    LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                    if (StatusDataBcastUploadExecutor.this.mMessageObject != null) {
                        StatusDataBcastUploadExecutor.this.sendBroadcastIntent(StatusDataBcastUploadExecutor.this.mMessageObject);
                    }
                    if (!(StatusDataBcastUploadExecutor.this.mMessage == null || StatusDataBcastUploadExecutor.this.mMessage.equals(StatusDataBcastUploadExecutor.ID_LONGMESSAGE))) {
                        intent = new Intent(BroadcastIntents.ACTION_UPLOAD_STATUS);
                        intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                        intent.putExtra(CatfishService.PROGRESS_STATE, 2);
                        intent.putExtra(ServerMessageDataStorage.SEQUENCE, StatusDataBcastUploadExecutor.this.mSequence);
                        LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).sendBroadcast(intent);
                    }
                    Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: Post To Notify Recipients");
                    StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(new SetDsName(), 2);
                    try {
                        StatusDataBcastUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                    if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                        StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                    }
                } else if (StatusDataBcastUploadExecutor.this.mbCancelUpload) {
                    LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                    if (!(StatusDataBcastUploadExecutor.this.mMessage == null || StatusDataBcastUploadExecutor.this.mMessage.equals(StatusDataBcastUploadExecutor.ID_LONGMESSAGE))) {
                        intent = new Intent(BroadcastIntents.ACTION_UPLOAD_STATUS);
                        intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                        intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                        intent.putExtra(ServerMessageDataStorage.SEQUENCE, StatusDataBcastUploadExecutor.this.mSequence);
                        LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).sendBroadcast(intent);
                    }
                    StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                    try {
                        StatusDataBcastUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e2) {
                    }
                    if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                        StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                    }
                    StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                } else {
                    Log.e(StatusDataBcastUploadExecutor.TAG, "data upload chunck muserpin: " + StatusDataBcastUploadExecutor.this.mUserpin + " mobjsequence" + StatusDataBcastUploadExecutor.this.mObjSequence);
                    CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(StatusDataBcastUploadExecutor.this.mServer, StatusDataBcastUploadExecutor.this.mUserpin, StatusDataBcastUploadExecutor.this.mObjSequence, StatusDataBcastUploadExecutor.this.mDatasize, StatusDataBcastUploadExecutor.this.mBytestart, StatusDataBcastUploadExecutor.this.mChunksize, StatusDataBcastUploadExecutor.this.mChunkbuffer);
                    if (StatusDataBcastUploadExecutor.this.mbCancelUpload) {
                        LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                        if (!(StatusDataBcastUploadExecutor.this.mMessage == null || StatusDataBcastUploadExecutor.this.mMessage.equals(StatusDataBcastUploadExecutor.ID_LONGMESSAGE))) {
                            intent = new Intent(BroadcastIntents.ACTION_UPLOAD_STATUS);
                            intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                            intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                            intent.putExtra(ServerMessageDataStorage.SEQUENCE, StatusDataBcastUploadExecutor.this.mSequence);
                            LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).sendBroadcast(intent);
                        }
                        StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                        try {
                            StatusDataBcastUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e3) {
                        }
                        if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                            StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                        }
                        StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                        return;
                    }
                    if (uploadDataChunk.hasSuccess()) {
                        this.mAge = System.currentTimeMillis();
                        if (uploadDataChunk.byteend == 0) {
                            Log.d(StatusDataBcastUploadExecutor.TAG, "----Byte End is 0: RESEND");
                            StatusDataBcastUploadExecutor.this.bNeedRead = false;
                            StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(this, 2);
                            return;
                        } else if (StatusDataBcastUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - StatusDataBcastUploadExecutor.this.mBytestart) + 1) {
                            Log.d(StatusDataBcastUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                            StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                            try {
                                StatusDataBcastUploadExecutor.this.mChunkstream.close();
                            } catch (IOException e4) {
                            }
                            LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                            StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                            uploadDataChunk.cleaningup();
                            if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                                StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                                return;
                            }
                            return;
                        } else {
                            Log.d(StatusDataBcastUploadExecutor.TAG, "Chunk Sent: " + String.valueOf(uploadDataChunk.byteend - StatusDataBcastUploadExecutor.this.mBytestart) + " bytes: " + String.valueOf(StatusDataBcastUploadExecutor.this.mBytestart) + "-" + String.valueOf(uploadDataChunk.byteend) + ": SELF RE-POST");
                            StatusDataBcastUploadExecutor statusDataBcastUploadExecutor = StatusDataBcastUploadExecutor.this;
                            statusDataBcastUploadExecutor.mChunksent += (uploadDataChunk.byteend - StatusDataBcastUploadExecutor.this.mBytestart) + 1;
                            StatusDataBcastUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                            StatusDataBcastUploadExecutor.this.bNeedRead = true;
                            if (!(StatusDataBcastUploadExecutor.this.mMessage == null || StatusDataBcastUploadExecutor.this.mMessage.equals(StatusDataBcastUploadExecutor.ID_LONGMESSAGE))) {
                                int i = (StatusDataBcastUploadExecutor.this.mBytestart * 100) / StatusDataBcastUploadExecutor.this.mDatasize;
                                Intent intent2 = new Intent(BroadcastIntents.ACTION_UPLOAD_STATUS);
                                intent2.putExtra(CatfishService.PROGRESS_VALUE, i);
                                intent2.putExtra(ServerMessageDataStorage.SEQUENCE, StatusDataBcastUploadExecutor.this.mSequence);
                                LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).sendBroadcast(intent2);
                            }
                            StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        }
                    } else if (uploadDataChunk.hasFailure()) {
                        Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: FAILURE !!!: Re Schedule");
                        if (!(StatusDataBcastUploadExecutor.this.mMessage == null || StatusDataBcastUploadExecutor.this.mMessage.equals(StatusDataBcastUploadExecutor.ID_LONGMESSAGE))) {
                            r1 = new Intent(BroadcastIntents.ACTION_UPLOAD_STATUS);
                            r1.putExtra(CatfishService.PROGRESS_VALUE, 0);
                            r1.putExtra(ServerMessageDataStorage.SEQUENCE, StatusDataBcastUploadExecutor.this.mSequence);
                            r1.putExtra(CatfishService.PROGRESS_STATE, 4);
                            LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).sendBroadcast(r1);
                        }
                        StatusDataBcastUploadExecutor.this.bNeedRead = false;
                        StatusDataBcastUploadExecutor.this.mServer = CatfishService.getServerHost();
                        StatusDataBcastUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    } else {
                        Log.e(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: ERROR: DROP");
                        LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                        if (!(StatusDataBcastUploadExecutor.this.mMessage == null || StatusDataBcastUploadExecutor.this.mMessage.equals(StatusDataBcastUploadExecutor.ID_LONGMESSAGE))) {
                            r1 = new Intent(BroadcastIntents.ACTION_UPLOAD_STATUS);
                            r1.putExtra(CatfishService.PROGRESS_VALUE, 0);
                            r1.putExtra(ServerMessageDataStorage.SEQUENCE, StatusDataBcastUploadExecutor.this.mSequence);
                            r1.putExtra(CatfishService.PROGRESS_STATE, 4);
                            LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).sendBroadcast(r1);
                        }
                        StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                        try {
                            StatusDataBcastUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e5) {
                        }
                        if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                            StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                        }
                        StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                    }
                    uploadDataChunk.cleaningup();
                }
            } catch (IOException e6) {
                Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: FAIL TO READ STREAM: CANCELED");
                LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                    StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                }
                StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class GetSlinkFromServer implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        private boolean mIsSent;
        public int scheduleNum;
        private boolean send;

        private GetSlinkFromServer() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.send = true;
            this.mIsSent = false;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            Log.e(StatusDataBcastUploadExecutor.TAG, "data getslink muserpin: " + StatusDataBcastUploadExecutor.this.mUserpin + " mobjsequence" + StatusDataBcastUploadExecutor.this.mObjSequence);
            CatfishResult slink = this.catfishRestAPI.getSlink(StatusDataBcastUploadExecutor.this.mServer, StatusDataBcastUploadExecutor.this.mUserpin, StatusDataBcastUploadExecutor.this.mUserpin, StatusDataBcastUploadExecutor.this.mObjSequence);
            if (slink.hasSuccess()) {
                StatusDataBcastUploadExecutor.this.mSlink = slink.slink;
                StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(new BcastCommentToFriendList(), 2);
            } else if (slink.hasFailure()) {
                Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: FAILURE !!!: Re Schedule");
                StatusDataBcastUploadExecutor.this.mServer = CatfishService.getServerHost();
                StatusDataBcastUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: ERROR: DROP");
                StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
            }
            slink.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class InvokeClientCallback implements Runnable {
        private Cursor mCursor;
        private ICatfishClientInterface mIfClient;

        public InvokeClientCallback(ICatfishClientInterface iCatfishClientInterface, Cursor cursor) {
            this.mCursor = cursor;
            this.mIfClient = iCatfishClientInterface;
        }

        public void run() {
            if (!this.mIfClient.isFinish()) {
                this.mIfClient.onDatabaseResponse(CatfishService.GET_STATCOMM_CONVERSATION_KEY, this.mCursor, 0);
            }
        }
    }

    class SetDsName implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        private boolean mIsSent;
        public int scheduleNum;
        private boolean send;

        private SetDsName() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.send = true;
            this.mIsSent = false;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public String getMimeType(String str) {
            String str2 = "*/*";
            String fileExtensionFromUrl = MimeTypeMap.getFileExtensionFromUrl(str);
            return fileExtensionFromUrl != null ? MimeTypeMap.getSingleton().getMimeTypeFromExtension(fileExtensionFromUrl) : str2;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            String safeFileName = Utils.getSafeFileName(StatusDataBcastUploadExecutor.this.mDataFile.getName());
            int fizzlinkTypeFromExtension = FizzlinkUtil.getFizzlinkTypeFromExtension(StatusDataBcastUploadExecutor.this.mDataFile);
            StatusDataBcastUploadExecutor.this.mMessage;
            JSONObject jSONObject = new JSONObject();
            try {
                File file = new File(StatusDataBcastUploadExecutor.this.mDataPath);
                if (StatusDataBcastUploadExecutor.this.mMessage != null) {
                    jSONObject.put(AlbusModelObject.INTENT_DESC, StatusDataBcastUploadExecutor.this.mMessage);
                } else {
                    jSONObject.put(AlbusModelObject.INTENT_DESC, "");
                }
                jSONObject.put("objsequencethumb", StatusDataBcastUploadExecutor.this.mSequenceThumb);
                Log.d(StatusDataBcastUploadExecutor.TAG, "!@@@ objsequencethumb:" + StatusDataBcastUploadExecutor.this.mSequenceThumb + " ownerpin:" + StatusDataBcastUploadExecutor.this.mUserpin);
            } catch (JSONException e) {
                e.printStackTrace();
            }
            CatfishResult dsName = this.catfishRestAPI.setDsName(StatusDataBcastUploadExecutor.this.mServer, StatusDataBcastUploadExecutor.this.mUserpin, StatusDataBcastUploadExecutor.this.mUserpin, StatusDataBcastUploadExecutor.this.mObjSequence, safeFileName, fizzlinkTypeFromExtension, jSONObject.toString());
            if (dsName.hasSuccess()) {
                if (StatusDataBcastUploadExecutor.this.mImagethumuri == null) {
                    Log.d(StatusDataBcastUploadExecutor.TAG, "@@@ mImagethumuri null");
                    StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(), 2);
                    return;
                }
                try {
                    Uri parse = Uri.parse(StatusDataBcastUploadExecutor.this.mImagethumuri);
                    StatusDataBcastUploadExecutor.this.mDataFile = new File(parse.getPath());
                    Log.d(StatusDataBcastUploadExecutor.TAG, "++++ myUri.getPath:" + parse.getPath() + "+++");
                    Long valueOf = Long.valueOf(StatusDataBcastUploadExecutor.this.mDataFile.length());
                    StatusDataBcastUploadExecutor.this.mDatasize = valueOf.intValue();
                    StatusDataBcastUploadExecutor.this.mChunkstream = new FileInputStream(StatusDataBcastUploadExecutor.this.mDataFile);
                    StatusDataBcastUploadExecutor.this.mChunkbuffer = new byte[StatusDataBcastUploadExecutor.mChunkMaxSize];
                    StatusDataBcastUploadExecutor.this.mBytestart = 0;
                    StatusDataBcastUploadExecutor.this.bNeedRead = true;
                    StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(new ThumbUploadChunk(), 2);
                } catch (FileNotFoundException e2) {
                    StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(), 2);
                    return;
                }
            } else if (dsName.hasFailure()) {
                Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: FAILURE !!!: Re Schedule");
                StatusDataBcastUploadExecutor.this.mServer = CatfishService.getServerHost();
                StatusDataBcastUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: ERROR: DROP");
                StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
            }
            dsName.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class ThumbUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private volatile long mAge;
        private String mMsg;
        public int scheduleNum;

        private ThumbUploadChunk() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
            this.mMsg = null;
        }

        public void dropRunnable() {
            if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                StatusDataBcastUploadExecutor.this.mCacheFile.delete();
            }
            LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (StatusDataBcastUploadExecutor.this.mChunkstream == null) {
                Log.d(StatusDataBcastUploadExecutor.TAG, "----DSTATUSSHARE_THUMB: INVALID CHUNKSTREAM (NULL): CANCELED");
                LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                    StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                    return;
                }
                return;
            }
            try {
                if (StatusDataBcastUploadExecutor.this.bNeedRead) {
                    StatusDataBcastUploadExecutor.this.bNeedRead = false;
                    StatusDataBcastUploadExecutor.this.mChunksize = StatusDataBcastUploadExecutor.this.mChunkstream.read(StatusDataBcastUploadExecutor.this.mChunkbuffer, 0, StatusDataBcastUploadExecutor.mChunkMaxSize);
                }
                if (StatusDataBcastUploadExecutor.this.mChunksize <= 0) {
                    Log.d(StatusDataBcastUploadExecutor.TAG, "----DSTATUSSHARE_THUMB: SENT COMPLETE-----@@@@");
                    Log.d(StatusDataBcastUploadExecutor.TAG, "!@@@ object sequence:" + StatusDataBcastUploadExecutor.this.mSequenceThumb + " object owner" + StatusDataBcastUploadExecutor.this.mUserpin);
                    LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                    if (StatusDataBcastUploadExecutor.this.mMessageObject != null) {
                        StatusDataBcastUploadExecutor.this.sendBroadcastIntent(StatusDataBcastUploadExecutor.this.mMessageObject);
                    }
                    Log.d(StatusDataBcastUploadExecutor.TAG, "----DSTATUSSHARE_THUMB: Post To Notify Recipients");
                    StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(), 2);
                    try {
                        StatusDataBcastUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                        StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                    }
                    StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                } else if (StatusDataBcastUploadExecutor.this.mbCancelUpload) {
                    Log.d(StatusDataBcastUploadExecutor.TAG, "canceling upload is on progress.....");
                    LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                    StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                } else {
                    CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(StatusDataBcastUploadExecutor.this.mServer, StatusDataBcastUploadExecutor.this.mUserpin, StatusDataBcastUploadExecutor.this.mSequenceThumb, StatusDataBcastUploadExecutor.this.mDatasize, StatusDataBcastUploadExecutor.this.mBytestart, StatusDataBcastUploadExecutor.this.mChunksize, StatusDataBcastUploadExecutor.this.mChunkbuffer);
                    if (uploadDataChunk.hasSuccess()) {
                        this.mAge = System.currentTimeMillis();
                        if (uploadDataChunk.byteend == 0) {
                            Log.d(StatusDataBcastUploadExecutor.TAG, "----Byte End is 0: RESEND");
                            StatusDataBcastUploadExecutor.this.bNeedRead = false;
                            this.mAge = System.currentTimeMillis();
                            StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(this, 2);
                            return;
                        } else if (StatusDataBcastUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - StatusDataBcastUploadExecutor.this.mBytestart) + 1) {
                            Log.d(StatusDataBcastUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                            LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                            StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                            try {
                                StatusDataBcastUploadExecutor.this.mChunkstream.close();
                            } catch (IOException e2) {
                            }
                            StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                            if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                                StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                            }
                            uploadDataChunk.cleaningup();
                            return;
                        } else {
                            Log.d(StatusDataBcastUploadExecutor.TAG, "Chunk Sent: " + String.valueOf(uploadDataChunk.byteend - StatusDataBcastUploadExecutor.this.mBytestart) + " bytes: " + String.valueOf(StatusDataBcastUploadExecutor.this.mBytestart) + "-" + String.valueOf(uploadDataChunk.byteend) + ": SELF RE-POST");
                            StatusDataBcastUploadExecutor statusDataBcastUploadExecutor = StatusDataBcastUploadExecutor.this;
                            statusDataBcastUploadExecutor.mChunksent += (uploadDataChunk.byteend - StatusDataBcastUploadExecutor.this.mBytestart) + 1;
                            StatusDataBcastUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                            int i = (StatusDataBcastUploadExecutor.this.mBytestart * 100) / StatusDataBcastUploadExecutor.this.mDatasize;
                            StatusDataBcastUploadExecutor.this.bNeedRead = true;
                            StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        }
                    } else if (uploadDataChunk.hasFailure()) {
                        Log.d(StatusDataBcastUploadExecutor.TAG, "----DSTATUSSHARE_THUMB: FAILURE !!!: Re Schedule");
                        StatusDataBcastUploadExecutor.this.bNeedRead = false;
                        StatusDataBcastUploadExecutor.this.mServer = CatfishService.getServerHost();
                        StatusDataBcastUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    } else {
                        Log.e(StatusDataBcastUploadExecutor.TAG, "----DSTATUSSHARE_THUMB: ERROR: DROP");
                        LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                        StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                        try {
                            StatusDataBcastUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e3) {
                        }
                        StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                        if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                            StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                        }
                    }
                    uploadDataChunk.cleaningup();
                }
            } catch (IOException e4) {
                Log.d(StatusDataBcastUploadExecutor.TAG, "----DSTATUSSHARE_THUMB: FAIL TO READ STREAM: CANCELED");
                LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                StatusDataBcastUploadExecutor.this.mChunkbuffer = null;
                StatusDataBcastUploadExecutor.this.mService.postRunnableToDbThread(new DataBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                if (StatusDataBcastUploadExecutor.this.mCacheFile != null && StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                    StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                }
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public StatusDataBcastUploadExecutor(CatfishService catfishService, ICatfishClientInterface iCatfishClientInterface, Context context, String str, String str2, String str3, String str4, String str5, long j, ICatfishUIBinder iCatfishUIBinder, String str6) {
        this.mContext = context;
        this.mClientInterface = iCatfishClientInterface;
        this.mServiceBinder = iCatfishUIBinder;
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mRecipient = str3;
        this.mDataPath = str4;
        this.mMessage = str5;
        this.mSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mObjSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mSequenceThumb = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mStatusSequence = j;
        this.mTipe = str6;
        this.mDataFile = new File(str4);
        this.mFilename = this.mDataFile.getName();
        Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_STATUS);
        intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelUploadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_STATUS_UPLOAD));
    }

    public StatusDataBcastUploadExecutor(CatfishService catfishService, ICatfishClientInterface iCatfishClientInterface, Context context, String str, String str2, String str3, String str4, String str5, long j, ICatfishUIBinder iCatfishUIBinder, String str6, String str7, long j2) {
        this.mContext = context;
        this.mClientInterface = iCatfishClientInterface;
        this.mServiceBinder = iCatfishUIBinder;
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mRecipient = str3;
        this.mDataPath = str4;
        this.mMessage = str5;
        this.mSequence = j2;
        this.mObjSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mSequenceThumb = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mStatusSequence = j;
        this.mLongMessagePreview = str7;
        this.mTipe = str6;
        this.mDataFile = new File(str4);
        this.mFilename = this.mDataFile.getName();
        Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_STATUS);
        intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelUploadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_STATUS_UPLOAD));
    }

    private void deteleThumbFile(Uri uri) {
        try {
            File file = new File(uri.getPath());
            if (file.exists()) {
                Log.d(TAG, "Delete thumbfile=" + file.getAbsolutePath());
                file.delete();
                return;
            }
            Log.d(TAG, "thumbfile=" + file.getAbsolutePath() + ": Not exists");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Bitmap rescaleBitmap() {
        int i = 1;
        Options options = new Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(this.mDataFile.getAbsolutePath(), options);
        int i2 = options.outWidth;
        int i3 = options.outHeight;
        while (i2 / 2 >= 240 && i3 / 2 >= 240) {
            i2 /= 2;
            i3 /= 2;
            i *= 2;
        }
        Log.d(TAG, "scale=" + i + ",oW=" + options.outWidth + ",oH=" + options.outHeight + " -> W=" + i2 + ",H=" + i3);
        Options options2 = new Options();
        options2.inSampleSize = i;
        options2.inJustDecodeBounds = false;
        options2.inDither = false;
        options2.inPreferredConfig = Config.ARGB_8888;
        return BitmapFactory.decodeFile(this.mDataFile.getAbsolutePath(), options2);
    }

    private void sendBroadcastIntent(CatfishMessageObject catfishMessageObject) {
        if (catfishMessageObject != null && catfishMessageObject.message != null && catfishMessageObject.message.equals(ID_LONGMESSAGE)) {
            return;
        }
        if (this.mLongMessagePreview == null || this.mLongMessagePreview.isEmpty()) {
            Intent intent = new Intent();
            intent.putExtra(TaskDataStorage.SENDERPIN, catfishMessageObject.senderpin);
            intent.putExtra(ServerMessageDataStorage.SENDERNAME, catfishMessageObject.sendername);
            intent.putExtra("conversation_key", catfishMessageObject.conversation_key);
            intent.putExtra("image_path", catfishMessageObject.image_path);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, catfishMessageObject.sequence);
            intent.putExtra("imagethumb_uri", catfishMessageObject.imagethumb_uri);
            intent.putExtra(ServerMessageDataStorage.VOICEFILEPATH, catfishMessageObject.voicefilepath);
            intent.putExtra("datafile_path", catfishMessageObject.datafile_path);
            intent.putExtra(ServerMessageDataStorage.MESSAGE, catfishMessageObject.message);
            intent.putExtra(TaskDataStorage.MESSAGETYPE, catfishMessageObject.messagetype.ordinal());
            intent.putExtra("rcvtimestamp", catfishMessageObject.rcvtimestamp);
            intent.putExtra("object_owner", catfishMessageObject.object_owner);
            intent.putExtra("object_sequence", catfishMessageObject.object_sequence);
            intent.setAction(BroadcastIntents.ACTION_STATUS_MEDIA);
            this.mService.sendBroadcast(intent);
            Log.d(TAG, "SEND BROADCAST MEDIA FROM STATUSCOMMENT");
        }
    }

    public void run() {
        if (this.mTipe.equals(AlbusModelObject.IMAGE) || this.mTipe.equals(AlbusModelObject.DATA_TYPE_IMAGE)) {
            ImageThumbnailer anonymousClass1 = new ImageThumbnailer(this.mService, CatfishService.getUserPIN(), 1, 2.0f) {
                protected void onPostExecute(Uri uri) {
                    if (uri != null) {
                        StatusDataBcastUploadExecutor.this.mImagethumuri = uri.toString();
                        Log.d(StatusDataBcastUploadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                        try {
                            StatusDataBcastUploadExecutor.this.mCacheFile = CatfishPhotoStorage.getCacheFile(StatusDataBcastUploadExecutor.this.mService, StatusDataBcastUploadExecutor.this.mFilename);
                            if (StatusDataBcastUploadExecutor.this.mCacheFile == null) {
                                Log.e(StatusDataBcastUploadExecutor.TAG, "FAIL to create cache file: DROP");
                                LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                                StatusDataBcastUploadExecutor.this.deteleThumbFile(uri);
                                return;
                            }
                            OutputStream fileOutputStream = new FileOutputStream(StatusDataBcastUploadExecutor.this.mCacheFile);
                            Bitmap access$600 = StatusDataBcastUploadExecutor.this.rescaleBitmap();
                            if (access$600 == null) {
                                Log.e(StatusDataBcastUploadExecutor.TAG, "Rescaling FAIL: DROP");
                                LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                                try {
                                    fileOutputStream.close();
                                } catch (IOException e) {
                                }
                                if (StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                                    StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                                }
                                StatusDataBcastUploadExecutor.this.deteleThumbFile(uri);
                                return;
                            }
                            if (StatusDataBcastUploadExecutor.this.mTipe.equals(AlbusModelObject.DATA_TYPE_IMAGE)) {
                                access$600.compress(CompressFormat.JPEG, 60, fileOutputStream);
                            } else {
                                access$600.compress(CompressFormat.PNG, 60, fileOutputStream);
                            }
                            try {
                                fileOutputStream.flush();
                                fileOutputStream.close();
                            } catch (IOException e2) {
                            }
                            Long valueOf = Long.valueOf(StatusDataBcastUploadExecutor.this.mCacheFile.length());
                            StatusDataBcastUploadExecutor.this.mDatasize = valueOf.intValue();
                            StatusDataBcastUploadExecutor.this.mChunkstream = new FileInputStream(StatusDataBcastUploadExecutor.this.mCacheFile);
                            StatusDataBcastUploadExecutor.this.mChunkbuffer = new byte[StatusDataBcastUploadExecutor.mChunkMaxSize];
                            Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: Put Message in recipients record: " + StatusDataBcastUploadExecutor.this.mDataFile.getAbsolutePath());
                            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(StatusDataBcastUploadExecutor.this.mService);
                            String string = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                            StatusDataBcastUploadExecutor.this.mMessageObject = new CatfishMessageObject();
                            StatusDataBcastUploadExecutor.this.mMessageObject.messagetype = MessageType.BCASTIMAGESTATUS;
                            StatusDataBcastUploadExecutor.this.mMessageObject.userpin = StatusDataBcastUploadExecutor.this.mUserpin;
                            StatusDataBcastUploadExecutor.this.mMessageObject.senderpin = StatusDataBcastUploadExecutor.this.mUserpin;
                            StatusDataBcastUploadExecutor.this.mMessageObject.sendername = string;
                            StatusDataBcastUploadExecutor.this.mMessageObject.message = StatusDataBcastUploadExecutor.this.mMessage;
                            StatusDataBcastUploadExecutor.this.mMessageObject.sequence = StatusDataBcastUploadExecutor.this.mSequence;
                            StatusDataBcastUploadExecutor.this.mMessageObject.object_sequence = StatusDataBcastUploadExecutor.this.mObjSequence;
                            StatusDataBcastUploadExecutor.this.mMessageObject.object_owner = StatusDataBcastUploadExecutor.this.mUserpin;
                            StatusDataBcastUploadExecutor.this.mMessageObject.image_path = StatusDataBcastUploadExecutor.this.mDataFile.getAbsolutePath();
                            StatusDataBcastUploadExecutor.this.mMessageObject.imagethumb_uri = StatusDataBcastUploadExecutor.this.mImagethumuri;
                            StatusDataBcastUploadExecutor.this.mMessageObject.deliverystatus = MessageDeliveryStatus.BCASTQUEUE;
                            StatusDataBcastUploadExecutor.this.mMessageObject.username = string;
                            StatusDataBcastUploadExecutor.this.mMessageObject.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                            StatusDataBcastUploadExecutor.this.mMessageObject.recipient = StatusDataBcastUploadExecutor.this.mRecipient;
                            string = "sc:" + StatusDataBcastUploadExecutor.this.mRecipient + ":" + StatusDataBcastUploadExecutor.this.mStatusSequence;
                            StatusDataBcastUploadExecutor.this.mConvKey = string;
                            StatusDataBcastUploadExecutor.this.mMessageObject.conversation_key = string;
                            catfishDataStorage.storeUserMessage(StatusDataBcastUploadExecutor.this.mMessageObject);
                            StatusDataBcastUploadExecutor.this.mService.postToMainHandler(new InvokeClientCallback(StatusDataBcastUploadExecutor.this.mClientInterface, catfishDataStorage.getChatConversation(StatusDataBcastUploadExecutor.this.mConvKey)));
                            Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: Put Message in recipients record: DONE");
                            Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: Post To Service: Upload DATA Chunks");
                            StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(new DataBcastUploadChunk(), 2);
                            return;
                        } catch (FileNotFoundException e3) {
                            Log.e(StatusDataBcastUploadExecutor.TAG, "----STATCOMM DATA FILE: " + e3.toString());
                            LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                            StatusDataBcastUploadExecutor.this.mChunkstream = null;
                            if (StatusDataBcastUploadExecutor.this.mCacheFile.exists()) {
                                StatusDataBcastUploadExecutor.this.mCacheFile.delete();
                            }
                            StatusDataBcastUploadExecutor.this.deteleThumbFile(uri);
                            return;
                        }
                    }
                    Log.d(StatusDataBcastUploadExecutor.TAG, "Thumbnail FAIL to create");
                }
            };
            Log.d(TAG, "uri" + Uri.fromFile(this.mDataFile));
            anonymousClass1.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
        } else if (this.mTipe.equals(AlbusModelObject.DATA_TYPE_VIDEO)) {
            ImageThumbnailer anonymousClass2 = new ImageThumbnailer(this.mService, CatfishService.getUserPIN(), 0, true, this.mDataFile.getAbsolutePath()) {
                protected void onPostExecute(Uri uri) {
                    if (uri != null) {
                        StatusDataBcastUploadExecutor.this.mImagethumuri = uri.toString();
                        Log.d(StatusDataBcastUploadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                    } else {
                        Log.d(StatusDataBcastUploadExecutor.TAG, "Thumbnail FAIL to create");
                    }
                    try {
                        Long valueOf = Long.valueOf(StatusDataBcastUploadExecutor.this.mDataFile.length());
                        StatusDataBcastUploadExecutor.this.mDatasize = valueOf.intValue();
                        StatusDataBcastUploadExecutor.this.mChunkstream = new FileInputStream(StatusDataBcastUploadExecutor.this.mDataFile);
                        StatusDataBcastUploadExecutor.this.mChunkbuffer = new byte[StatusDataBcastUploadExecutor.mChunkMaxSize];
                        Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: Put Message in recipients record: " + StatusDataBcastUploadExecutor.this.mDataFile.getAbsolutePath());
                        CatfishDataStorage catfishDataStorage = new CatfishDataStorage(StatusDataBcastUploadExecutor.this.mService);
                        String string = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                        StatusDataBcastUploadExecutor.this.mMessageObject = new CatfishMessageObject();
                        StatusDataBcastUploadExecutor.this.mMessageObject.messagetype = MessageType.BCASTVIDEOSTATUS;
                        StatusDataBcastUploadExecutor.this.mMessageObject.userpin = StatusDataBcastUploadExecutor.this.mUserpin;
                        StatusDataBcastUploadExecutor.this.mMessageObject.senderpin = StatusDataBcastUploadExecutor.this.mUserpin;
                        StatusDataBcastUploadExecutor.this.mMessageObject.sendername = string;
                        StatusDataBcastUploadExecutor.this.mMessageObject.message = StatusDataBcastUploadExecutor.this.mMessage;
                        StatusDataBcastUploadExecutor.this.mMessageObject.sequence = StatusDataBcastUploadExecutor.this.mSequence;
                        StatusDataBcastUploadExecutor.this.mMessageObject.object_sequence = StatusDataBcastUploadExecutor.this.mObjSequence;
                        StatusDataBcastUploadExecutor.this.mMessageObject.object_owner = StatusDataBcastUploadExecutor.this.mUserpin;
                        StatusDataBcastUploadExecutor.this.mMessageObject.datafile_path = StatusDataBcastUploadExecutor.this.mDataFile.getAbsolutePath();
                        StatusDataBcastUploadExecutor.this.mMessageObject.deliverystatus = MessageDeliveryStatus.BCASTQUEUE;
                        StatusDataBcastUploadExecutor.this.mMessageObject.username = string;
                        StatusDataBcastUploadExecutor.this.mMessageObject.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                        StatusDataBcastUploadExecutor.this.mMessageObject.recipient = StatusDataBcastUploadExecutor.this.mRecipient;
                        string = "sc:" + StatusDataBcastUploadExecutor.this.mRecipient + ":" + StatusDataBcastUploadExecutor.this.mStatusSequence;
                        StatusDataBcastUploadExecutor.this.mConvKey = string;
                        StatusDataBcastUploadExecutor.this.mMessageObject.conversation_key = string;
                        catfishDataStorage.storeUserMessage(StatusDataBcastUploadExecutor.this.mMessageObject);
                        StatusDataBcastUploadExecutor.this.mService.postToMainHandler(new InvokeClientCallback(StatusDataBcastUploadExecutor.this.mClientInterface, catfishDataStorage.getChatConversation(StatusDataBcastUploadExecutor.this.mConvKey)));
                        Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: Put Message in recipients record: DONE");
                        Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM: Post To Service: Upload DATA Chunks");
                        StatusDataBcastUploadExecutor.this.mService.postToServiceHandler(new DataBcastUploadChunk(), 2);
                    } catch (FileNotFoundException e) {
                        Log.d(StatusDataBcastUploadExecutor.TAG, "----STATCOMM DATA FILE: " + e.toString());
                        LocalBroadcastManager.getInstance(StatusDataBcastUploadExecutor.this.mService).unregisterReceiver(StatusDataBcastUploadExecutor.this.mCancelUploadReceiver);
                        StatusDataBcastUploadExecutor.this.mChunkstream = null;
                    }
                }
            };
            Log.d(TAG, "uri" + Uri.fromFile(this.mDataFile));
            anonymousClass2.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
        } else if (this.mTipe.equals(AlbusModelObject.TEXT)) {
            try {
                this.mDatasize = Long.valueOf(this.mDataFile.length()).intValue();
                this.mChunkstream = new FileInputStream(this.mDataFile);
                this.mChunkbuffer = new byte[mChunkMaxSize];
                Log.d(TAG, "----STATCOMM: Put Message in recipients record: " + this.mDataFile.getAbsolutePath());
                r0 = new CatfishDataStorage(this.mService);
                r1 = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                this.mMessageObject = new CatfishMessageObject();
                this.mMessageObject.messagetype = MessageType.LONGSTATUSCOMMENT;
                this.mMessageObject.userpin = this.mUserpin;
                this.mMessageObject.senderpin = this.mUserpin;
                this.mMessageObject.sendername = r1;
                this.mMessageObject.message = this.mMessage;
                this.mMessageObject.sequence = this.mSequence;
                this.mMessageObject.object_sequence = this.mObjSequence;
                this.mMessageObject.object_owner = this.mUserpin;
                this.mMessageObject.datafile_path = this.mDataFile.getAbsolutePath();
                this.mMessageObject.deliverystatus = MessageDeliveryStatus.BCASTQUEUE;
                this.mMessageObject.username = r1;
                this.mMessageObject.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                this.mMessageObject.recipient = this.mRecipient;
                r1 = "sc:" + this.mRecipient + ":" + this.mStatusSequence;
                this.mConvKey = r1;
                this.mMessageObject.conversation_key = r1;
                CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
                catfishMessageObject.sequence = this.mSequence;
                catfishMessageObject.message = this.mLongMessagePreview;
                r0.updatDiscussMessage(catfishMessageObject);
                this.mService.postToMainHandler(new InvokeClientCallback(this.mClientInterface, r0.getChatConversation(this.mConvKey)));
                Log.d(TAG, "----STATCOMM: Put Message in recipients record: DONE");
                Log.d(TAG, "----STATCOMM: Post To Service: Upload DATA Chunks");
                this.mService.postToServiceHandler(new DataBcastUploadChunk(), 2);
            } catch (FileNotFoundException e) {
                Log.d(TAG, "----STATCOMM DATA FILE: " + e.toString());
                LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelUploadReceiver);
                this.mChunkstream = null;
            }
        } else if (this.mTipe.equals(AlbusModelObject.DATA_TYPE_VOICE)) {
            try {
                this.mDatasize = Long.valueOf(this.mDataFile.length()).intValue();
                this.mChunkstream = new FileInputStream(this.mDataFile);
                this.mChunkbuffer = new byte[mChunkMaxSize];
                Log.d(TAG, "----STATCOMM: Put Message in recipients record: " + this.mDataFile.getAbsolutePath());
                r0 = new CatfishDataStorage(this.mService);
                r1 = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                this.mMessageObject = new CatfishMessageObject();
                this.mMessageObject.messagetype = MessageType.BCASTVOICESTATUS;
                this.mMessageObject.userpin = this.mUserpin;
                this.mMessageObject.senderpin = this.mUserpin;
                this.mMessageObject.sendername = r1;
                this.mMessageObject.message = this.mMessage;
                this.mMessageObject.sequence = this.mSequence;
                this.mMessageObject.object_sequence = this.mObjSequence;
                this.mMessageObject.object_owner = this.mUserpin;
                this.mMessageObject.voicefilepath = this.mDataFile.getAbsolutePath();
                this.mMessageObject.imagethumb_uri = this.mImagethumuri;
                this.mMessageObject.deliverystatus = MessageDeliveryStatus.BCASTQUEUE;
                this.mMessageObject.username = r1;
                this.mMessageObject.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                this.mMessageObject.recipient = this.mRecipient;
                r1 = "sc:" + this.mRecipient + ":" + this.mStatusSequence;
                this.mConvKey = r1;
                this.mMessageObject.conversation_key = r1;
                r0.storeUserMessage(this.mMessageObject);
                this.mService.postToMainHandler(new InvokeClientCallback(this.mClientInterface, r0.getChatConversation(this.mConvKey)));
                Log.d(TAG, "----STATCOMM: Put Message in recipients record: DONE");
                Log.d(TAG, "----STATCOMM: Post To Service: Upload DATA Chunks");
                this.mService.postToServiceHandler(new DataBcastUploadChunk(), 2);
            } catch (FileNotFoundException e2) {
                Log.d(TAG, "----STATCOMM DATA FILE: " + e2.toString());
                LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelUploadReceiver);
                this.mChunkstream = null;
            }
        }
    }
}

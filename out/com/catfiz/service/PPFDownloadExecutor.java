package com.catfiz.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v4.content.LocalBroadcastManager;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.media.CatfishPhotoStorage;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishUIBinder.DatabaseRequestOP;
import com.catfiz.service.uidbexec.CUIDatabaseRequestExecutor;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.Log;
import com.catfiz.util.ObjectLockManager;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class PPFDownloadExecutor implements IDropableRunnable, Runnable {
    private static final String TAG = "PPFDownloadExecutor";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge;
    private int mByteend = 0;
    private int mBytestart = 0;
    private boolean mCancel;
    private BroadcastReceiver mCancelReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String stringExtra = intent.getStringExtra(TaskDataStorage.SENDERPIN);
            if (stringExtra == null) {
                Log.d(PPFDownloadExecutor.TAG, "INVALID Sender Pin: DO NOT CANCEL");
            } else if (PPFDownloadExecutor.this.mFriendpin == null || !PPFDownloadExecutor.this.mFriendpin.equals(stringExtra)) {
                Log.d(PPFDownloadExecutor.TAG, "Current Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(PPFDownloadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + stringExtra);
                PPFDownloadExecutor.this.mCancel = true;
            }
        }
    };
    private FileOutputStream mChunkstream = null;
    private String mFriendpin = null;
    private ICatfishUIBinder mIBinder = null;
    private ICatfishClientInterface mIfclient = null;
    public boolean mLastUpdatePerStep = false;
    public String mLockKey = null;
    public String mLockObj = null;
    private int mPhotosize = 0;
    private boolean mSchedOnPendingList = false;
    private String mServer = null;
    private CatfishService mService = null;
    private String mUserName = null;
    private String mUserpin = null;
    private int mWriten = 0;
    public int scheduleNum = 0;

    class GetProfilePhotoChunks implements IDropableRunnable, Runnable {
        private boolean bNotifyUI;
        private CatfishRESTAPI catfishRestAPI;
        private volatile long mAge;
        public int scheduleNum;

        private GetProfilePhotoChunks() {
            this.bNotifyUI = false;
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            Log.d(PPFDownloadExecutor.TAG, "Friend (" + PPFDownloadExecutor.this.mFriendpin + ") Photo Download: DROP BY SERVICE");
            ObjectLockManager.releaseLockKey(PPFDownloadExecutor.this.mLockKey);
            LocalBroadcastManager.getInstance(PPFDownloadExecutor.this.mService).unregisterReceiver(PPFDownloadExecutor.this.mCancelReceiver);
            try {
                PPFDownloadExecutor.this.mChunkstream.flush();
                PPFDownloadExecutor.this.mChunkstream.close();
            } catch (IOException e) {
                LocalBroadcastManager.getInstance(PPFDownloadExecutor.this.mService).unregisterReceiver(PPFDownloadExecutor.this.mCancelReceiver);
            }
            if (PPFDownloadExecutor.this.mSchedOnPendingList) {
                Log.d(PPFDownloadExecutor.TAG, "DROP BY SERVICE " + PPFDownloadExecutor.this.mFriendpin + " PHOTO: EXECUTE NEXT PENDING AND ADD TO PENDING");
                PPFDownloadExecutor.this.mService.getProfilePhotoPendingList().executePendingByService(PPFDownloadExecutor.this.mService);
                PPFDownloadExecutor.this.mService.getProfilePhotoPendingList().pushPending(PPFDownloadExecutor.this.mFriendpin);
            }
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (!ObjectLockManager.isLockKeyLocked(PPFDownloadExecutor.this.mLockKey)) {
                Log.e(PPFDownloadExecutor.TAG, "GetProfilePhotoChunks: INCONSISTENT LOCK!!!: DROP");
                try {
                    PPFDownloadExecutor.this.mChunkstream.flush();
                    PPFDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e) {
                    LocalBroadcastManager.getInstance(PPFDownloadExecutor.this.mService).unregisterReceiver(PPFDownloadExecutor.this.mCancelReceiver);
                }
                PPFDownloadExecutor.this.abortDownloadPhoto(null);
            } else if (ObjectLockManager.checkLockKeyString(PPFDownloadExecutor.this.mLockKey, PPFDownloadExecutor.this.mLockObj)) {
                Log.d(PPFDownloadExecutor.TAG, "GetProfilePhotoChunks: WE HAVE HELD THE LOCK: Continue...");
                if (CatfishPhotoStorage.isPhotoStorageMounted()) {
                    Log.d(PPFDownloadExecutor.TAG, "Get byte range: bs=" + String.valueOf(PPFDownloadExecutor.this.mBytestart) + ", " + "be=" + String.valueOf(PPFDownloadExecutor.this.mByteend) + ", " + "size=" + String.valueOf(PPFDownloadExecutor.this.mPhotosize) + ", " + "mWriten=" + String.valueOf(PPFDownloadExecutor.this.mWriten) + ", friend=" + PPFDownloadExecutor.this.mFriendpin);
                    if (PPFDownloadExecutor.this.mCancel) {
                        Log.d(PPFDownloadExecutor.TAG, "canceling upload is on progress.....");
                        PPFDownloadExecutor.this.onDownloadPhotoFail();
                        try {
                            PPFDownloadExecutor.this.mChunkstream.flush();
                            PPFDownloadExecutor.this.mChunkstream.close();
                            return;
                        } catch (IOException e2) {
                            return;
                        }
                    }
                    CatfishResult downloadProfilePhotoChunk = this.catfishRestAPI.downloadProfilePhotoChunk(PPFDownloadExecutor.this.mServer, PPFDownloadExecutor.this.mUserpin, PPFDownloadExecutor.this.mFriendpin, PPFDownloadExecutor.this.mBytestart, PPFDownloadExecutor.this.mByteend, PPFDownloadExecutor.this.mChunkstream);
                    Log.d(PPFDownloadExecutor.TAG, "Chunksize: " + String.valueOf(downloadProfilePhotoChunk.chunksize));
                    if (downloadProfilePhotoChunk.hasSuccess() && downloadProfilePhotoChunk.chunksize != 0) {
                        this.mAge = System.currentTimeMillis();
                        if (downloadProfilePhotoChunk.chunksize > 0) {
                            PPFDownloadExecutor.this.mWriten = PPFDownloadExecutor.this.mWriten + downloadProfilePhotoChunk.chunksize;
                        }
                        if (PPFDownloadExecutor.this.mWriten < PPFDownloadExecutor.this.mPhotosize) {
                            PPFDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.growChunkSize(PPFDownloadExecutor.mChunkMaxSize);
                            PPFDownloadExecutor.this.mBytestart = PPFDownloadExecutor.this.mWriten;
                            PPFDownloadExecutor.this.mByteend = (PPFDownloadExecutor.this.mBytestart + PPFDownloadExecutor.mChunkMaxSize) - 1;
                            this.mAge = System.currentTimeMillis();
                            PPFDownloadExecutor.this.mService.postToServiceHandler(this, 2);
                            downloadProfilePhotoChunk.cleaningup();
                            return;
                        }
                        Log.d(PPFDownloadExecutor.TAG, "Get Profile Photo Chunks: DONE");
                        this.bNotifyUI = true;
                        ObjectLockManager.releaseLockKey(PPFDownloadExecutor.this.mLockKey);
                        try {
                            PPFDownloadExecutor.this.mChunkstream.flush();
                            PPFDownloadExecutor.this.mChunkstream.close();
                        } catch (IOException e3) {
                        }
                        if (PPFDownloadExecutor.this.mFriendpin.compareTo(PPFDownloadExecutor.this.mUserpin) == 0) {
                            CatfishPhotoStorage.setTempToUserPhotoProfile(PPFDownloadExecutor.this.mService);
                        } else {
                            CatfishPhotoStorage.setTempToFriendPhotoProfile(PPFDownloadExecutor.this.mService, PPFDownloadExecutor.this.mFriendpin);
                        }
                        PPFDownloadExecutor.this.onDownloadPhotoSuccess();
                        PPFDownloadExecutor.this.mService.postRunnableToDbThread(new SetRecentUpdatesDB());
                    } else if (downloadProfilePhotoChunk.hasNotFound() && PPFDownloadExecutor.this.mWriten > 0) {
                        Log.d(PPFDownloadExecutor.TAG, "Get Profile Photo Chunks: NOT FOUND IN MIDLE DOWNLOAD: Cancel!!!");
                        ObjectLockManager.releaseLockKey(PPFDownloadExecutor.this.mLockKey);
                        try {
                            PPFDownloadExecutor.this.mChunkstream.flush();
                            PPFDownloadExecutor.this.mChunkstream.close();
                        } catch (IOException e4) {
                        }
                        this.bNotifyUI = false;
                        PPFDownloadExecutor.this.onDownloadPhotoFail();
                    } else if (downloadProfilePhotoChunk.hasFailure()) {
                        Log.d(PPFDownloadExecutor.TAG, "Get Profile Photo Chunks: FAIL: Reschedule");
                        if (downloadProfilePhotoChunk.chunksize > 0) {
                            this.mAge = System.currentTimeMillis();
                            PPFDownloadExecutor.this.mWriten = PPFDownloadExecutor.this.mWriten + downloadProfilePhotoChunk.chunksize;
                            if (PPFDownloadExecutor.this.mWriten >= PPFDownloadExecutor.this.mPhotosize) {
                                Log.d(PPFDownloadExecutor.TAG, "Get Profile Photo Chunks: DONE (In Failure)");
                                this.bNotifyUI = true;
                                ObjectLockManager.releaseLockKey(PPFDownloadExecutor.this.mLockKey);
                                try {
                                    PPFDownloadExecutor.this.mChunkstream.flush();
                                    PPFDownloadExecutor.this.mChunkstream.close();
                                } catch (IOException e5) {
                                }
                                PPFDownloadExecutor.this.onDownloadPhotoSuccess();
                                PPFDownloadExecutor.this.mService.postRunnableToDbThread(new SetRecentUpdatesDB());
                                downloadProfilePhotoChunk.cleaningup();
                                return;
                            }
                            PPFDownloadExecutor.this.mBytestart = PPFDownloadExecutor.this.mWriten;
                            PPFDownloadExecutor.this.mByteend = (PPFDownloadExecutor.this.mWriten + PPFDownloadExecutor.mChunkMaxSize) - 1;
                            this.mAge = System.currentTimeMillis();
                            PPFDownloadExecutor.this.mService.postToServiceHandler(this, 2);
                            downloadProfilePhotoChunk.cleaningup();
                            return;
                        }
                        PPFDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(PPFDownloadExecutor.mChunkMaxSize);
                        PPFDownloadExecutor.this.mServer = CatfishService.getServerHost();
                        PPFDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
                        downloadProfilePhotoChunk.cleaningup();
                        return;
                    } else {
                        Log.d(PPFDownloadExecutor.TAG, "Get Profile Photo Chunks: ERROR: DROP");
                        ObjectLockManager.releaseLockKey(PPFDownloadExecutor.this.mLockKey);
                        try {
                            PPFDownloadExecutor.this.mChunkstream.flush();
                            PPFDownloadExecutor.this.mChunkstream.close();
                        } catch (IOException e6) {
                        }
                        this.bNotifyUI = false;
                        PPFDownloadExecutor.this.onDownloadPhotoFail();
                    }
                    downloadProfilePhotoChunk.cleaningup();
                    if (this.bNotifyUI && PPFDownloadExecutor.this.mFriendpin.compareTo(PPFDownloadExecutor.this.mUserpin) != 0) {
                        PPFDownloadExecutor.this.mService.signalHasFriendProfileUpdate(PPFDownloadExecutor.this.mFriendpin);
                        return;
                    }
                    return;
                }
                Log.d(PPFDownloadExecutor.TAG, "Media not mounted when download chunk for " + PPFDownloadExecutor.this.mFriendpin + ": RESCHEDULE");
                ObjectLockManager.releaseLockKey(PPFDownloadExecutor.this.mLockKey);
                LocalBroadcastManager.getInstance(PPFDownloadExecutor.this.mService).unregisterReceiver(PPFDownloadExecutor.this.mCancelReceiver);
                PPFDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.d(PPFDownloadExecutor.TAG, "GetProfilePhotoChunks: OOPS LOCK ITS NOT MINE: CANCEL");
                PPFDownloadExecutor.this.abortDownloadPhoto(PPFDownloadExecutor.this.mLockKey);
                try {
                    PPFDownloadExecutor.this.mChunkstream.flush();
                    PPFDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e7) {
                    LocalBroadcastManager.getInstance(PPFDownloadExecutor.this.mService).unregisterReceiver(PPFDownloadExecutor.this.mCancelReceiver);
                }
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class SetRecentUpdatesDB implements Runnable {
        private SetRecentUpdatesDB() {
        }

        public void run() {
            if (PPFDownloadExecutor.this.mFriendpin.compareTo(PPFDownloadExecutor.this.mUserpin) != 0) {
                new FriendListDataStorage(PPFDownloadExecutor.this.mService).setFriendLastActivity(PPFDownloadExecutor.this.mFriendpin, CatfishRESTAPI.uniqueMonotonicSequence());
            }
        }
    }

    public PPFDownloadExecutor(CatfishService catfishService, String str, String str2, String str3) {
        initPPFDownloadExecutor(catfishService, str, str2, str3);
        this.mSchedOnPendingList = false;
    }

    public PPFDownloadExecutor(CatfishService catfishService, String str, String str2, String str3, boolean z) {
        initPPFDownloadExecutor(catfishService, str, str2, str3);
        this.mSchedOnPendingList = z;
    }

    public PPFDownloadExecutor(ICatfishClientInterface iCatfishClientInterface, ICatfishUIBinder iCatfishUIBinder, CatfishService catfishService, String str, String str2, String str3, boolean z, boolean z2) {
        initPPFDownloadExecutor(catfishService, str, str2, str3);
        this.mSchedOnPendingList = z;
        this.mIfclient = iCatfishClientInterface;
        this.mIBinder = iCatfishUIBinder;
        this.mLastUpdatePerStep = z2;
    }

    private void initPPFDownloadExecutor(CatfishService catfishService, String str, String str2, String str3) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mFriendpin = str3;
        this.mLockKey = "ppfdownload:" + this.mFriendpin;
        this.mLockObj = String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence());
        ObjectLockManager.acquireLockKey(this.mLockKey, this.mLockObj);
        this.mAge = System.currentTimeMillis();
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_PROFILE_DOWNLOAD));
    }

    public void abortDownloadPhoto(String str) {
        if (str != null) {
            ObjectLockManager.releaseLockKey(str);
        }
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
        if (this.mSchedOnPendingList) {
            this.mService.getProfilePhotoPendingList().removeFromPending(this.mFriendpin);
            this.mService.getProfilePhotoPendingList().removePendingTask(this.mFriendpin);
            Log.d(TAG, "DOWNLOAD ABORTED: " + this.mFriendpin + " EXECUTE NEXT PENDING");
            this.mService.getProfilePhotoPendingList().executeNextPending(this.mService);
        }
    }

    public void dropRunnable() {
        ObjectLockManager.releaseLockKey(this.mLockKey);
        if (this.mSchedOnPendingList) {
            Log.d(TAG, "DROP BY SERVICE " + this.mFriendpin + " PHOTO: EXECUTE NEXT PENDING AND ADD TO PENDING");
            this.mService.getProfilePhotoPendingList().executePendingByService(this.mService);
            this.mService.getProfilePhotoPendingList().pushPending(this.mFriendpin);
        }
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void onDownloadPhotoFail() {
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
        if (this.mSchedOnPendingList) {
            Log.d(TAG, "FAIL TO DOWNLOAD " + this.mFriendpin + " PHOTO: EXECUTE NEXT PENDING AND ADD TO PENDING");
            this.mService.getProfilePhotoPendingList().executeNextPending(this.mService);
            this.mService.getProfilePhotoPendingList().pushPending(this.mFriendpin);
        }
    }

    public void onDownloadPhotoSuccess() {
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
        this.mService.getProfilePhotoPendingList().removePendingTask(this.mFriendpin);
        if (this.mSchedOnPendingList) {
            this.mService.getProfilePhotoPendingList().executeNextPending(this.mService);
        }
        if (this.mLastUpdatePerStep) {
            this.mService.postToDBHandler(new CUIDatabaseRequestExecutor(this.mIBinder, this.mIfclient, DatabaseRequestOP.UPDATE_PHOTO_FRIENDS));
        }
        Log.d(TAG, "ppf download download successsend broadcast photo");
        Intent intent = new Intent(BroadcastIntents.ACTION_PPF_DONE);
        intent.putExtra(CatfishService.PPF_DOWNLOAD_FRIENDPIN, this.mFriendpin);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
    }

    public void onMediaNotMounted() {
        if (this.mSchedOnPendingList) {
            Log.d(TAG, "FAIL TO DOWNLOAD:MEDIA NOT MOUNTED: " + this.mFriendpin + " PHOTO: ADD " + this.mFriendpin + " TO PENDING LIST");
            this.mService.getProfilePhotoPendingList().pushPending(this.mFriendpin);
        }
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
    }

    public void run() {
        if (!ObjectLockManager.isLockKeyLocked(this.mLockKey)) {
            Log.e(TAG, "INCONSISTENT LOCK!!!: DROP");
            abortDownloadPhoto(null);
        } else if (ObjectLockManager.checkLockKeyString(this.mLockKey, this.mLockObj)) {
            Log.d(TAG, "WE HAVE HELD THE LOCK: Continue...");
            if (CatfishPhotoStorage.isPhotoStorageMounted()) {
                CatfishResult userProfileInfo = this.catfishRestAPI.getUserProfileInfo(this.mServer, this.mUserpin, this.mFriendpin);
                if (userProfileInfo.hasFailure()) {
                    Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download: FAIL GET USER PROFILE: Re schedule");
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
                    this.mServer = CatfishService.getServerHost();
                    this.mService.scheduleRunnableToService(this, 2);
                    userProfileInfo.cleaningup();
                    return;
                } else if (userProfileInfo.hasNotFound()) {
                    Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download: USER PROFILE NOT FOUND: DROP");
                    abortDownloadPhoto(this.mLockKey);
                    userProfileInfo.cleaningup();
                    return;
                } else if (!userProfileInfo.hasSuccess()) {
                    Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download: ERROR GET USER PROFILE: DROP");
                    abortDownloadPhoto(this.mLockKey);
                    userProfileInfo.cleaningup();
                    return;
                } else if (userProfileInfo.photoavailable) {
                    this.mPhotosize = userProfileInfo.photosize;
                    this.mUserName = userProfileInfo.username;
                    this.mByteend = mChunkMaxSize - 1;
                    try {
                        if (this.mFriendpin.compareTo(this.mUserpin) == 0) {
                            this.mChunkstream = new FileOutputStream(CatfishPhotoStorage.getUserProfilePhotoFileTemp(this.mService));
                        } else {
                            this.mChunkstream = new FileOutputStream(CatfishPhotoStorage.getFriendProfilePhotoFileTemp(this.mService, this.mFriendpin));
                        }
                        this.mService.getProfilePhotoPendingList().removeFromPending(this.mFriendpin);
                        Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download: Start Download...");
                        this.mService.postToServiceHandler(new GetProfilePhotoChunks(), 2);
                        return;
                    } catch (FileNotFoundException e) {
                        Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download: " + e.toString());
                        abortDownloadPhoto(this.mLockKey);
                        try {
                            this.mChunkstream.flush();
                            this.mChunkstream.close();
                            return;
                        } catch (Exception e2) {
                            return;
                        }
                    } catch (Exception e3) {
                        e3.printStackTrace();
                        Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download Fail");
                        abortDownloadPhoto(this.mLockKey);
                        try {
                            this.mChunkstream.flush();
                            this.mChunkstream.close();
                            return;
                        } catch (Exception e4) {
                            return;
                        }
                    }
                } else {
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
                    if (userProfileInfo.photoincomplete) {
                        Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download: PHOTO IS INCOMPLETE (BECOME AVAILABLE): DROP");
                        abortDownloadPhoto(this.mLockKey);
                        userProfileInfo.cleaningup();
                        return;
                    }
                    Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download: PHOTO IS NOT AVAILABLE: DROP");
                    abortDownloadPhoto(this.mLockKey);
                    userProfileInfo.cleaningup();
                    return;
                }
            }
            Log.d(TAG, "Friend (" + this.mFriendpin + ") Photo Download:Media Storage is NOT MOUNTED: ABORT !!!");
            ObjectLockManager.releaseLockKey(this.mLockKey);
            LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelReceiver);
            onMediaNotMounted();
        } else {
            Log.d(TAG, "OOPS LOCK ITS NOT MINE: CANCEL");
            abortDownloadPhoto(this.mLockKey);
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

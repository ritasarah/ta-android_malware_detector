package com.catfiz.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.Bitmap.Config;
import android.graphics.BitmapFactory;
import android.graphics.BitmapFactory.Options;
import android.net.Uri;
import android.support.v4.content.LocalBroadcastManager;
import com.catfiz.R;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.media.CatfishPhotoStorage;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.svcpersistent.P2PUploadBase;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.Log;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Locale;
import org.apache.commons.logging.impl.SimpleLog;
import org.apache.http.HttpStatus;
import org.apache.http.conn.routing.HttpRouteDirector;
import org.json.JSONException;
import org.json.JSONObject;

public class P2PUploadExecutor extends P2PUploadBase implements IDropableRunnable, Runnable {
    private static final String TAG = "P2PUploadExecutor";
    private static final int mChunkMaxSize = 131072;
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = System.currentTimeMillis();
    private int mByteEnd = 0;
    private int mByteStart = 0;
    private File mCacheFile = null;
    private BroadcastReceiver mCancelUploadReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            long longExtra = intent.getLongExtra(ServerMessageDataStorage.SEQUENCE, 0);
            if (longExtra == 0) {
                Log.d(P2PUploadExecutor.TAG, "INVALID SEQUENCE: DO NOT CANCEL");
            } else if (P2PUploadExecutor.this.mSequence == 0 || P2PUploadExecutor.this.mSequence != longExtra) {
                Log.d(P2PUploadExecutor.TAG, "Current Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(P2PUploadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + longExtra + " SEQ " + P2PUploadExecutor.this.mSequence);
                P2PUploadExecutor.this.mbCancelUpload = true;
            }
        }
    };
    private volatile long mChannelId = 0;
    private int mChunkOffset = 0;
    private byte[] mChunkbuffer = null;
    private volatile int mChunksize = 0;
    private File mDataFile = null;
    private FileInputStream mDatastream = null;
    private volatile int mDatastreamSize = 0;
    private volatile String mFilename = null;
    private String mImagethumuri = null;
    private int mInWaitTries = 0;
    private int mLastByteRead = 0;
    private String mLongMessagePreview = null;
    private CatfishMessageObject mMessage = null;
    private volatile String mRecipient = null;
    private volatile long mSequence = 0;
    private volatile String mServer = null;
    private volatile CatfishService mService = null;
    private volatile int mStreamType = 0;
    private boolean mTransparentFormat = false;
    private volatile String mUserpin = null;
    private boolean mbCancelUpload = false;
    public int scheduleNum = 0;

    public class AddPrepareStatusToDB implements Runnable {
        public void run() {
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(P2PUploadExecutor.this.mService);
            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(P2PUploadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            obtain.userpin = P2PUploadExecutor.this.mUserpin;
            obtain.recipient = P2PUploadExecutor.this.mRecipient;
            obtain.messagetype = MessageType.MESSAGE;
            obtain.rcvtimestamp = P2PUploadExecutor.this.mSequence;
            obtain.deliverystatus = MessageDeliveryStatus.QUEUEING;
            obtain.sequence = P2PUploadExecutor.this.mSequence;
            if (P2PUploadExecutor.this.mImagethumuri != null) {
                obtain.imagethumb_uri = P2PUploadExecutor.this.mImagethumuri.toString();
                Log.d(P2PUploadExecutor.TAG, "masuk");
            } else {
                Log.d(P2PUploadExecutor.TAG, "ga masuk");
            }
            switch (P2PUploadExecutor.this.mStreamType) {
                case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                    obtain.datafile_path = P2PUploadExecutor.this.mDataFile.getAbsolutePath();
                    obtain.message = P2PUploadExecutor.this.mService.getResources().getString(R.string.user_prepare_to_send);
                    break;
                case HttpRouteDirector.TUNNEL_PROXY /*4*/:
                    obtain.voicefilepath = P2PUploadExecutor.this.mDataFile.getAbsolutePath();
                    obtain.message = P2PUploadExecutor.this.mService.getResources().getString(R.string.user_prepare_to_send);
                    break;
                case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                    P2PUploadExecutor.this.mService.postToServiceHandler(new OpenP2PChannel(), 2);
                    return;
                default:
                    obtain.datafile_path = P2PUploadExecutor.this.mDataFile.getAbsolutePath();
                    obtain.message = P2PUploadExecutor.this.mDataFile.getName() + " " + P2PUploadExecutor.this.mService.getResources().getString(R.string.user_prepare_to_send);
                    break;
            }
            P2PUploadExecutor.this.fillMessage(obtain);
            if (catfishDataStorage.storeUserMessage(obtain)) {
                Log.d(P2PUploadExecutor.TAG, "Success: Writing User message to DB: GOOD !!!: CONTINUE SENDING");
            } else {
                Log.e(P2PUploadExecutor.TAG, "Error: Writing User message to DB FAIL !!!: CONTINUE SENDING");
            }
            friendListDataStorage.setFriendLastActivity(P2PUploadExecutor.this.mRecipient, obtain.rcvtimestamp);
            friendListDataStorage.updateActivityCount(P2PUploadExecutor.this.mRecipient, 600);
            friendListDataStorage.updateLastChatActivity(P2PUploadExecutor.this.mRecipient, obtain.rcvtimestamp);
            obtain.recycle();
            P2PUploadExecutor.this.mService.signalUploadStartSending();
            P2PUploadExecutor.this.mService.postToServiceHandler(new OpenP2PChannel(), 2);
        }
    }

    class BlockUploader implements IDropableRunnable, IP2PDropableRunnable, Runnable {
        private boolean bNeedRead;
        private volatile long mAge;
        private boolean mDeepWait;
        public int scheduleNum;

        public BlockUploader() {
            this.bNeedRead = true;
            this.mAge = 0;
            this.mDeepWait = false;
            this.scheduleNum = 0;
            this.mAge = System.currentTimeMillis();
        }

        public void dropRunnable() {
            synchronized (this) {
                Log.d(P2PUploadExecutor.TAG, "---P2P Channel: " + String.valueOf(P2PUploadExecutor.this.mChannelId) + ": DROP BY SERVICE !!!");
                LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).unregisterReceiver(P2PUploadExecutor.this.mCancelUploadReceiver);
                if (P2PUploadExecutor.this.mCacheFile != null) {
                    switch (P2PUploadExecutor.this.mStreamType) {
                        case e.b /*1*/:
                            if (P2PUploadExecutor.this.mCacheFile.exists()) {
                                P2PUploadExecutor.this.mCacheFile.delete();
                                break;
                            }
                            break;
                    }
                }
                if (P2PUploadExecutor.this.mService != null) {
                    P2PUploadExecutor.this.mService.postRunnableToDbThread(new UpdateSendMessageStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_send_fail)));
                }
                if (P2PUploadExecutor.this.mDatastream == null) {
                    return;
                }
                try {
                    P2PUploadExecutor.this.mDatastream.close();
                } catch (IOException e) {
                }
                P2PUploadExecutor.this.mChunkbuffer = null;
                P2PUploadExecutor.this.deleteTaskState(String.valueOf(P2PUploadExecutor.this.mSequence), false);
            }
        }

        public long getAge() {
            return this.mAge;
        }

        public String getChannelId() {
            return String.valueOf(P2PUploadExecutor.this.mChannelId);
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public boolean isInDeepWait() {
            return this.mDeepWait;
        }

        public void run() {
            JSONObject jSONObject = new JSONObject();
            try {
                jSONObject.put("transparent", P2PUploadExecutor.this.mTransparentFormat);
            } catch (JSONException e) {
                e.printStackTrace();
            }
            P2PUploadExecutor.this.updateTaskState(String.valueOf(P2PUploadExecutor.this.mSequence), P2PUploadExecutor.this.mCacheFile.getAbsolutePath(), P2PUploadExecutor.this.mRecipient, P2PUploadExecutor.this.mDatastreamSize, P2PUploadExecutor.this.mByteStart, P2PUploadExecutor.this.mChunkOffset, P2PUploadExecutor.this.mStreamType, P2PUploadExecutor.this.mChannelId, jSONObject.toString(), false);
            if (P2PUploadExecutor.this.mDatastream == null) {
                Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: Data Stream INVALID (NULL): DROP !!!");
                P2PUploadExecutor.this.mChunkbuffer = null;
                P2PUploadExecutor.this.mService.postRunnableToDbThread(new UpdateSendMessageStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_send_fail)));
                LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).unregisterReceiver(P2PUploadExecutor.this.mCancelUploadReceiver);
                P2PUploadExecutor.this.deleteTaskState(String.valueOf(P2PUploadExecutor.this.mSequence), false);
                return;
            }
            try {
                if (this.bNeedRead) {
                    this.bNeedRead = false;
                    P2PUploadExecutor.this.mChunksize = P2PUploadExecutor.this.mDatastream.read(P2PUploadExecutor.this.mChunkbuffer, 0, P2PUploadExecutor.mChunkMaxSize);
                    P2PUploadExecutor.this.mByteEnd = P2PUploadExecutor.this.mByteStart + P2PUploadExecutor.this.mChunksize;
                }
                Intent intent;
                if (P2PUploadExecutor.this.mChunksize <= 0) {
                    Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: SENT COMPLETE");
                    if (P2PUploadExecutor.this.mMessage != null) {
                        P2PUploadExecutor.this.sendBroadcastIntent(P2PUploadExecutor.this.mMessage);
                        P2PUploadExecutor.this.mMessage.recycle();
                        P2PUploadExecutor.this.mMessage = null;
                    }
                    LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).unregisterReceiver(P2PUploadExecutor.this.mCancelUploadReceiver);
                    if (P2PUploadExecutor.this.mCacheFile != null) {
                        switch (P2PUploadExecutor.this.mStreamType) {
                            case e.b /*1*/:
                                if (P2PUploadExecutor.this.mCacheFile.exists()) {
                                    P2PUploadExecutor.this.mCacheFile.delete();
                                    break;
                                }
                                break;
                        }
                    }
                    try {
                        P2PUploadExecutor.this.mDatastream.close();
                    } catch (IOException e2) {
                    }
                    P2PUploadExecutor.this.mService.postRunnableToDbThread(new UpdateSendMessageStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_send_completed)));
                    if (P2PUploadExecutor.this.mStreamType != 6) {
                        intent = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                        intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                        intent.putExtra(ServerMessageDataStorage.SEQUENCE, P2PUploadExecutor.this.mSequence);
                        LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).sendBroadcast(intent);
                    }
                    P2PUploadExecutor.this.deleteTaskState(String.valueOf(P2PUploadExecutor.this.mSequence), false);
                    P2PUploadExecutor.this.mChunkbuffer = null;
                } else if (P2PUploadExecutor.this.mbCancelUpload) {
                    LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).unregisterReceiver(P2PUploadExecutor.this.mCancelUploadReceiver);
                    if (P2PUploadExecutor.this.mStreamType != 6) {
                        intent = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                        intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                        intent.putExtra(ServerMessageDataStorage.SEQUENCE, P2PUploadExecutor.this.mSequence);
                        LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).sendBroadcast(intent);
                    }
                    if (P2PUploadExecutor.this.mCacheFile != null) {
                        switch (P2PUploadExecutor.this.mStreamType) {
                            case e.b /*1*/:
                                if (P2PUploadExecutor.this.mCacheFile.exists()) {
                                    P2PUploadExecutor.this.mCacheFile.delete();
                                    break;
                                }
                                break;
                        }
                        P2PUploadExecutor.this.deleteTaskState(String.valueOf(P2PUploadExecutor.this.mSequence), false);
                    }
                    try {
                        P2PUploadExecutor.this.mDatastream.close();
                    } catch (IOException e3) {
                    }
                    P2PUploadExecutor.this.mService.postRunnableToDbThread(new UpdateSendMessageStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_send_fail)));
                    P2PUploadExecutor.this.mChunkbuffer = null;
                } else {
                    Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload:EXECUTE p2pStore BYTESTART = " + String.valueOf(P2PUploadExecutor.this.mByteStart) + ", " + "BYTEEND = " + String.valueOf(P2PUploadExecutor.this.mByteEnd));
                    CatfishResult p2pStore = P2PUploadExecutor.this.catfishRestAPI.p2pStore(P2PUploadExecutor.this.mServer, P2PUploadExecutor.this.mUserpin, P2PUploadExecutor.this.mRecipient, P2PUploadExecutor.this.mStreamType, P2PUploadExecutor.this.mChannelId, P2PUploadExecutor.this.mByteStart, P2PUploadExecutor.this.mByteEnd - 1, P2PUploadExecutor.this.mChunkOffset, P2PUploadExecutor.this.mChunkbuffer);
                    if (p2pStore.hasFailure()) {
                        Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: FAIL: Re schedule in P2P !!!");
                        P2PUploadExecutor.this.mServer = CatfishService.getServerHost();
                        P2PUploadExecutor.this.mService.putWaitP2PSender(P2PUploadExecutor.this.mChannelId, this);
                    } else if (p2pStore.hasSuccess()) {
                        this.mAge = System.currentTimeMillis();
                        P2PUploadExecutor.this.mChunkOffset = 0;
                        P2PUploadExecutor.this.mByteStart = P2PUploadExecutor.this.mByteEnd;
                        this.bNeedRead = true;
                        if (P2PUploadExecutor.this.mStreamType != 6) {
                            int access$1000 = (P2PUploadExecutor.this.mByteStart * 100) / P2PUploadExecutor.this.mDatastreamSize;
                            Intent intent2 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                            intent2.putExtra(CatfishService.PROGRESS_VALUE, access$1000);
                            intent2.putExtra(ServerMessageDataStorage.SEQUENCE, P2PUploadExecutor.this.mSequence);
                            LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).sendBroadcast(intent2);
                        }
                        P2PUploadExecutor.this.mInWaitTries = 0;
                        this.mDeepWait = false;
                        Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: SELF POST TO UPLOAD NEXT CHUNK");
                        this.mAge = System.currentTimeMillis();
                        P2PUploadExecutor.this.mService.postToServiceHandler(this, 2);
                    } else if (p2pStore.hasWaitBlock()) {
                        if (p2pStore.byteread >= P2PUploadExecutor.this.mByteEnd - 1) {
                            P2PUploadExecutor.this.mChunkOffset = 0;
                            P2PUploadExecutor.this.mByteStart = P2PUploadExecutor.this.mByteEnd;
                            this.bNeedRead = true;
                            P2PUploadExecutor.this.mInWaitTries = 0;
                            this.mDeepWait = true;
                            Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload (In Waitblock): SELF POST TO UPLOAD NEXT CHUNK: DEEP WAIT MARK");
                            P2PUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        } else if (p2pStore.byteread > P2PUploadExecutor.this.mByteStart) {
                            P2PUploadExecutor.this.mChunkOffset = (p2pStore.byteread - P2PUploadExecutor.this.mByteStart) + 1;
                            this.bNeedRead = false;
                            P2PUploadExecutor.this.mByteStart = p2pStore.byteread + 1;
                            Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload(In Waitblock): BYTESTART = " + String.valueOf(P2PUploadExecutor.this.mByteStart) + ", " + "BYTEEND = " + String.valueOf(P2PUploadExecutor.this.mByteEnd - 1) + ", " + "CHUNKOFFS = " + String.valueOf(P2PUploadExecutor.this.mChunkOffset) + ", " + "LEN = " + String.valueOf((P2PUploadExecutor.this.mByteEnd - P2PUploadExecutor.this.mByteStart) + 1));
                            if (P2PUploadExecutor.this.mByteStart >= P2PUploadExecutor.this.mByteEnd) {
                                Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload(In Waitblock): MARK READ STREAM");
                                P2PUploadExecutor.this.mChunkOffset = 0;
                                this.bNeedRead = true;
                                P2PUploadExecutor.this.mInWaitTries = 0;
                                this.mDeepWait = true;
                                P2PUploadExecutor.this.mService.postToServiceHandler(this, 2);
                                return;
                            }
                        } else if ((p2pStore.byteend - p2pStore.bytestart) - 1 > 0) {
                            P2PUploadExecutor.this.mChunkOffset = (p2pStore.byteend - P2PUploadExecutor.this.mByteStart) + 1;
                            this.bNeedRead = false;
                            P2PUploadExecutor.this.mByteStart = p2pStore.byteend + 1;
                            Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: BYTESTART = " + String.valueOf(P2PUploadExecutor.this.mByteStart) + ", " + "BYTEEND = " + String.valueOf(P2PUploadExecutor.this.mByteEnd - 1) + ", " + "CHUNKOFFS = " + String.valueOf(P2PUploadExecutor.this.mChunkOffset) + ", " + "LEN = " + String.valueOf((P2PUploadExecutor.this.mByteEnd - P2PUploadExecutor.this.mByteStart) + 1));
                            if (P2PUploadExecutor.this.mByteStart >= P2PUploadExecutor.this.mByteEnd) {
                                Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: MARK READ STREAM");
                                P2PUploadExecutor.this.mChunkOffset = 0;
                                this.bNeedRead = true;
                                P2PUploadExecutor.this.mInWaitTries = 0;
                                this.mDeepWait = true;
                                P2PUploadExecutor.this.mService.postToServiceHandler(this, 2);
                                return;
                            }
                        }
                        Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: WAIT");
                        P2PUploadExecutor.this.mService.putWaitP2PSender(P2PUploadExecutor.this.mChannelId, this);
                    } else {
                        Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: ERROR: DROP !!!");
                        LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).unregisterReceiver(P2PUploadExecutor.this.mCancelUploadReceiver);
                        P2PUploadExecutor.this.mService.cancelWaitP2PSender(P2PUploadExecutor.this.mChannelId);
                        if (P2PUploadExecutor.this.mStreamType != 6) {
                            Intent intent3 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                            intent3.putExtra(CatfishService.PROGRESS_VALUE, 0);
                            intent3.putExtra(ServerMessageDataStorage.SEQUENCE, P2PUploadExecutor.this.mSequence);
                            intent3.putExtra("fail", true);
                            LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).sendBroadcast(intent3);
                        }
                        if (P2PUploadExecutor.this.mCacheFile != null) {
                            switch (P2PUploadExecutor.this.mStreamType) {
                                case e.b /*1*/:
                                    if (P2PUploadExecutor.this.mCacheFile.exists()) {
                                        P2PUploadExecutor.this.mCacheFile.delete();
                                        break;
                                    }
                                    break;
                            }
                        }
                        try {
                            P2PUploadExecutor.this.mDatastream.close();
                        } catch (IOException e4) {
                        }
                        P2PUploadExecutor.this.mService.postRunnableToDbThread(new UpdateSendMessageStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_send_fail)));
                        P2PUploadExecutor.this.deleteTaskState(String.valueOf(P2PUploadExecutor.this.mSequence), false);
                        P2PUploadExecutor.this.mChunkbuffer = null;
                    }
                    p2pStore.cleaningup();
                }
            } catch (IOException e5) {
                Log.d(P2PUploadExecutor.TAG, "----P2P Block Upload: FAIL TO READ DATA INPUTSTREAM: CANCELED");
                P2PUploadExecutor.this.mService.postRunnableToDbThread(new UpdateSendMessageStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_send_fail)));
                LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).unregisterReceiver(P2PUploadExecutor.this.mCancelUploadReceiver);
                P2PUploadExecutor.this.deleteTaskState(String.valueOf(P2PUploadExecutor.this.mSequence), false);
                P2PUploadExecutor.this.mChunkbuffer = null;
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            P2PUploadExecutor.this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class OpenP2PChannel implements IDropableRunnable, Runnable {
        private long mAge;
        public int scheduleNum;

        private OpenP2PChannel() {
            this.mAge = System.currentTimeMillis();
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (P2PUploadExecutor.this.isResumeProcess()) {
                P2PUploadExecutor.this.mService.postRunnableToDbThread(new SetSentStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_sending)));
                return;
            }
            Log.d(P2PUploadExecutor.TAG, "----P2P Open Channel (datasize=" + String.valueOf(P2PUploadExecutor.this.mDatastreamSize) + ")----");
            CatfishResult p2pOpenChannel = P2PUploadExecutor.this.catfishRestAPI.p2pOpenChannel(P2PUploadExecutor.this.mServer, P2PUploadExecutor.this.mUserpin, P2PUploadExecutor.this.mRecipient, P2PUploadExecutor.this.mStreamType, P2PUploadExecutor.this.mChannelId, P2PUploadExecutor.this.mDatastreamSize, P2PUploadExecutor.this.mFilename, P2PUploadExecutor.this.mSequence);
            Log.d(P2PUploadExecutor.TAG, "cancel upload is " + P2PUploadExecutor.this.mbCancelUpload);
            if (P2PUploadExecutor.this.mbCancelUpload) {
                LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).unregisterReceiver(P2PUploadExecutor.this.mCancelUploadReceiver);
                Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, P2PUploadExecutor.this.mSequence);
                LocalBroadcastManager.getInstance(P2PUploadExecutor.this.mService).sendBroadcast(intent);
                p2pOpenChannel.cleaningup();
                if (P2PUploadExecutor.this.mCacheFile != null) {
                    switch (P2PUploadExecutor.this.mStreamType) {
                        case e.b /*1*/:
                            if (P2PUploadExecutor.this.mCacheFile.exists()) {
                                P2PUploadExecutor.this.mCacheFile.delete();
                                break;
                            }
                            break;
                    }
                }
                P2PUploadExecutor.this.mService.postRunnableToDbThread(new UpdateSendMessageStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_send_fail)));
            } else if (p2pOpenChannel.hasSuccess()) {
                Log.d(P2PUploadExecutor.TAG, "----P2P Open Channel: SUCCESS: UPLOAD...");
                P2PUploadExecutor.this.mService.postRunnableToDbThread(new SetSentStatusToDB(P2PUploadExecutor.this.mService.getResources().getString(R.string.user_sending)));
                p2pOpenChannel.cleaningup();
            } else if (p2pOpenChannel.hasFailure()) {
                Log.d(P2PUploadExecutor.TAG, "----P2P Open Channel: FAIL: Re schedule !!!");
                P2PUploadExecutor.this.mServer = CatfishService.getServerHost();
                P2PUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                p2pOpenChannel.cleaningup();
            } else {
                Log.d(P2PUploadExecutor.TAG, "----P2P Open Channel: ERROR: DROP !!!");
                p2pOpenChannel.cleaningup();
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            P2PUploadExecutor.this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public class SetSentStatusToDB implements Runnable {
        String mMessageText;

        public SetSentStatusToDB(String str) {
            this.mMessageText = str;
        }

        public void run() {
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(P2PUploadExecutor.this.mService);
            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(P2PUploadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            obtain.userpin = P2PUploadExecutor.this.mUserpin;
            obtain.recipient = P2PUploadExecutor.this.mRecipient;
            obtain.rcvtimestamp = P2PUploadExecutor.this.mSequence;
            obtain.sequence = P2PUploadExecutor.this.mSequence;
            obtain.deliverystatus = MessageDeliveryStatus.SENT;
            obtain.message = P2PUploadExecutor.this.mDataFile.getName() + " " + this.mMessageText;
            switch (P2PUploadExecutor.this.mStreamType) {
                case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                    obtain.message = this.mMessageText;
                    break;
                case HttpRouteDirector.TUNNEL_PROXY /*4*/:
                    obtain.message = this.mMessageText;
                    break;
                case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                    obtain.message = P2PUploadExecutor.this.mLongMessagePreview;
                    break;
                default:
                    obtain.message = P2PUploadExecutor.this.mDataFile.getName() + " " + this.mMessageText;
                    break;
            }
            if (!catfishDataStorage.updateSendFileMessageStatus(obtain)) {
                Log.e(P2PUploadExecutor.TAG, "Error: Writing User message to DB FAIL !!!");
            }
            friendListDataStorage.setFriendLastActivity(P2PUploadExecutor.this.mRecipient, obtain.rcvtimestamp);
            friendListDataStorage.updateActivityCount(P2PUploadExecutor.this.mRecipient, 600);
            friendListDataStorage.updateLastChatActivity(P2PUploadExecutor.this.mRecipient, obtain.rcvtimestamp);
            obtain.recycle();
            P2PUploadExecutor.this.mService.signalUploadStartSending();
            P2PUploadExecutor.this.mService.postToServiceHandler(new BlockUploader(), 2);
        }
    }

    public class UpdateSendMessageStatusToDB implements Runnable {
        String mMessageText;

        public UpdateSendMessageStatusToDB(String str) {
            this.mMessageText = str;
        }

        public void run() {
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(P2PUploadExecutor.this.mService);
            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(P2PUploadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            obtain.userpin = P2PUploadExecutor.this.mUserpin;
            obtain.recipient = P2PUploadExecutor.this.mRecipient;
            obtain.rcvtimestamp = P2PUploadExecutor.this.mSequence;
            obtain.sequence = P2PUploadExecutor.this.mSequence;
            obtain.message = P2PUploadExecutor.this.mDataFile.getName() + " " + this.mMessageText;
            switch (P2PUploadExecutor.this.mStreamType) {
                case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                    obtain.message = "Video Chat " + this.mMessageText;
                    break;
                case HttpRouteDirector.TUNNEL_PROXY /*4*/:
                    obtain.message = this.mMessageText;
                    break;
                case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                    obtain.message = P2PUploadExecutor.this.mLongMessagePreview;
                    break;
                default:
                    obtain.message = P2PUploadExecutor.this.mDataFile.getName() + " " + this.mMessageText;
                    break;
            }
            if (!catfishDataStorage.updateSendFileMessageStatus(obtain)) {
                Log.e(P2PUploadExecutor.TAG, "Error: Writing User message to DB FAIL !!!");
            }
            friendListDataStorage.setFriendLastActivity(P2PUploadExecutor.this.mRecipient, obtain.rcvtimestamp);
            friendListDataStorage.updateActivityCount(P2PUploadExecutor.this.mRecipient, 600);
            friendListDataStorage.updateLastChatActivity(P2PUploadExecutor.this.mRecipient, obtain.rcvtimestamp);
            Log.d(P2PUploadExecutor.TAG, "sent:" + obtain.message);
            obtain.recycle();
            P2PUploadExecutor.this.mService.signalUploadStartSending();
        }
    }

    public P2PUploadExecutor(CatfishService catfishService, String str, String str2, String str3, int i, File file) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mRecipient = str3;
        this.mStreamType = i;
        try {
            this.mFilename = file.getName().toLowerCase(Locale.US);
            this.mDataFile = file;
        } catch (Exception e) {
            this.mFilename = null;
            this.mDataFile = null;
        }
        if (this.mChannelId == 0) {
            this.mChannelId = CatfishRESTAPI.uniqueMonotonicSequence();
        }
        if (this.mSequence == 0) {
            this.mSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        }
        if (this.mStreamType != 6) {
            Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
            intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
            LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        }
        Log.d(TAG, "register the cancel chat upload");
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelUploadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_CHAT_UPLOAD));
    }

    public P2PUploadExecutor(CatfishService catfishService, String str, String str2, String str3, int i, File file, boolean z) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mRecipient = str3;
        this.mStreamType = i;
        this.mTransparentFormat = z;
        try {
            this.mFilename = file.getName().toLowerCase(Locale.US);
            this.mDataFile = file;
        } catch (Exception e) {
            this.mFilename = null;
            this.mDataFile = null;
        }
        if (this.mChannelId == 0) {
            this.mChannelId = CatfishRESTAPI.uniqueMonotonicSequence();
        }
        if (this.mSequence == 0) {
            this.mSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        }
        if (this.mStreamType != 6) {
            Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
            intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
            LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        }
        Log.d(TAG, "register the cancel chat upload");
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelUploadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_CHAT_UPLOAD));
    }

    public P2PUploadExecutor(CatfishService catfishService, String str, String str2, String str3, long j, int i, String str4, File file) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mRecipient = str3;
        this.mStreamType = i;
        this.mLongMessagePreview = str4;
        try {
            this.mFilename = file.getName().toLowerCase(Locale.US);
            this.mDataFile = file;
        } catch (Exception e) {
            this.mFilename = null;
            this.mDataFile = null;
        }
        if (this.mChannelId == 0) {
            this.mChannelId = CatfishRESTAPI.uniqueMonotonicSequence();
        }
        this.mSequence = j;
        if (this.mStreamType != 6) {
            Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
            intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
            LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        }
        Log.d(TAG, "register the cancel chat upload");
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelUploadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_CHAT_UPLOAD));
    }

    private void fillMessage(CatfishMessageObject catfishMessageObject) {
        if (this.mMessage != null) {
            this.mMessage.recycle();
        }
        this.mMessage = CatfishMessageObject.obtain();
        this.mMessage.senderpin = catfishMessageObject.userpin;
        this.mMessage.sendername = catfishMessageObject.username;
        this.mMessage.conversation_key = catfishMessageObject.userpin + ":" + catfishMessageObject.recipient;
        this.mMessage.imagethumb_uri = catfishMessageObject.imagethumb_uri;
        this.mMessage.image_path = catfishMessageObject.image_path;
        this.mMessage.sequence = catfishMessageObject.sequence;
        this.mMessage.voicefilepath = catfishMessageObject.voicefilepath;
        this.mMessage.datafile_path = catfishMessageObject.datafile_path;
        this.mMessage.message = "";
        this.mMessage.messagetype = catfishMessageObject.messagetype;
        this.mMessage.rcvtimestamp = catfishMessageObject.rcvtimestamp;
    }

    private Bitmap rescaleBitmap() {
        int i = 1;
        Options options = new Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(this.mDataFile.getAbsolutePath(), options);
        int i2 = options.outWidth;
        int i3 = options.outHeight;
        while (i2 / 2 >= 240 && i3 / 2 >= 240) {
            i2 /= 2;
            i3 /= 2;
            i *= 2;
        }
        options = new Options();
        options.inSampleSize = i;
        options.inJustDecodeBounds = false;
        options.inPreferredConfig = Config.ARGB_8888;
        return BitmapFactory.decodeFile(this.mDataFile.getAbsolutePath(), options);
    }

    private void sendBroadcastIntent(CatfishMessageObject catfishMessageObject) {
        Log.d(TAG, "sendBroadcastIntent:" + this.mLongMessagePreview);
        if (catfishMessageObject == null || catfishMessageObject.message == null || this.mLongMessagePreview == null || this.mLongMessagePreview.isEmpty()) {
            Intent intent = new Intent();
            intent.putExtra(TaskDataStorage.SENDERPIN, catfishMessageObject.senderpin);
            intent.putExtra(ServerMessageDataStorage.SENDERNAME, catfishMessageObject.sendername);
            intent.putExtra("conversation_key", catfishMessageObject.conversation_key);
            intent.putExtra("image_path", catfishMessageObject.image_path);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, catfishMessageObject.sequence);
            intent.putExtra("imagethumb_uri", catfishMessageObject.imagethumb_uri);
            intent.putExtra(ServerMessageDataStorage.VOICEFILEPATH, catfishMessageObject.voicefilepath);
            intent.putExtra("datafile_path", catfishMessageObject.datafile_path);
            intent.putExtra(ServerMessageDataStorage.MESSAGE, catfishMessageObject.message);
            intent.putExtra(TaskDataStorage.MESSAGETYPE, catfishMessageObject.messagetype.ordinal());
            intent.putExtra("rcvtimestamp", catfishMessageObject.rcvtimestamp);
            intent.putExtra("object_owner", catfishMessageObject.object_owner);
            intent.putExtra("object_sequence", catfishMessageObject.object_sequence);
            intent.setAction(BroadcastIntents.ACTION_CHAT_MEDIA);
            this.mService.sendBroadcast(intent);
            Log.d(TAG, "convkey : " + catfishMessageObject.conversation_key);
            Log.e(TAG, "SEND BROADCAST MEDIA FROM CHAT : P2P");
        }
    }

    public void dropRunnable() {
        if (this.mCacheFile != null && this.mCacheFile.exists()) {
            this.mCacheFile.delete();
        }
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        if (isResumeProcess()) {
            this.mByteStart = getResumeUploadData().mBytestart;
            this.mByteEnd = this.mByteStart + mChunkMaxSize;
            this.mSequence = Long.parseLong(getResumeUploadData().mKey);
            this.mChannelId = Long.parseLong(getResumeUploadData().mChannelID);
            this.mChunkOffset = getResumeUploadData().mChunkOffset;
        }
        if (this.mFilename == null || this.mDataFile == null) {
            Log.d(TAG, "ERROR: P2P With NULL File: DROP");
        } else if (this.mStreamType == 1) {
            ImageThumbnailer anonymousClass1 = new ImageThumbnailer(this.mService, CatfishService.getUserPIN(), this.mStreamType) {
                protected void onPostExecute(Uri uri) {
                    if (uri != null) {
                        P2PUploadExecutor.this.mImagethumuri = uri.toString();
                        Log.d(P2PUploadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                        try {
                            P2PUploadExecutor.this.mCacheFile = CatfishPhotoStorage.getCacheFile(P2PUploadExecutor.this.mService, P2PUploadExecutor.this.mFilename);
                            if (P2PUploadExecutor.this.mCacheFile != null) {
                                OutputStream fileOutputStream = new FileOutputStream(P2PUploadExecutor.this.mCacheFile);
                                Bitmap access$400 = P2PUploadExecutor.this.rescaleBitmap();
                                if (access$400 == null) {
                                    try {
                                        fileOutputStream.close();
                                        return;
                                    } catch (IOException e) {
                                        return;
                                    }
                                }
                                if (P2PUploadExecutor.this.mTransparentFormat) {
                                    access$400.compress(CompressFormat.PNG, 60, fileOutputStream);
                                } else {
                                    access$400.compress(CompressFormat.JPEG, 60, fileOutputStream);
                                }
                                try {
                                    fileOutputStream.flush();
                                    fileOutputStream.close();
                                } catch (IOException e2) {
                                }
                                P2PUploadExecutor.this.mDatastreamSize = Long.valueOf(P2PUploadExecutor.this.mCacheFile.length()).intValue();
                                P2PUploadExecutor.this.mDatastream = new FileInputStream(P2PUploadExecutor.this.mCacheFile);
                                P2PUploadExecutor.this.mChunkbuffer = new byte[P2PUploadExecutor.mChunkMaxSize];
                                if (P2PUploadExecutor.this.isResumeProcess()) {
                                    P2PUploadExecutor.this.mDatastream.skip((long) P2PUploadExecutor.this.mByteStart);
                                }
                                P2PUploadExecutor.this.mService.postRunnableToDbThread(new AddPrepareStatusToDB());
                                return;
                            }
                            return;
                        } catch (FileNotFoundException e3) {
                            Log.d(P2PUploadExecutor.TAG, "----P2P DATA FILE: " + e3.toString());
                            P2PUploadExecutor.this.mDatastream = null;
                            if (P2PUploadExecutor.this.mCacheFile != null && P2PUploadExecutor.this.mCacheFile.exists()) {
                                P2PUploadExecutor.this.mCacheFile.delete();
                                return;
                            }
                            return;
                        } catch (Exception e4) {
                            e4.printStackTrace();
                            P2PUploadExecutor.this.mDatastream = null;
                            if (P2PUploadExecutor.this.mCacheFile != null && P2PUploadExecutor.this.mCacheFile.exists()) {
                                P2PUploadExecutor.this.mCacheFile.delete();
                                return;
                            }
                            return;
                        }
                    }
                    Log.d(P2PUploadExecutor.TAG, "Thumbnail FAIL to create");
                }
            };
            Log.d(TAG, "uri" + Uri.fromFile(this.mDataFile));
            anonymousClass1.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
        } else if (this.mStreamType == 4) {
            this.mService.postRunnableToDbThread(new AddPrepareStatusToDB());
            this.mCacheFile = new File(this.mDataFile.getAbsolutePath());
            this.mDatastreamSize = Long.valueOf(this.mCacheFile.length()).intValue();
            this.mFilename = "r" + this.mFilename;
            try {
                this.mDatastream = new FileInputStream(this.mCacheFile);
                this.mChunkbuffer = new byte[mChunkMaxSize];
            } catch (FileNotFoundException e) {
                Log.d(TAG, "----P2P DATA FILE: " + e.toString());
                this.mDatastream = null;
            }
        } else if (this.mStreamType == 6) {
            this.mService.postRunnableToDbThread(new AddPrepareStatusToDB());
            this.mCacheFile = new File(this.mDataFile.getAbsolutePath());
            this.mDatastreamSize = Long.valueOf(this.mCacheFile.length()).intValue();
            try {
                this.mDatastream = new FileInputStream(this.mCacheFile);
                this.mChunkbuffer = new byte[mChunkMaxSize];
            } catch (FileNotFoundException e2) {
                Log.d(TAG, "----P2P DATA FILE: " + e2.toString());
                this.mDatastream = null;
            }
        } else if (this.mStreamType == 5 || this.mStreamType == 3) {
            String name = this.mDataFile.getName();
            Log.d(TAG, "url :" + name);
            if (Utils.getFileTypeFromPath(name) == 1) {
                new ImageThumbnailer(this.mService, CatfishService.getUserPIN(), this.mStreamType) {
                    protected void onPostExecute(Uri uri) {
                        if (uri != null) {
                            P2PUploadExecutor.this.mImagethumuri = uri.toString();
                            Log.d(P2PUploadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                        } else {
                            P2PUploadExecutor.this.mImagethumuri = null;
                            Log.d(P2PUploadExecutor.TAG, "Thumbnail FAIL to create");
                        }
                        P2PUploadExecutor.this.mService.postRunnableToDbThread(new AddPrepareStatusToDB());
                        P2PUploadExecutor.this.mCacheFile = new File(P2PUploadExecutor.this.mDataFile.getAbsolutePath());
                        P2PUploadExecutor.this.mDatastreamSize = Long.valueOf(P2PUploadExecutor.this.mCacheFile.length()).intValue();
                        try {
                            P2PUploadExecutor.this.mDatastream = new FileInputStream(P2PUploadExecutor.this.mCacheFile);
                            P2PUploadExecutor.this.mChunkbuffer = new byte[P2PUploadExecutor.mChunkMaxSize];
                            if (P2PUploadExecutor.this.isResumeProcess()) {
                                P2PUploadExecutor.this.mDatastream.skip((long) P2PUploadExecutor.this.mByteStart);
                            }
                        } catch (IOException e) {
                            Log.d(P2PUploadExecutor.TAG, "----P2P DATA FILE: " + e.toString());
                            P2PUploadExecutor.this.mDatastream = null;
                        }
                    }
                }.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
            } else if (Utils.getFileTypeFromPath(name) == 6) {
                Log.d(TAG, "video lewat data masuk ga");
                new ImageThumbnailer(this.mService, CatfishService.getUserPIN(), this.mStreamType, true, this.mDataFile.getAbsolutePath()) {
                    protected void onPostExecute(Uri uri) {
                        if (uri != null) {
                            P2PUploadExecutor.this.mImagethumuri = uri.toString();
                            Log.d(P2PUploadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                        } else {
                            P2PUploadExecutor.this.mImagethumuri = null;
                            Log.d(P2PUploadExecutor.TAG, "Thumbnail FAIL to create because 3gp are not always video");
                        }
                        P2PUploadExecutor.this.mService.postRunnableToDbThread(new AddPrepareStatusToDB());
                        P2PUploadExecutor.this.mCacheFile = new File(P2PUploadExecutor.this.mDataFile.getAbsolutePath());
                        P2PUploadExecutor.this.mDatastreamSize = Long.valueOf(P2PUploadExecutor.this.mCacheFile.length()).intValue();
                        try {
                            P2PUploadExecutor.this.mDatastream = new FileInputStream(P2PUploadExecutor.this.mCacheFile);
                            P2PUploadExecutor.this.mChunkbuffer = new byte[P2PUploadExecutor.mChunkMaxSize];
                            if (P2PUploadExecutor.this.isResumeProcess()) {
                                Log.d(P2PUploadExecutor.TAG, "---- SKIP BYTESTART : " + P2PUploadExecutor.this.mByteStart);
                                P2PUploadExecutor.this.mDatastream.skip((long) P2PUploadExecutor.this.mByteStart);
                            }
                        } catch (IOException e) {
                            Log.d(P2PUploadExecutor.TAG, "----P2P DATA FILE: " + e.toString());
                            P2PUploadExecutor.this.mDatastream = null;
                        }
                    }
                }.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
            } else {
                this.mService.postRunnableToDbThread(new AddPrepareStatusToDB());
                this.mCacheFile = new File(this.mDataFile.getAbsolutePath());
                this.mDatastreamSize = Long.valueOf(this.mCacheFile.length()).intValue();
                try {
                    this.mDatastream = new FileInputStream(this.mCacheFile);
                    this.mChunkbuffer = new byte[mChunkMaxSize];
                    if (isResumeProcess()) {
                        this.mDatastream.skip((long) this.mByteStart);
                    }
                } catch (IOException e3) {
                    Log.d(TAG, "----P2P DATA FILE: " + e3.toString());
                    this.mDatastream = null;
                }
            }
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

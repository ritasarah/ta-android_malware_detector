package com.catfiz.service;

import android.os.Environment;
import android.util.SparseArray;
import com.catfiz.util.Log;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import org.apache.http.protocol.HTTP;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class LongMessageExecutor {
    public static final int LONG_MESSAGE_CHAR_PREVIEW = 210;
    private static final String TAG = "LongMessageExecutor";
    public static final String mParentPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ);
    byte[] autf8bytes = null;
    private int charthreshold = 900;
    private int mBlockNum = 0;
    private String mMessage = null;
    private long mSequence = 0;
    private int mTotalBlock = 0;

    public LongMessageExecutor(String str, long j) {
        Log.d(TAG, "LongMessageExecutor:" + j);
        this.mMessage = str;
        this.mSequence = j;
        try {
            this.autf8bytes = this.mMessage.getBytes(HTTP.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e(TAG, "UNSUPORTED ENCODING: SEE LOG!!!");
            e.printStackTrace();
        }
        if (this.mMessage != null) {
            this.mTotalBlock = this.autf8bytes.length / this.charthreshold;
            if (this.autf8bytes.length / this.charthreshold != 0) {
                this.mTotalBlock++;
            }
        }
    }

    public static void deleteLongMessage(long j) {
        File file = new File(mParentPath + "/text/" + String.valueOf(j));
        if (file.exists()) {
            file.delete();
        }
    }

    public static byte[] getBytesFromFile(File file) {
        InputStream fileInputStream = new FileInputStream(file);
        byte[] bArr = new byte[((int) file.length())];
        int i = 0;
        while (i < bArr.length) {
            int read = fileInputStream.read(bArr, i, bArr.length - i);
            if (read < 0) {
                break;
            }
            i += read;
        }
        if (i < bArr.length) {
            throw new IOException("Could not completely read file " + file.getName());
        }
        fileInputStream.close();
        return bArr;
    }

    public static String getLongMessage(long j) {
        String str;
        FileNotFoundException e;
        IOException e2;
        try {
            BufferedReader bufferedReader = new BufferedReader(new FileReader(getTextDirPath() + String.valueOf(j)));
            str = null;
            while (true) {
                try {
                    String readLine = bufferedReader.readLine();
                    if (readLine == null) {
                        break;
                    }
                    str = str == null ? readLine : str + "\n" + readLine;
                } catch (FileNotFoundException e3) {
                    e = e3;
                } catch (IOException e4) {
                    e2 = e4;
                }
            }
            bufferedReader.close();
        } catch (FileNotFoundException e5) {
            FileNotFoundException fileNotFoundException = e5;
            str = null;
            e = fileNotFoundException;
            e.printStackTrace();
            return str;
        } catch (IOException e6) {
            IOException iOException = e6;
            str = null;
            e2 = iOException;
            e2.printStackTrace();
            return str;
        }
        return str;
    }

    public static String getTextDirPath() {
        new File(mParentPath + "/text/").mkdirs();
        return mParentPath + "/text/";
    }

    private String readMessageBlockFile(String str, int i) {
        if (!new File(getTextDirPath() + str + "." + i).exists()) {
            return "";
        }
        String str2 = new String(getBytesFromFile(new File(getTextDirPath() + str + "." + i)), HTTP.UTF_8);
        new File(getTextDirPath() + str + "." + i).delete();
        return str2;
    }

    private void saveToMessageBlockFile(String str, String str2, int i) {
        FileOutputStream fileOutputStream = new FileOutputStream(getTextDirPath() + str2 + "." + i);
        fileOutputStream.write(str.getBytes(HTTP.UTF_8));
        fileOutputStream.flush();
        fileOutputStream.close();
    }

    public String concateJSONMessage(String str) {
        try {
            String readLine;
            String str2;
            JSONObject jSONObject = new JSONObject(str);
            String string = jSONObject.getString(ServerMessageDataStorage.SEQUENCE);
            if (new File(getTextDirPath() + string).exists()) {
                BufferedReader bufferedReader = new BufferedReader(new FileReader(getTextDirPath() + string));
                readLine = bufferedReader.readLine();
                bufferedReader.close();
            } else {
                readLine = null;
            }
            JSONObject jSONObject2 = new JSONObject();
            JSONArray jSONArray = new JSONArray();
            BufferedWriter bufferedWriter;
            if (readLine != null) {
                int i;
                JSONArray jSONArray2 = new JSONArray(readLine);
                int length = jSONArray2.length();
                for (i = 0; i < length; i++) {
                    if (jSONArray2.getJSONObject(i).getInt("block") == jSONObject.getInt("block")) {
                        return null;
                    }
                    jSONArray.put(jSONArray2.getJSONObject(i));
                }
                i = jSONObject.getInt("block");
                saveToMessageBlockFile(jSONObject.getString(ServerMessageDataStorage.MESSAGE), string, i);
                jSONObject2.put("block_count", jSONObject.getInt("block_count"));
                jSONObject2.put("block", i);
                jSONArray.put(jSONObject2);
                if (jSONArray.length() == jSONObject.getInt("block_count")) {
                    int length2 = jSONArray.length();
                    str2 = null;
                    for (i = 0; i < length2; i++) {
                        str2 = str2 == null ? readMessageBlockFile(string, i + 1) : str2 + readMessageBlockFile(string, i + 1);
                    }
                    FileOutputStream fileOutputStream = new FileOutputStream(getTextDirPath() + string);
                    fileOutputStream.write(str2.getBytes(HTTP.UTF_8));
                    fileOutputStream.flush();
                    fileOutputStream.close();
                    str2 = getTextDirPath() + string;
                } else {
                    bufferedWriter = new BufferedWriter(new FileWriter(new File(getTextDirPath() + string), false));
                    bufferedWriter.append(jSONArray.toString());
                    bufferedWriter.newLine();
                    bufferedWriter.flush();
                    bufferedWriter.close();
                    str2 = null;
                }
            } else {
                int i2 = jSONObject.getInt("block");
                saveToMessageBlockFile(jSONObject.getString(ServerMessageDataStorage.MESSAGE), string, i2);
                jSONObject2.put("block_count", jSONObject.getString("block_count"));
                jSONObject2.put("block", i2);
                jSONArray.put(jSONObject2);
                bufferedWriter = new BufferedWriter(new FileWriter(new File(getTextDirPath() + string), false));
                bufferedWriter.append(jSONArray.toString());
                bufferedWriter.newLine();
                bufferedWriter.flush();
                bufferedWriter.close();
                str2 = null;
            }
            return str2;
        } catch (JSONException e) {
            Log.d(TAG, e.getMessage());
            e.printStackTrace();
            return null;
        } catch (FileNotFoundException e2) {
            Log.d(TAG, e2.getMessage());
            e2.printStackTrace();
            return null;
        } catch (IOException e3) {
            Log.d(TAG, e3.getMessage());
            e3.printStackTrace();
            return null;
        }
    }

    public String concateJSONMessage_(String str) {
        CharSequence charSequence;
        JSONException jSONException;
        FileNotFoundException fileNotFoundException;
        IOException iOException;
        String str2 = null;
        int i = 0;
        try {
            String readLine;
            JSONObject jSONObject = new JSONObject(str);
            String string = jSONObject.getString(ServerMessageDataStorage.SEQUENCE);
            if (new File(getTextDirPath() + string).exists()) {
                BufferedReader bufferedReader = new BufferedReader(new FileReader(getTextDirPath() + string));
                readLine = bufferedReader.readLine();
                bufferedReader.close();
            } else {
                readLine = null;
            }
            JSONObject jSONObject2 = new JSONObject();
            JSONArray jSONArray = new JSONArray();
            BufferedWriter bufferedWriter;
            if (readLine != null) {
                int i2;
                JSONArray jSONArray2 = new JSONArray(readLine);
                int length = jSONArray2.length();
                for (i2 = 0; i2 < length; i2++) {
                    if (jSONArray2.getJSONObject(i2).getInt("block") == jSONObject.getInt("block")) {
                        return null;
                    }
                    jSONArray.put(jSONArray2.getJSONObject(i2));
                }
                jSONObject2.put(ServerMessageDataStorage.MESSAGE, jSONObject.getString(ServerMessageDataStorage.MESSAGE));
                jSONObject2.put("block_count", jSONObject.getInt("block_count"));
                jSONObject2.put("block", jSONObject.getInt("block"));
                jSONArray.put(jSONObject2);
                if (jSONArray.length() == jSONObject.getInt("block_count")) {
                    SparseArray sparseArray = new SparseArray();
                    i2 = jSONArray.length();
                    while (i < i2) {
                        Log.d(TAG, "put = " + jSONArray.getJSONObject(i).getString(ServerMessageDataStorage.MESSAGE));
                        sparseArray.put(jSONArray.getJSONObject(i).getInt("block"), jSONArray.getJSONObject(i).getString(ServerMessageDataStorage.MESSAGE));
                        i++;
                    }
                    int size = sparseArray.size();
                    i2 = 1;
                    CharSequence charSequence2 = null;
                    while (i2 <= size) {
                        try {
                            Log.d(TAG, "write = " + ((String) sparseArray.get(i2)));
                            str2 = charSequence2 == null ? (String) sparseArray.get(i2) : charSequence2 + ((String) sparseArray.get(i2));
                            i2++;
                            Object obj = str2;
                        } catch (JSONException e) {
                            JSONException jSONException2 = e;
                            charSequence = charSequence2;
                            jSONException = jSONException2;
                        } catch (FileNotFoundException e2) {
                            FileNotFoundException fileNotFoundException2 = e2;
                            charSequence = charSequence2;
                            fileNotFoundException = fileNotFoundException2;
                        } catch (IOException e3) {
                            IOException iOException2 = e3;
                            charSequence = charSequence2;
                            iOException = iOException2;
                        }
                    }
                    bufferedWriter = new BufferedWriter(new FileWriter(new File(getTextDirPath() + string), false));
                    bufferedWriter.append(charSequence2);
                    bufferedWriter.newLine();
                    bufferedWriter.flush();
                    bufferedWriter.close();
                    new File(getTextDirPath() + string).delete();
                    return charSequence2;
                }
                bufferedWriter = new BufferedWriter(new FileWriter(new File(getTextDirPath() + string), false));
                bufferedWriter.append(jSONArray.toString());
                bufferedWriter.newLine();
                bufferedWriter.flush();
                bufferedWriter.close();
                return null;
            }
            jSONObject2.put(ServerMessageDataStorage.MESSAGE, jSONObject.getString(ServerMessageDataStorage.MESSAGE));
            jSONObject2.put("block_count", jSONObject.getString("block_count"));
            jSONObject2.put("block", jSONObject.getString("block"));
            jSONArray.put(jSONObject2);
            bufferedWriter = new BufferedWriter(new FileWriter(new File(getTextDirPath() + string), false));
            bufferedWriter.append(jSONArray.toString());
            bufferedWriter.newLine();
            bufferedWriter.flush();
            bufferedWriter.close();
            return null;
        } catch (JSONException e4) {
            jSONException = e4;
            Log.d(TAG, jSONException.getMessage());
            jSONException.printStackTrace();
            return str2;
        } catch (FileNotFoundException e5) {
            fileNotFoundException = e5;
            Log.d(TAG, fileNotFoundException.getMessage());
            fileNotFoundException.printStackTrace();
            return str2;
        } catch (IOException e6) {
            iOException = e6;
            Log.d(TAG, iOException.getMessage());
            iOException.printStackTrace();
            return str2;
        }
    }

    public ArrayList createJSONMessage() {
        ArrayList arrayList = new ArrayList();
        saveSentLongMessageToFile();
        for (int i = 0; i < this.mTotalBlock; i++) {
            int i2 = i * this.charthreshold;
            int length = i + 1 == this.mTotalBlock ? this.autf8bytes.length : this.charthreshold + i2;
            byte[] bArr = new byte[(length - i2)];
            int i3 = 0;
            while (i2 < length) {
                bArr[i3] = this.autf8bytes[i2];
                i3++;
                i2++;
            }
            JSONObject jSONObject = new JSONObject();
            try {
                jSONObject.put(ServerMessageDataStorage.SEQUENCE, this.mSequence);
                jSONObject.put("block", i + 1);
                jSONObject.put("block_count", this.mTotalBlock);
                try {
                    jSONObject.put(ServerMessageDataStorage.MESSAGE, new String(bArr, HTTP.UTF_8));
                } catch (UnsupportedEncodingException e) {
                    jSONObject.put(ServerMessageDataStorage.MESSAGE, new String(bArr));
                    e.printStackTrace();
                }
                arrayList.add(jSONObject.toString());
            } catch (JSONException e2) {
                e2.printStackTrace();
            }
        }
        return arrayList;
    }

    public ArrayList createJSONMessageByte() {
        ArrayList arrayList = new ArrayList();
        saveSentLongMessageToFile();
        for (int i = 0; i < this.mTotalBlock; i++) {
            int i2 = i * this.charthreshold;
            int length = i + 1 == this.mTotalBlock ? this.autf8bytes.length : this.charthreshold + i2;
            byte[] bArr = new byte[(length - i2)];
            int i3 = 0;
            while (i2 < length) {
                bArr[i3] = this.autf8bytes[i2];
                i3++;
                i2++;
            }
            JSONObject jSONObject = new JSONObject();
            try {
                jSONObject.put(ServerMessageDataStorage.SEQUENCE, this.mSequence);
                jSONObject.put("block", i + 1);
                jSONObject.put("block_count", this.mTotalBlock);
                jSONObject.put(ServerMessageDataStorage.MESSAGE, new String(bArr, HTTP.UTF_8));
                arrayList.add(jSONObject.toString().getBytes(HTTP.UTF_8));
            } catch (JSONException e) {
                e.printStackTrace();
            } catch (UnsupportedEncodingException e2) {
                e2.printStackTrace();
            }
        }
        return arrayList;
    }

    public String saveSentLongMessageToFile() {
        try {
            FileOutputStream fileOutputStream = new FileOutputStream(getTextDirPath() + this.mSequence);
            fileOutputStream.write(this.mMessage.getBytes(HTTP.UTF_8));
            fileOutputStream.flush();
            fileOutputStream.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e2) {
            e2.printStackTrace();
        }
        return getTextDirPath() + this.mSequence;
    }
}

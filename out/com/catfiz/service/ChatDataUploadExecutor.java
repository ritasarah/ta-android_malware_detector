package com.catfiz.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.Bitmap.Config;
import android.graphics.BitmapFactory;
import android.graphics.BitmapFactory.Options;
import android.net.Uri;
import android.support.v4.content.LocalBroadcastManager;
import android.webkit.MimeTypeMap;
import android.widget.Toast;
import com.albus.util.AlbusModelObject;
import com.catfiz.R;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.localstorage.ChunkStorage;
import com.catfiz.media.CatfishPhotoStorage;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.pool.PoolDataStorage;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.service.CatfishUIBinder.DatabaseRequestOP;
import com.catfiz.service.uisvcexec.GetStreamThumbnailExecutor;
import com.catfiz.svcpersistent.DataStorageDownloadInfo.DataStorageStreamType;
import com.catfiz.svcpersistent.DataStorageUploadBase;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.FizzlinkUtil;
import com.catfiz.util.Log;
import com.catfiz.util.MimeTypeParser;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Locale;
import org.apache.http.HttpStatus;
import org.json.JSONException;
import org.json.JSONObject;

public class ChatDataUploadExecutor extends DataStorageUploadBase implements Runnable {
    private static final String LONG_MESSAGE = "_longmessage_";
    private static final String TAG = "ChatDataUploadExecutor";
    public static final int mChunkMaxSize = 262144;
    public boolean bNeedRead = true;
    private boolean cancelUpload = false;
    public int mBytestart = 0;
    private File mCacheFile = null;
    private BroadcastReceiver mCancelUploadReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            long longExtra = intent.getLongExtra(ServerMessageDataStorage.SEQUENCE, 0);
            if (longExtra == 0) {
                Log.d(ChatDataUploadExecutor.TAG, "INVALID SEQUENCE: DO NOT CANCEL");
            } else if (ChatDataUploadExecutor.this.mSequence == 0 || ChatDataUploadExecutor.this.mSequence != longExtra) {
                Log.d(ChatDataUploadExecutor.TAG, "Current Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(ChatDataUploadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + longExtra + " OBJSEQ=" + ChatDataUploadExecutor.this.mObjSequence + " SEQ " + ChatDataUploadExecutor.this.mSequence);
                ChatDataUploadExecutor.this.cancelUpload = true;
            }
        }
    };
    public byte[] mChunkbuffer = null;
    public int mChunksent = 0;
    public int mChunksize = 0;
    public FileInputStream mChunkstream = null;
    private ICatfishClientInterface mClientInterface = null;
    Context mContext = null;
    public String mConvKey;
    public File mDataFile = null;
    private String mDataPath = null;
    public volatile int mDatasize = 0;
    private String mFilename = null;
    private String mImagethumuri = null;
    private String mMessage = null;
    CatfishMessageObject mMessageObject = null;
    private long mObjSequence = 0;
    private volatile String mRecipient = null;
    private volatile long mSequence = 0;
    private volatile long mSequenceThumb = 0;
    private volatile String mServer = null;
    private CatfishService mService = null;
    private ICatfishUIBinder mServiceBinder = null;
    private String mSlink = null;
    private String mTipe = null;
    private volatile String mUserpin = null;

    class ChatDeliveryStatus implements Runnable {
        private MessageDeliveryStatus mDeliveryStatus = MessageDeliveryStatus.UNDEFINED;
        private String mMessage = null;

        public ChatDeliveryStatus(MessageDeliveryStatus messageDeliveryStatus) {
            this.mDeliveryStatus = messageDeliveryStatus;
        }

        public ChatDeliveryStatus(MessageDeliveryStatus messageDeliveryStatus, String str) {
            this.mDeliveryStatus = messageDeliveryStatus;
            this.mMessage = str;
        }

        public void run() {
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(ChatDataUploadExecutor.this.mService);
            ChatDataUploadExecutor.this.mMessageObject.deliverystatus = this.mDeliveryStatus;
            ChatDataUploadExecutor.this.mMessageObject.recipient = ChatDataUploadExecutor.this.mRecipient;
            ChatDataUploadExecutor.this.mMessageObject.userpin = ChatDataUploadExecutor.this.mUserpin;
            ChatDataUploadExecutor.this.mMessageObject.sequence = ChatDataUploadExecutor.this.mSequence;
            if (this.mMessage == null || this.mMessage.length() <= 0) {
                ChatDataUploadExecutor.this.mMessageObject.message = PoolDataStorage.messageWithMetaInfoBuilder("", ChatDataUploadExecutor.this.mDataFile);
            } else {
                ChatDataUploadExecutor.this.mMessageObject.message = PoolDataStorage.messageWithMetaInfoBuilder(this.mMessage, ChatDataUploadExecutor.this.mDataFile);
            }
            if (ChatDataUploadExecutor.this.mSlink != null) {
                ChatDataUploadExecutor.this.mMessageObject.slink = ChatDataUploadExecutor.this.mSlink;
            }
            if (catfishDataStorage.updateMessageSentStatusNMessage(ChatDataUploadExecutor.this.mMessageObject)) {
                Log.e(ChatDataUploadExecutor.TAG, "----DCHATSHARE: UPDATE DELVERY STATUS IN DB");
                ChatDataUploadExecutor.this.mService.postToMainHandler(new InvokeClientCallback(ChatDataUploadExecutor.this.mClientInterface, catfishDataStorage.getChatConversation(ChatDataUploadExecutor.this.mConvKey)));
                return;
            }
            Log.e(ChatDataUploadExecutor.TAG, "----DCHATSHARE: FAIL TO UPDATE DELVERY STATUS IN DB");
        }
    }

    class DataChatUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private volatile long mAge = System.currentTimeMillis();
        private String mMsg = null;
        public int scheduleNum = 0;

        public DataChatUploadChunk(String str) {
            if (ChatDataUploadExecutor.this.mChunksize == 0) {
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.QUEUEING, str));
            }
            this.mMsg = str;
        }

        public void dropRunnable() {
            if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                ChatDataUploadExecutor.this.mCacheFile.delete();
            }
            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
            ChatDataUploadExecutor.this.deleteTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), false);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            JSONObject jSONObject = new JSONObject();
            try {
                jSONObject.put(MimeTypeParser.TAG_TYPE, ChatDataUploadExecutor.this.mTipe);
            } catch (JSONException e) {
                e.printStackTrace();
            }
            ChatDataUploadExecutor.this.updateTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), ChatDataUploadExecutor.this.mDataFile.getAbsolutePath(), ChatDataUploadExecutor.this.mDatasize, ChatDataUploadExecutor.this.mBytestart, DataStorageStreamType.CHAT_DATA.ordinal(), jSONObject.toString(), false);
            if (ChatDataUploadExecutor.this.mChunkstream == null) {
                Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: INVALID CHUNKSTREAM (NULL): CANCELED");
                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                ChatDataUploadExecutor.this.mChunkbuffer = null;
                if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                    ChatDataUploadExecutor.this.mCacheFile.delete();
                }
                ChatDataUploadExecutor.this.deleteTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), false);
                return;
            }
            try {
                if (ChatDataUploadExecutor.this.bNeedRead) {
                    ChatDataUploadExecutor.this.bNeedRead = false;
                    ChatDataUploadExecutor.this.mChunksize = ChatDataUploadExecutor.this.mChunkstream.read(ChatDataUploadExecutor.this.mChunkbuffer, 0, ChatDataUploadExecutor.mChunkMaxSize);
                }
                if (ChatDataUploadExecutor.this.mChunksize <= 0) {
                    Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: SENT COMPLETE-----@@@@");
                    LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                    if (ChatDataUploadExecutor.this.mMessageObject != null) {
                        ChatDataUploadExecutor.this.sendBroadcastIntent(ChatDataUploadExecutor.this.mMessageObject);
                    }
                    Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Post To Notify Recipients");
                    ChatDataUploadExecutor.this.mService.postToServiceHandler(new SetDsName(this.mMsg), 2);
                    try {
                        ChatDataUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e2) {
                    }
                    if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                        ChatDataUploadExecutor.this.mCacheFile.delete();
                    }
                    ChatDataUploadExecutor.this.mChunkbuffer = null;
                    ChatDataUploadExecutor.this.deleteTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), false);
                } else if (ChatDataUploadExecutor.this.cancelUpload) {
                    Log.d(ChatDataUploadExecutor.TAG, "canceling upload is on progress.....");
                    LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                    r0 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                    r0.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                    r0.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
                    r0.putExtra(CatfishService.PROGRESS_STATE, 3);
                    LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(r0);
                    ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                    ChatDataUploadExecutor.this.deleteTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), false);
                } else {
                    CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(ChatDataUploadExecutor.this.mServer, ChatDataUploadExecutor.this.mUserpin, ChatDataUploadExecutor.this.mSequence, ChatDataUploadExecutor.this.mDatasize, ChatDataUploadExecutor.this.mBytestart, ChatDataUploadExecutor.this.mChunksize, ChatDataUploadExecutor.this.mChunkbuffer);
                    if (ChatDataUploadExecutor.this.cancelUpload) {
                        Log.d(ChatDataUploadExecutor.TAG, "canceling upload is on progress.....");
                        LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                        r0 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                        r0.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                        r0.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
                        r0.putExtra(CatfishService.PROGRESS_STATE, 3);
                        LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(r0);
                        ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                        ChatDataUploadExecutor.this.deleteTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), false);
                        return;
                    }
                    if (uploadDataChunk.hasSuccess()) {
                        this.mAge = System.currentTimeMillis();
                        if (uploadDataChunk.byteend == 0) {
                            Log.d(ChatDataUploadExecutor.TAG, "----Byte End is 0: RESEND");
                            ChatDataUploadExecutor.this.bNeedRead = false;
                            this.mAge = System.currentTimeMillis();
                            ChatDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                            return;
                        } else if (ChatDataUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - ChatDataUploadExecutor.this.mBytestart) + 1) {
                            Log.d(ChatDataUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                            ChatDataUploadExecutor.this.mChunkbuffer = null;
                            try {
                                ChatDataUploadExecutor.this.mChunkstream.close();
                            } catch (IOException e3) {
                            }
                            ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                            if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                                ChatDataUploadExecutor.this.mCacheFile.delete();
                            }
                            ChatDataUploadExecutor.this.deleteTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), false);
                            uploadDataChunk.cleaningup();
                            return;
                        } else {
                            Log.d(ChatDataUploadExecutor.TAG, "Chunk Sent: " + String.valueOf(uploadDataChunk.byteend - ChatDataUploadExecutor.this.mBytestart) + " bytes: " + String.valueOf(ChatDataUploadExecutor.this.mBytestart) + "-" + String.valueOf(uploadDataChunk.byteend) + ": SELF RE-POST");
                            ChatDataUploadExecutor chatDataUploadExecutor = ChatDataUploadExecutor.this;
                            chatDataUploadExecutor.mChunksent += (uploadDataChunk.byteend - ChatDataUploadExecutor.this.mBytestart) + 1;
                            ChatDataUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                            int i = (ChatDataUploadExecutor.this.mBytestart * 100) / ChatDataUploadExecutor.this.mDatasize;
                            Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                            intent.putExtra(CatfishService.PROGRESS_VALUE, i);
                            intent.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
                            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(intent);
                            ChatDataUploadExecutor.this.bNeedRead = true;
                            ChatDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        }
                    } else if (uploadDataChunk.hasFailure()) {
                        Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: FAILURE !!!: Re Schedule");
                        ChatDataUploadExecutor.this.bNeedRead = false;
                        ChatDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                        ChatDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    } else {
                        Log.e(ChatDataUploadExecutor.TAG, "----DCHATSHARE: ERROR: DROP");
                        LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                        Intent intent2 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                        intent2.putExtra(CatfishService.PROGRESS_VALUE, 0);
                        intent2.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
                        intent2.putExtra(CatfishService.PROGRESS_STATE, 4);
                        LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(intent2);
                        ChatDataUploadExecutor.this.mChunkbuffer = null;
                        try {
                            ChatDataUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e4) {
                        }
                        ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                        if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                            ChatDataUploadExecutor.this.mCacheFile.delete();
                        }
                        ChatDataUploadExecutor.this.deleteTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), false);
                    }
                    uploadDataChunk.cleaningup();
                }
            } catch (IOException e5) {
                Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: FAIL TO READ STREAM: CANCELED");
                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                ChatDataUploadExecutor.this.mChunkbuffer = null;
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                    ChatDataUploadExecutor.this.mCacheFile.delete();
                }
                ChatDataUploadExecutor.this.deleteTaskState(String.valueOf(ChatDataUploadExecutor.this.mSequence), false);
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class GetSlinkFromServer implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private long mAge = System.currentTimeMillis();
        private boolean mIsSent = false;
        private String mMsg = null;
        public int scheduleNum = 0;
        private boolean send = true;

        public GetSlinkFromServer(String str) {
            this.mMsg = str;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult slink = this.catfishRestAPI.getSlink(ChatDataUploadExecutor.this.mServer, ChatDataUploadExecutor.this.mUserpin, ChatDataUploadExecutor.this.mUserpin, ChatDataUploadExecutor.this.mSequence);
            if (slink.hasSuccess()) {
                ChatDataUploadExecutor.this.mSlink = slink.slink;
                ChatDataUploadExecutor.this.mService.postToServiceHandler(new GetStreamThumbnailExecutor(ChatDataUploadExecutor.this.mService, ChatDataUploadExecutor.this.mSlink), 2);
                CatfishService access$500 = ChatDataUploadExecutor.this.mService;
                CatfishService access$5002 = ChatDataUploadExecutor.this.mService;
                long access$1100 = ChatDataUploadExecutor.this.mSequence;
                ChatDataUploadExecutor.this.mService;
                access$500.postRunnableToService(new SlinkFileInfoExecutor(access$5002, access$1100, CatfishService.getCurrentServerHost(), ChatDataUploadExecutor.this.mSlink, false, false), 2);
                ChatDataUploadExecutor.this.mService.postToServiceHandler(new SendChatToFriend(this.mMsg), 2);
            } else if (slink.hasFailure()) {
                Log.d(ChatDataUploadExecutor.TAG, "----CHAT GET SLINK: FAILURE !!!: Re Schedule");
                ChatDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                ChatDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                r0 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                r0.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                r0.putExtra(CatfishService.PROGRESS_STATE, 4);
                r0.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(r0);
            } else {
                Log.e(ChatDataUploadExecutor.TAG, "----CHAT GET SLINK: ERROR: DROP");
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                r0 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                r0.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                r0.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
                r0.putExtra(CatfishService.PROGRESS_STATE, 4);
                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(r0);
            }
            slink.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class InvokeClientCallback implements Runnable {
        private Cursor mCursor;
        private ICatfishClientInterface mIfClient;

        public InvokeClientCallback(ICatfishClientInterface iCatfishClientInterface, Cursor cursor) {
            this.mCursor = cursor;
            this.mIfClient = iCatfishClientInterface;
        }

        public void run() {
            if (this.mIfClient == null || this.mIfClient.isFinish()) {
                Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: cannot invoke client calback");
                return;
            }
            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: invoke client calback");
            this.mIfClient.onDatabaseResponse(CatfishService.GET_CONVERSATION_KEY, this.mIfClient.transfromDBCursor(DatabaseRequestOP.SEND_CONV_MESSAGE, this.mCursor, 0), 0);
        }
    }

    class SendChatToFriend implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private long mAge = System.currentTimeMillis();
        private String msg = null;
        public int scheduleNum = 0;

        public SendChatToFriend(String str) {
            this.msg = str;
        }

        public void dropRunnable() {
            Log.e(ChatDataUploadExecutor.TAG, "SEND STATUS COMMENT: SEND ERROR: DROP BY SERVICE !!!");
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            String string = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
            JSONObject jSONObject = new JSONObject();
            try {
                File file = new File(ChatDataUploadExecutor.this.mDataPath);
                jSONObject.put(ServerMessageDataStorage.MESSAGE, ChatDataUploadExecutor.this.mMessage);
                jSONObject.put(CatfishDataStorage.NIC_NAME, file.getName().toLowerCase(Locale.US));
                jSONObject.put(ServerMessageDataStorage.SLINK, ChatDataUploadExecutor.this.mSlink);
                if (ChatDataUploadExecutor.this.mTipe.equals(AlbusModelObject.DATA_TYPE_IMAGE)) {
                    jSONObject.put("tipe", AlbusModelObject.IMAGE);
                } else {
                    jSONObject.put("tipe", ChatDataUploadExecutor.this.mTipe);
                }
            } catch (JSONException e) {
                e.printStackTrace();
            }
            Log.d(ChatDataUploadExecutor.TAG, "sender: " + string);
            CatfishRESTAPI catfishRESTAPI = this.catfishRestAPI;
            ChatDataUploadExecutor.this.mService;
            CatfishResult sendMessage = catfishRESTAPI.sendMessage(CatfishService.getCurrentServerHost(), ChatDataUploadExecutor.this.mUserpin, ChatDataUploadExecutor.this.mRecipient, ChatDataUploadExecutor.this.mMessageObject.messagetype.ordinal(), jSONObject.toString(), ChatDataUploadExecutor.this.mSequence);
            if (sendMessage.hasSuccess()) {
                new FriendListDataStorage(ChatDataUploadExecutor.this.mService).setLastMessageStatus(true, ChatDataUploadExecutor.this.mRecipient, MessageDeliveryStatus.SENT.ordinal());
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.SENT, this.msg));
            } else if (sendMessage.hasFailure()) {
                ChatDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                ChatDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(ChatDataUploadExecutor.TAG, "SEND IMAGE STATUS COMMENT: SEND ERROR: DROP !!!");
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
            }
            Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
            intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
            intent.putExtra(CatfishService.PROGRESS_STATE, 2);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(intent);
            sendMessage.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class SetDsName implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private long mAge = System.currentTimeMillis();
        private boolean mIsSent = false;
        private String mMsgsetdsname = null;
        public int scheduleNum = 0;
        private boolean send = true;

        public SetDsName(String str) {
            this.mMsgsetdsname = str;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public String getMimeType(String str) {
            String fileExtensionFromUrl = MimeTypeMap.getFileExtensionFromUrl(str);
            return fileExtensionFromUrl != null ? MimeTypeMap.getSingleton().getMimeTypeFromExtension(fileExtensionFromUrl) : null;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            String safeFileName = Utils.getSafeFileName(ChatDataUploadExecutor.this.mDataFile.getName());
            int fizzlinkTypeFromExtension = FizzlinkUtil.getFizzlinkTypeFromExtension(ChatDataUploadExecutor.this.mDataFile);
            String str = this.mMsgsetdsname;
            JSONObject jSONObject = new JSONObject();
            try {
                File file = new File(ChatDataUploadExecutor.this.mDataPath);
                if (this.mMsgsetdsname != null) {
                    jSONObject.put(AlbusModelObject.INTENT_DESC, this.mMsgsetdsname);
                } else {
                    jSONObject.put(AlbusModelObject.INTENT_DESC, "");
                }
                jSONObject.put("objsequencethumb", ChatDataUploadExecutor.this.mSequenceThumb);
                Log.d(ChatDataUploadExecutor.TAG, "!@@@ objsequencethumb:" + ChatDataUploadExecutor.this.mSequenceThumb + " ownerpin:" + ChatDataUploadExecutor.this.mUserpin);
            } catch (JSONException e) {
                e.printStackTrace();
            }
            CatfishResult dsName = this.catfishRestAPI.setDsName(ChatDataUploadExecutor.this.mServer, ChatDataUploadExecutor.this.mUserpin, ChatDataUploadExecutor.this.mUserpin, ChatDataUploadExecutor.this.mObjSequence, safeFileName, fizzlinkTypeFromExtension, jSONObject.toString());
            if (dsName.hasSuccess()) {
                if (ChatDataUploadExecutor.this.mImagethumuri == null) {
                    Log.d(ChatDataUploadExecutor.TAG, "@@@ mImagethumuri null");
                    ChatDataUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(this.mMsgsetdsname), 2);
                    return;
                }
                try {
                    Uri parse = Uri.parse(ChatDataUploadExecutor.this.mImagethumuri);
                    ChatDataUploadExecutor.this.mDataFile = new File(parse.getPath());
                    Log.d(ChatDataUploadExecutor.TAG, "++++ myUri.getPath:" + parse.getPath() + "+++");
                    Long valueOf = Long.valueOf(ChatDataUploadExecutor.this.mDataFile.length());
                    ChatDataUploadExecutor.this.mDatasize = valueOf.intValue();
                    ChatDataUploadExecutor.this.mChunkstream = new FileInputStream(ChatDataUploadExecutor.this.mDataFile);
                    ChatDataUploadExecutor.this.mChunkbuffer = new byte[ChatDataUploadExecutor.mChunkMaxSize];
                    ChatDataUploadExecutor.this.mBytestart = 0;
                    ChatDataUploadExecutor.this.bNeedRead = true;
                    ChatDataUploadExecutor.this.mService.postToServiceHandler(new ThumbUploadChunk(this.mMsgsetdsname), 2);
                } catch (FileNotFoundException e2) {
                    ChatDataUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(this.mMsgsetdsname), 2);
                    return;
                }
            } else if (dsName.hasFailure()) {
                Log.d(ChatDataUploadExecutor.TAG, "----STATCOMM: FAILURE !!!: Re Schedule");
                ChatDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                ChatDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                r1 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                r1.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                r1.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
                r1.putExtra(CatfishService.PROGRESS_STATE, 4);
                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(r1);
            } else {
                r1 = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
                r1.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                r1.putExtra(CatfishService.PROGRESS_STATE, 4);
                r1.putExtra(ServerMessageDataStorage.SEQUENCE, ChatDataUploadExecutor.this.mSequence);
                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).sendBroadcast(r1);
                Log.e(ChatDataUploadExecutor.TAG, "----STATCOMM: SETDSNAME ERROR: DROP");
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
            }
            dsName.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class ThumbUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private volatile long mAge = System.currentTimeMillis();
        private String mMsg = null;
        public int scheduleNum = 0;

        public ThumbUploadChunk(String str) {
            this.mMsg = str;
        }

        public void dropRunnable() {
            if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                ChatDataUploadExecutor.this.mCacheFile.delete();
            }
            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (ChatDataUploadExecutor.this.mChunkstream == null) {
                Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE_THUMB: INVALID CHUNKSTREAM (NULL): CANCELED");
                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                ChatDataUploadExecutor.this.mChunkbuffer = null;
                if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                    ChatDataUploadExecutor.this.mCacheFile.delete();
                    return;
                }
                return;
            }
            try {
                if (ChatDataUploadExecutor.this.bNeedRead) {
                    ChatDataUploadExecutor.this.bNeedRead = false;
                    ChatDataUploadExecutor.this.mChunksize = ChatDataUploadExecutor.this.mChunkstream.read(ChatDataUploadExecutor.this.mChunkbuffer, 0, ChatDataUploadExecutor.mChunkMaxSize);
                }
                if (ChatDataUploadExecutor.this.mChunksize <= 0) {
                    Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE_THUMB: SENT COMPLETE-----@@@@");
                    Log.d(ChatDataUploadExecutor.TAG, "!@@@ object sequence:" + ChatDataUploadExecutor.this.mSequenceThumb + " object owner" + ChatDataUploadExecutor.this.mUserpin);
                    LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                    if (ChatDataUploadExecutor.this.mMessageObject != null) {
                        ChatDataUploadExecutor.this.sendBroadcastIntent(ChatDataUploadExecutor.this.mMessageObject);
                    }
                    Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE_THUMB: Post To Notify Recipients");
                    ChatDataUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(this.mMsg), 2);
                    try {
                        ChatDataUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                        ChatDataUploadExecutor.this.mCacheFile.delete();
                    }
                    ChatDataUploadExecutor.this.mChunkbuffer = null;
                } else if (ChatDataUploadExecutor.this.cancelUpload) {
                    Log.d(ChatDataUploadExecutor.TAG, "canceling upload is on progress.....");
                    LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                    ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                } else {
                    CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(ChatDataUploadExecutor.this.mServer, ChatDataUploadExecutor.this.mUserpin, ChatDataUploadExecutor.this.mSequenceThumb, ChatDataUploadExecutor.this.mDatasize, ChatDataUploadExecutor.this.mBytestart, ChatDataUploadExecutor.this.mChunksize, ChatDataUploadExecutor.this.mChunkbuffer);
                    if (ChatDataUploadExecutor.this.cancelUpload) {
                        Log.d(ChatDataUploadExecutor.TAG, "canceling upload is on progress.....");
                        LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                        ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                        return;
                    }
                    if (uploadDataChunk.hasSuccess()) {
                        this.mAge = System.currentTimeMillis();
                        if (uploadDataChunk.byteend == 0) {
                            Log.d(ChatDataUploadExecutor.TAG, "----Byte End is 0: RESEND");
                            ChatDataUploadExecutor.this.bNeedRead = false;
                            this.mAge = System.currentTimeMillis();
                            ChatDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                            return;
                        } else if (ChatDataUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - ChatDataUploadExecutor.this.mBytestart) + 1) {
                            Log.d(ChatDataUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                            ChatDataUploadExecutor.this.mChunkbuffer = null;
                            try {
                                ChatDataUploadExecutor.this.mChunkstream.close();
                            } catch (IOException e2) {
                            }
                            ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                            if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                                ChatDataUploadExecutor.this.mCacheFile.delete();
                            }
                            uploadDataChunk.cleaningup();
                            return;
                        } else {
                            Log.d(ChatDataUploadExecutor.TAG, "Chunk Sent: " + String.valueOf(uploadDataChunk.byteend - ChatDataUploadExecutor.this.mBytestart) + " bytes: " + String.valueOf(ChatDataUploadExecutor.this.mBytestart) + "-" + String.valueOf(uploadDataChunk.byteend) + ": SELF RE-POST");
                            ChatDataUploadExecutor chatDataUploadExecutor = ChatDataUploadExecutor.this;
                            chatDataUploadExecutor.mChunksent += (uploadDataChunk.byteend - ChatDataUploadExecutor.this.mBytestart) + 1;
                            ChatDataUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                            int i = (ChatDataUploadExecutor.this.mBytestart * 100) / ChatDataUploadExecutor.this.mDatasize;
                            ChatDataUploadExecutor.this.bNeedRead = true;
                            ChatDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        }
                    } else if (uploadDataChunk.hasFailure()) {
                        Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE_THUMB: FAILURE !!!: Re Schedule");
                        ChatDataUploadExecutor.this.bNeedRead = false;
                        ChatDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                        ChatDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    } else {
                        Log.e(ChatDataUploadExecutor.TAG, "----DCHATSHARE_THUMB: ERROR: DROP");
                        LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                        ChatDataUploadExecutor.this.mChunkbuffer = null;
                        try {
                            ChatDataUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e3) {
                        }
                        ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                        if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                            ChatDataUploadExecutor.this.mCacheFile.delete();
                        }
                    }
                    uploadDataChunk.cleaningup();
                }
            } catch (IOException e4) {
                Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE_THUMB: FAIL TO READ STREAM: CANCELED");
                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                ChatDataUploadExecutor.this.mChunkbuffer = null;
                ChatDataUploadExecutor.this.mService.postRunnableToDbThread(new ChatDeliveryStatus(MessageDeliveryStatus.DROP));
                if (ChatDataUploadExecutor.this.mCacheFile != null && ChatDataUploadExecutor.this.mCacheFile.exists()) {
                    ChatDataUploadExecutor.this.mCacheFile.delete();
                }
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public ChatDataUploadExecutor(CatfishService catfishService, ICatfishClientInterface iCatfishClientInterface, Context context, String str, String str2, String str3, String str4, String str5, ICatfishUIBinder iCatfishUIBinder, String str6) {
        this.mContext = context;
        this.mClientInterface = iCatfishClientInterface;
        this.mServiceBinder = iCatfishUIBinder;
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mRecipient = str3;
        this.mDataPath = str4;
        this.mMessage = str5;
        this.mSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mSequenceThumb = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mObjSequence = this.mSequence;
        this.mTipe = str6;
        this.mConvKey = this.mUserpin + ":" + this.mRecipient;
        Log.d(TAG, "+++ datapath:" + str4 + "+++");
        if (str4 == null) {
            Log.d(TAG, "+++ datapath:null+++");
            Toast.makeText(this.mContext, R.string.error_generic, 0).show();
            return;
        }
        this.mDataFile = new File(str4);
        this.mFilename = this.mDataFile.getName();
        Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_CHAT);
        intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelUploadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_CHAT_UPLOAD));
    }

    private void deteleThumbFile(Uri uri) {
        try {
            File file = new File(uri.getPath());
            if (file.exists()) {
                Log.d(TAG, "Delete thumbfile=" + file.getAbsolutePath());
                file.delete();
                return;
            }
            Log.d(TAG, "thumbfile=" + file.getAbsolutePath() + ": Not exists");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Bitmap rescaleBitmap() {
        int i = 1;
        Options options = new Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(this.mDataFile.getAbsolutePath(), options);
        int i2 = options.outWidth;
        int i3 = options.outHeight;
        while (i2 / 2 >= 240 && i3 / 2 >= 240) {
            i2 /= 2;
            i3 /= 2;
            i *= 2;
        }
        options = new Options();
        options.inSampleSize = i;
        options.inJustDecodeBounds = false;
        options.inPreferredConfig = Config.ARGB_8888;
        return BitmapFactory.decodeFile(this.mDataFile.getAbsolutePath(), options);
    }

    public void run() {
        Log.d(TAG, "To:" + this.mRecipient + ", Type:" + this.mTipe);
        if (isResumeProcess()) {
            this.mBytestart = getResumeUploadData().mBytestart;
            this.mChunksent = this.mBytestart;
            this.mSequence = Long.parseLong(getResumeUploadData().mKey);
            this.mObjSequence = this.mSequence;
        }
        if (this.mTipe.equals(AlbusModelObject.IMAGE) || this.mTipe.equals(AlbusModelObject.DATA_TYPE_IMAGE)) {
            ImageThumbnailer anonymousClass1 = new ImageThumbnailer(this.mService, CatfishService.getUserPIN(), 1, 2.0f) {
                protected void onPostExecute(Uri uri) {
                    if (uri != null) {
                        ChatDataUploadExecutor.this.mImagethumuri = uri.toString();
                        Log.d(ChatDataUploadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                        try {
                            ChatDataUploadExecutor.this.mCacheFile = CatfishPhotoStorage.getCacheFile(ChatDataUploadExecutor.this.mContext, ChatDataUploadExecutor.this.mFilename);
                            if (ChatDataUploadExecutor.this.mCacheFile == null) {
                                ChatDataUploadExecutor.this.deteleThumbFile(uri);
                                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                                return;
                            }
                            OutputStream fileOutputStream = new FileOutputStream(ChatDataUploadExecutor.this.mCacheFile);
                            Bitmap access$600 = ChatDataUploadExecutor.this.rescaleBitmap();
                            if (access$600 == null) {
                                try {
                                    fileOutputStream.close();
                                    if (ChatDataUploadExecutor.this.mCacheFile.exists()) {
                                        ChatDataUploadExecutor.this.mCacheFile.delete();
                                    }
                                } catch (IOException e) {
                                }
                                LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                                ChatDataUploadExecutor.this.deteleThumbFile(uri);
                                return;
                            }
                            Log.d(ChatDataUploadExecutor.TAG, "Image type = " + ChatDataUploadExecutor.this.mTipe);
                            if (ChatDataUploadExecutor.this.mTipe.equals(AlbusModelObject.DATA_TYPE_IMAGE)) {
                                Log.d(ChatDataUploadExecutor.TAG, "Compress using JPEG format");
                                access$600.compress(CompressFormat.JPEG, 100, fileOutputStream);
                            } else {
                                Log.d(ChatDataUploadExecutor.TAG, "Compress using PNG format");
                                access$600.compress(CompressFormat.PNG, 100, fileOutputStream);
                            }
                            try {
                                fileOutputStream.flush();
                                fileOutputStream.close();
                            } catch (IOException e2) {
                            }
                            Long valueOf = Long.valueOf(ChatDataUploadExecutor.this.mCacheFile.length());
                            ChatDataUploadExecutor.this.mDatasize = valueOf.intValue();
                            ChatDataUploadExecutor.this.mChunkstream = new FileInputStream(ChatDataUploadExecutor.this.mCacheFile);
                            if (ChatDataUploadExecutor.this.isResumeProcess()) {
                                ChatDataUploadExecutor.this.mChunkstream.skip((long) ChatDataUploadExecutor.this.mBytestart);
                            }
                            ChatDataUploadExecutor.this.mChunkbuffer = new byte[ChatDataUploadExecutor.mChunkMaxSize];
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Put Message in recipients record: " + ChatDataUploadExecutor.this.mDataFile.getAbsolutePath());
                            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(ChatDataUploadExecutor.this.mService);
                            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(ChatDataUploadExecutor.this.mService);
                            String string = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                            ChatDataUploadExecutor.this.mMessageObject = CatfishMessageObject.obtain();
                            ChatDataUploadExecutor.this.mMessageObject.messagetype = MessageType.PHOTOSEND_WCOMMENT;
                            ChatDataUploadExecutor.this.mMessageObject.userpin = ChatDataUploadExecutor.this.mUserpin;
                            ChatDataUploadExecutor.this.mMessageObject.message = ChatDataUploadExecutor.this.mMessage;
                            ChatDataUploadExecutor.this.mMessageObject.sequence = ChatDataUploadExecutor.this.mSequence;
                            ChatDataUploadExecutor.this.mMessageObject.object_sequence = ChatDataUploadExecutor.this.mObjSequence;
                            ChatDataUploadExecutor.this.mMessageObject.object_owner = ChatDataUploadExecutor.this.mUserpin;
                            ChatDataUploadExecutor.this.mMessageObject.image_path = ChatDataUploadExecutor.this.mDataFile.getAbsolutePath();
                            ChatDataUploadExecutor.this.mMessageObject.imagethumb_uri = ChatDataUploadExecutor.this.mImagethumuri;
                            ChatDataUploadExecutor.this.mMessageObject.deliverystatus = MessageDeliveryStatus.QUEUEING;
                            ChatDataUploadExecutor.this.mMessageObject.username = string;
                            ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp = ChatDataUploadExecutor.this.mSequence;
                            ChatDataUploadExecutor.this.mMessageObject.recipient = ChatDataUploadExecutor.this.mRecipient;
                            catfishDataStorage.storeUserMessage(ChatDataUploadExecutor.this.mMessageObject);
                            friendListDataStorage.setLastMessage(true, ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.sequence, ChatDataUploadExecutor.this.mMessageObject.message, ChatDataUploadExecutor.this.mMessageObject.deliverystatus.ordinal(), ChatDataUploadExecutor.this.mMessageObject.messagetype.ordinal(), ChatDataUploadExecutor.this.mMessageObject.image_path);
                            friendListDataStorage.updateActivityCount(ChatDataUploadExecutor.this.mMessageObject.recipient, 600);
                            friendListDataStorage.setFriendLastActivity(ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp);
                            friendListDataStorage.updateLastChatActivity(ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp);
                            ChatDataUploadExecutor.this.mService.postToMainHandler(new InvokeClientCallback(ChatDataUploadExecutor.this.mClientInterface, catfishDataStorage.getChatConversation(ChatDataUploadExecutor.this.mConvKey)));
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Put Message in recipients record: DONE");
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Post To Service: Upload DATA Chunks");
                            ChatDataUploadExecutor.this.mService.postToServiceHandler(new DataChatUploadChunk(ChatDataUploadExecutor.this.mMessage), 2);
                            return;
                        } catch (Exception e3) {
                            Log.d(ChatDataUploadExecutor.TAG, "----P2P DATA FILE: " + e3.toString());
                            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                            ChatDataUploadExecutor.this.mChunkstream = null;
                            if (ChatDataUploadExecutor.this.mCacheFile.exists()) {
                                ChatDataUploadExecutor.this.mCacheFile.delete();
                            }
                            ChatDataUploadExecutor.this.deteleThumbFile(uri);
                            return;
                        }
                    }
                    Log.d(ChatDataUploadExecutor.TAG, "Thumbnail FAIL to create");
                }
            };
            Log.d(TAG, "uri" + Uri.fromFile(this.mDataFile));
            anonymousClass1.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
        } else if (this.mTipe.equals(AlbusModelObject.DATA_TYPE_VOICE)) {
            Log.d(TAG, "----DCHATSHARE: VOICE CHAT----");
            try {
                this.mDatasize = Long.valueOf(this.mDataFile.length()).intValue();
                this.mChunkstream = new FileInputStream(this.mDataFile);
                if (isResumeProcess()) {
                    this.mChunkstream.skip((long) this.mBytestart);
                }
                this.mChunkbuffer = new byte[mChunkMaxSize];
                Log.d(TAG, "----DCHATSHARE: Put Message in recipients record: " + this.mDataFile.getAbsolutePath());
                r0 = new CatfishDataStorage(this.mService);
                r3 = new FriendListDataStorage(this.mService);
                r1 = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                this.mMessageObject = CatfishMessageObject.obtain();
                this.mMessageObject.messagetype = MessageType.DATASEND_WCOMMENT;
                this.mMessageObject.userpin = this.mUserpin;
                this.mMessageObject.sequence = this.mSequence;
                this.mMessageObject.object_sequence = this.mObjSequence;
                this.mMessageObject.object_owner = this.mUserpin;
                this.mMessageObject.voicefilepath = this.mDataFile.getAbsolutePath();
                this.mMessageObject.deliverystatus = MessageDeliveryStatus.QUEUEING;
                this.mMessageObject.username = r1;
                this.mMessageObject.rcvtimestamp = this.mSequence;
                this.mMessageObject.recipient = this.mRecipient;
                r0.storeUserMessage(this.mMessageObject);
                r3.setLastMessage(true, this.mMessageObject.recipient, this.mMessageObject.sequence, this.mMessageObject.message, this.mMessageObject.deliverystatus.ordinal(), this.mMessageObject.messagetype.ordinal(), this.mMessageObject.voicefilepath);
                r3.updateActivityCount(this.mMessageObject.recipient, 600);
                r3.setFriendLastActivity(this.mMessageObject.recipient, this.mMessageObject.rcvtimestamp);
                r3.updateLastChatActivity(this.mMessageObject.recipient, this.mMessageObject.rcvtimestamp);
                this.mService.postToMainHandler(new InvokeClientCallback(this.mClientInterface, r0.getChatConversation(this.mConvKey)));
                Log.d(TAG, "----DCHATSHARE: Put Message in recipients record: DONE");
                Log.d(TAG, "----DCHATSHARE: Post To Service: Upload DATA Chunks");
                this.mService.postToServiceHandler(new DataChatUploadChunk(this.mMessage), 2);
            } catch (Exception e) {
                Log.d(TAG, "----DATA FILE: " + e.toString());
                LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelUploadReceiver);
                this.mChunkstream = null;
            }
        } else if (!this.mTipe.equals(ChunkStorage.DATA_TABLE_NAME) && !this.mTipe.equals(AlbusModelObject.DATA_TYPE_VIDEO)) {
        } else {
            if (this.mTipe.equals(ChunkStorage.DATA_TABLE_NAME)) {
                Log.d(TAG, " --- File Share Image, create thumbnail --- ");
                new ImageThumbnailer(this.mService, CatfishService.getUserPIN(), 0, false, this.mDataFile.getAbsolutePath(), 2.0f) {
                    protected void onPostExecute(Uri uri) {
                        Log.d(ChatDataUploadExecutor.TAG, " --- onPostExecute, create thumbnail --- ");
                        if (uri != null) {
                            ChatDataUploadExecutor.this.mImagethumuri = uri.toString();
                        }
                        try {
                            Long valueOf = Long.valueOf(ChatDataUploadExecutor.this.mDataFile.length());
                            ChatDataUploadExecutor.this.mDatasize = valueOf.intValue();
                            ChatDataUploadExecutor.this.mChunkstream = new FileInputStream(ChatDataUploadExecutor.this.mDataFile);
                            if (ChatDataUploadExecutor.this.isResumeProcess()) {
                                ChatDataUploadExecutor.this.mChunkstream.skip((long) ChatDataUploadExecutor.this.mBytestart);
                            }
                            ChatDataUploadExecutor.this.mChunkbuffer = new byte[ChatDataUploadExecutor.mChunkMaxSize];
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Put Message in recipients record: " + ChatDataUploadExecutor.this.mDataFile.getAbsolutePath());
                            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(ChatDataUploadExecutor.this.mService);
                            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(ChatDataUploadExecutor.this.mService);
                            String string = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                            ChatDataUploadExecutor.this.mMessageObject = CatfishMessageObject.obtain();
                            ChatDataUploadExecutor.this.mMessageObject.messagetype = MessageType.DATASEND_WCOMMENT;
                            ChatDataUploadExecutor.this.mMessageObject.userpin = ChatDataUploadExecutor.this.mUserpin;
                            ChatDataUploadExecutor.this.mMessageObject.message = ChatDataUploadExecutor.this.mMessage;
                            ChatDataUploadExecutor.this.mMessageObject.sequence = ChatDataUploadExecutor.this.mSequence;
                            ChatDataUploadExecutor.this.mMessageObject.object_sequence = ChatDataUploadExecutor.this.mObjSequence;
                            ChatDataUploadExecutor.this.mMessageObject.object_owner = ChatDataUploadExecutor.this.mUserpin;
                            ChatDataUploadExecutor.this.mMessageObject.datafile_path = ChatDataUploadExecutor.this.mDataFile.getAbsolutePath();
                            ChatDataUploadExecutor.this.mMessageObject.imagethumb_uri = ChatDataUploadExecutor.this.mImagethumuri;
                            ChatDataUploadExecutor.this.mMessageObject.deliverystatus = MessageDeliveryStatus.QUEUEING;
                            ChatDataUploadExecutor.this.mMessageObject.username = string;
                            ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp = ChatDataUploadExecutor.this.mSequence;
                            ChatDataUploadExecutor.this.mMessageObject.recipient = ChatDataUploadExecutor.this.mRecipient;
                            catfishDataStorage.storeUserMessage(ChatDataUploadExecutor.this.mMessageObject);
                            friendListDataStorage.setLastMessage(true, ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.sequence, ChatDataUploadExecutor.this.mMessageObject.message, ChatDataUploadExecutor.this.mMessageObject.deliverystatus.ordinal(), ChatDataUploadExecutor.this.mMessageObject.messagetype.ordinal(), ChatDataUploadExecutor.this.mMessageObject.datafile_path);
                            friendListDataStorage.updateActivityCount(ChatDataUploadExecutor.this.mMessageObject.recipient, 600);
                            friendListDataStorage.setFriendLastActivity(ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp);
                            friendListDataStorage.updateLastChatActivity(ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp);
                            ChatDataUploadExecutor.this.mService.postToMainHandler(new InvokeClientCallback(ChatDataUploadExecutor.this.mClientInterface, catfishDataStorage.getChatConversation(ChatDataUploadExecutor.this.mConvKey)));
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Put Message in recipients record: DONE");
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Post To Service: Upload DATA Chunks");
                            ChatDataUploadExecutor.this.mService.postToServiceHandler(new DataChatUploadChunk(ChatDataUploadExecutor.this.mMessage), 2);
                        } catch (Exception e) {
                            Log.d(ChatDataUploadExecutor.TAG, "----DATA FILE: " + e.toString());
                            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                            ChatDataUploadExecutor.this.mChunkstream = null;
                        }
                    }
                }.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
            } else if (this.mTipe.equals(AlbusModelObject.DATA_TYPE_VIDEO)) {
                Log.d(TAG, " --- File Share video, create thumbnail --- ");
                new ImageThumbnailer(this.mService, CatfishService.getUserPIN(), 0, true, this.mDataFile.getAbsolutePath()) {
                    protected void onPostExecute(Uri uri) {
                        Log.d(ChatDataUploadExecutor.TAG, " --- onPostExecute, create thumbnail --- ");
                        if (uri != null) {
                            ChatDataUploadExecutor.this.mImagethumuri = uri.toString();
                        }
                        try {
                            Long valueOf = Long.valueOf(ChatDataUploadExecutor.this.mDataFile.length());
                            ChatDataUploadExecutor.this.mDatasize = valueOf.intValue();
                            ChatDataUploadExecutor.this.mChunkstream = new FileInputStream(ChatDataUploadExecutor.this.mDataFile);
                            if (ChatDataUploadExecutor.this.isResumeProcess()) {
                                ChatDataUploadExecutor.this.mChunkstream.skip((long) ChatDataUploadExecutor.this.mBytestart);
                            }
                            ChatDataUploadExecutor.this.mChunkbuffer = new byte[ChatDataUploadExecutor.mChunkMaxSize];
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Put Message in recipients record: " + ChatDataUploadExecutor.this.mDataFile.getAbsolutePath());
                            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(ChatDataUploadExecutor.this.mService);
                            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(ChatDataUploadExecutor.this.mService);
                            String string = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                            ChatDataUploadExecutor.this.mMessageObject = CatfishMessageObject.obtain();
                            ChatDataUploadExecutor.this.mMessageObject.messagetype = MessageType.VIDEO_STREAMING;
                            ChatDataUploadExecutor.this.mMessageObject.userpin = ChatDataUploadExecutor.this.mUserpin;
                            ChatDataUploadExecutor.this.mMessageObject.message = ChatDataUploadExecutor.this.mMessage;
                            ChatDataUploadExecutor.this.mMessageObject.sequence = ChatDataUploadExecutor.this.mSequence;
                            ChatDataUploadExecutor.this.mMessageObject.object_sequence = ChatDataUploadExecutor.this.mObjSequence;
                            ChatDataUploadExecutor.this.mMessageObject.object_owner = ChatDataUploadExecutor.this.mUserpin;
                            ChatDataUploadExecutor.this.mMessageObject.datafile_path = ChatDataUploadExecutor.this.mDataFile.getAbsolutePath();
                            ChatDataUploadExecutor.this.mMessageObject.imagethumb_uri = ChatDataUploadExecutor.this.mImagethumuri;
                            ChatDataUploadExecutor.this.mMessageObject.deliverystatus = MessageDeliveryStatus.QUEUEING;
                            ChatDataUploadExecutor.this.mMessageObject.username = string;
                            ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp = ChatDataUploadExecutor.this.mSequence;
                            ChatDataUploadExecutor.this.mMessageObject.recipient = ChatDataUploadExecutor.this.mRecipient;
                            catfishDataStorage.storeUserMessage(ChatDataUploadExecutor.this.mMessageObject);
                            friendListDataStorage.setLastMessage(true, ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.sequence, ChatDataUploadExecutor.this.mMessageObject.message, ChatDataUploadExecutor.this.mMessageObject.deliverystatus.ordinal(), ChatDataUploadExecutor.this.mMessageObject.messagetype.ordinal(), ChatDataUploadExecutor.this.mMessageObject.datafile_path);
                            friendListDataStorage.updateActivityCount(ChatDataUploadExecutor.this.mMessageObject.recipient, 600);
                            ChatDataUploadExecutor.this.mMessageObject.messagetype = MessageType.DATASEND_WCOMMENT;
                            friendListDataStorage.setFriendLastActivity(ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp);
                            friendListDataStorage.updateLastChatActivity(ChatDataUploadExecutor.this.mMessageObject.recipient, ChatDataUploadExecutor.this.mMessageObject.rcvtimestamp);
                            ChatDataUploadExecutor.this.mService.postToMainHandler(new InvokeClientCallback(ChatDataUploadExecutor.this.mClientInterface, catfishDataStorage.getChatConversation(ChatDataUploadExecutor.this.mConvKey)));
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Put Message in recipients record: DONE");
                            Log.d(ChatDataUploadExecutor.TAG, "----DCHATSHARE: Post To Service: Upload DATA Chunks");
                            ChatDataUploadExecutor.this.mService.postToServiceHandler(new DataChatUploadChunk(ChatDataUploadExecutor.this.mMessage), 2);
                        } catch (Exception e) {
                            Log.d(ChatDataUploadExecutor.TAG, "----DATA FILE: " + e.toString());
                            LocalBroadcastManager.getInstance(ChatDataUploadExecutor.this.mService).unregisterReceiver(ChatDataUploadExecutor.this.mCancelUploadReceiver);
                            ChatDataUploadExecutor.this.mChunkstream = null;
                        }
                    }
                }.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
            } else {
                try {
                    this.mDatasize = Long.valueOf(this.mDataFile.length()).intValue();
                    this.mChunkstream = new FileInputStream(this.mDataFile);
                    if (isResumeProcess()) {
                        this.mChunkstream.skip((long) this.mBytestart);
                    }
                    this.mChunkbuffer = new byte[mChunkMaxSize];
                    Log.d(TAG, "----DCHATSHARE: Put Message in recipients record: " + this.mDataFile.getAbsolutePath());
                    r0 = new CatfishDataStorage(this.mService);
                    r3 = new FriendListDataStorage(this.mService);
                    r1 = CatfishService.getCatfishPreferences().getString(CatfishService.USERNAME_PREF, null);
                    this.mMessageObject = CatfishMessageObject.obtain();
                    this.mMessageObject.messagetype = MessageType.DATASEND_WCOMMENT;
                    this.mMessageObject.userpin = this.mUserpin;
                    this.mMessageObject.message = this.mMessage;
                    this.mMessageObject.sequence = this.mSequence;
                    this.mMessageObject.object_sequence = this.mObjSequence;
                    this.mMessageObject.object_owner = this.mUserpin;
                    this.mMessageObject.datafile_path = this.mDataFile.getAbsolutePath();
                    this.mMessageObject.imagethumb_uri = this.mImagethumuri;
                    this.mMessageObject.deliverystatus = MessageDeliveryStatus.QUEUEING;
                    this.mMessageObject.username = r1;
                    this.mMessageObject.rcvtimestamp = this.mSequence;
                    this.mMessageObject.recipient = this.mRecipient;
                    r0.storeUserMessage(this.mMessageObject);
                    r3.setLastMessage(true, this.mMessageObject.recipient, this.mMessageObject.sequence, this.mMessageObject.message, this.mMessageObject.deliverystatus.ordinal(), this.mMessageObject.messagetype.ordinal(), this.mMessageObject.datafile_path);
                    r3.updateActivityCount(this.mMessageObject.recipient, 600);
                    r3.setFriendLastActivity(this.mMessageObject.recipient, this.mMessageObject.rcvtimestamp);
                    r3.updateLastChatActivity(this.mMessageObject.recipient, this.mMessageObject.rcvtimestamp);
                    this.mService.postToMainHandler(new InvokeClientCallback(this.mClientInterface, r0.getChatConversation(this.mConvKey)));
                    Log.d(TAG, "----DCHATSHARE: Put Message in recipients record: DONE");
                    Log.d(TAG, "----DCHATSHARE: Post To Service: Upload DATA Chunks");
                    this.mService.postToServiceHandler(new DataChatUploadChunk(this.mMessage), 2);
                } catch (Exception e2) {
                    Log.d(TAG, "----DATA FILE: " + e2.toString());
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelUploadReceiver);
                    this.mChunkstream = null;
                }
            }
        }
    }

    public void sendBroadcastIntent(CatfishMessageObject catfishMessageObject) {
        if (catfishMessageObject == null || catfishMessageObject.message == null || !catfishMessageObject.message.equals(LONG_MESSAGE)) {
            Intent intent = new Intent();
            String str = "";
            str = this.mConvKey == null ? catfishMessageObject.userpin + ":" + catfishMessageObject.recipient : this.mConvKey;
            intent.putExtra(TaskDataStorage.SENDERPIN, catfishMessageObject.userpin);
            intent.putExtra(ServerMessageDataStorage.SENDERNAME, catfishMessageObject.username);
            intent.putExtra("conversation_key", str);
            intent.putExtra("image_path", catfishMessageObject.image_path);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, catfishMessageObject.sequence);
            intent.putExtra("imagethumb_uri", catfishMessageObject.imagethumb_uri);
            intent.putExtra(ServerMessageDataStorage.VOICEFILEPATH, catfishMessageObject.voicefilepath);
            intent.putExtra("datafile_path", catfishMessageObject.datafile_path);
            intent.putExtra(ServerMessageDataStorage.MESSAGE, this.mMessage);
            intent.putExtra(TaskDataStorage.MESSAGETYPE, catfishMessageObject.messagetype.ordinal());
            intent.putExtra("rcvtimestamp", catfishMessageObject.rcvtimestamp);
            intent.putExtra("object_owner", catfishMessageObject.object_owner);
            intent.putExtra("object_sequence", catfishMessageObject.object_sequence);
            intent.setAction(BroadcastIntents.ACTION_CHAT_MEDIA);
            this.mService.sendBroadcast(intent);
            Log.d(TAG, "SEND BROADCAST MEDIA FROM CHAT WITH TEXT");
        }
    }
}

package com.catfiz.service;

import android.database.Cursor;
import android.widget.Toast;
import com.catfiz.R;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishService.UpdateRecent;
import com.catfiz.util.Log;
import com.catfiz.util.ObjectLockManager;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class PPFUploadExecutor implements IDropableRunnable, Runnable {
    private static final String TAG = "PPFUploadExecutor";
    private static final int mChunkMaxSize = 131072;
    private boolean bNeedDelete = true;
    private boolean bNeedRead = true;
    private CatfishRESTAPI catfishRestAPI = null;
    private volatile long mAge = 0;
    private int mBytestart = 0;
    private byte[] mChunkbuffer = null;
    private int mChunksent = 0;
    private int mChunksize = 0;
    private FileInputStream mChunkstream = null;
    public String mLockKey = null;
    public String mLockObj = null;
    public String mNotifyRecipients;
    private int mPhotosize = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private String mUserpin = null;
    public int scheduleNum = 0;

    class AddRecentUpdate implements Runnable {
        private AddRecentUpdate() {
        }

        public void run() {
            new CatfishDataStorage(PPFUploadExecutor.this.mService).addRecentupdatesSelfPhoto();
            PPFUploadExecutor.this.mService.signalUpdatesIncoming(UpdateRecent.SELFPHOTOUPDT.ordinal(), "");
        }
    }

    class GetFriendPinsToNotify implements Runnable {
        private GetFriendPinsToNotify() {
        }

        public void run() {
            Toast.makeText(PPFUploadExecutor.this.mService, R.string.profile_pict_title, 1).show();
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(PPFUploadExecutor.this.mService);
            Cursor friendPINs = new FriendListDataStorage(PPFUploadExecutor.this.mService).getFriendPINs();
            int columnIndex = friendPINs.getColumnIndex(FriendListDataStorage.FRIENDPIN);
            int count = friendPINs.getCount();
            PPFUploadExecutor.this.mNotifyRecipients = "";
            friendPINs.moveToFirst();
            for (int i = 0; i < count; i++) {
                StringBuilder stringBuilder;
                PPFUploadExecutor pPFUploadExecutor;
                if (i > 0) {
                    stringBuilder = new StringBuilder();
                    pPFUploadExecutor = PPFUploadExecutor.this;
                    pPFUploadExecutor.mNotifyRecipients = stringBuilder.append(pPFUploadExecutor.mNotifyRecipients).append(",").toString();
                }
                stringBuilder = new StringBuilder();
                pPFUploadExecutor = PPFUploadExecutor.this;
                pPFUploadExecutor.mNotifyRecipients = stringBuilder.append(pPFUploadExecutor.mNotifyRecipients).append(friendPINs.getString(columnIndex)).toString();
                friendPINs.moveToNext();
            }
            if (PPFUploadExecutor.this.mNotifyRecipients.length() > 0) {
                Log.d(PPFUploadExecutor.TAG, "DB Thread: Notify Friend for Photo Update: Post to service");
                PPFUploadExecutor.this.mService.postToServiceHandler(new NotifyFriendsForUpdate(), 2);
            } else {
                Log.d(PPFUploadExecutor.TAG, "DB Thread: Notify Friend for Photo Update: NO FRIEND PINS FOUND !!!");
            }
            friendPINs.close();
        }
    }

    class NotifyFriendsForUpdate implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private NotifyFriendsForUpdate() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult notifyFriendsPhotoUpdate = this.catfishRestAPI.notifyFriendsPhotoUpdate(PPFUploadExecutor.this.mServer, PPFUploadExecutor.this.mUserpin);
            if (notifyFriendsPhotoUpdate.hasSuccess()) {
                Log.e(PPFUploadExecutor.TAG, "Notify friends: Photo Update: DONE");
            } else if (notifyFriendsPhotoUpdate.hasFailure()) {
                Log.e(PPFUploadExecutor.TAG, "Notify friends: Photo Update: FAIL: Re schedule");
                PPFUploadExecutor.this.mServer = CatfishService.getServerHost();
                PPFUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else if (!notifyFriendsPhotoUpdate.hasSuccess()) {
                Log.e(PPFUploadExecutor.TAG, "Notify friends: Photo Update: ERROR: DROP");
            }
            notifyFriendsPhotoUpdate.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class SetUploadAsComplete implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private SetUploadAsComplete() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            Log.e(PPFUploadExecutor.TAG, "Setting Profile Photo as Complete state: ERROR: DROP BY SERVICE");
            ObjectLockManager.releaseLockKey(PPFUploadExecutor.this.mLockKey);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (!ObjectLockManager.isLockKeyLocked(PPFUploadExecutor.this.mLockKey)) {
                Log.e(PPFUploadExecutor.TAG, "SetUploadAsComplete: INCONSISTENT LOCK!!!: DROP");
            } else if (ObjectLockManager.checkLockKeyString(PPFUploadExecutor.this.mLockKey, PPFUploadExecutor.this.mLockObj)) {
                Log.d(PPFUploadExecutor.TAG, "SetUploadAsComplete: WE HAVE HELD THE LOCK: Continue...");
                CatfishResult profilePhotoAsComplete = this.catfishRestAPI.setProfilePhotoAsComplete(PPFUploadExecutor.this.mServer, PPFUploadExecutor.this.mUserpin);
                if (profilePhotoAsComplete.hasSuccess()) {
                    Log.e(PPFUploadExecutor.TAG, "Setting Profile Photo as Complete state: DONE");
                    ObjectLockManager.releaseLockKey(PPFUploadExecutor.this.mLockKey);
                    PPFUploadExecutor.this.mService.postRunnableToDbThread(new GetFriendPinsToNotify());
                    PPFUploadExecutor.this.mService.postRunnableToDbThread(new AddRecentUpdate());
                } else if (profilePhotoAsComplete.hasFailure()) {
                    Log.e(PPFUploadExecutor.TAG, "Setting Profile Photo as Complete state: FAIL: Re schedule");
                    PPFUploadExecutor.this.mServer = CatfishService.getServerHost();
                    PPFUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                } else if (!profilePhotoAsComplete.hasSuccess()) {
                    Log.e(PPFUploadExecutor.TAG, "Setting Profile Photo as Complete state: ERROR: DROP");
                    ObjectLockManager.releaseLockKey(PPFUploadExecutor.this.mLockKey);
                    Toast.makeText(PPFUploadExecutor.this.mService, R.string.profile_pict_error_title, 1).show();
                }
                profilePhotoAsComplete.cleaningup();
            } else {
                Log.d(PPFUploadExecutor.TAG, "SetUploadAsComplete: OOPS LOCK ITS NOT MINE: CANCEL");
                ObjectLockManager.releaseLockKey(PPFUploadExecutor.this.mLockKey);
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public PPFUploadExecutor(CatfishService catfishService, String str, String str2, File file) {
        this.mServer = str;
        this.mService = catfishService;
        this.mUserpin = str2;
        try {
            this.mPhotosize = Long.valueOf(file.length()).intValue();
            this.mChunkstream = new FileInputStream(file);
            this.mChunkbuffer = new byte[mChunkMaxSize];
        } catch (FileNotFoundException e) {
            Log.d(TAG, "ERROR UPLOAD PROFILE PHOTO: " + e.toString());
            this.mChunkstream = null;
        } catch (Exception e2) {
            e2.printStackTrace();
            Log.d(TAG, "FATAL ERROR UPLOAD PROFILE PHOTO");
            this.mChunkstream = null;
        }
        this.mLockKey = "ppfupload:" + this.mUserpin;
        this.mLockObj = String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence());
        ObjectLockManager.acquireLockKey(this.mLockKey, this.mLockObj);
        this.mAge = System.currentTimeMillis();
    }

    private boolean processDeleteFirst() {
        Log.d(TAG, "Deleting Profile Photo...");
        CatfishResult deleteProfilePhoto = this.catfishRestAPI.deleteProfilePhoto(this.mServer, this.mUserpin);
        if (deleteProfilePhoto.hasFailure()) {
            Log.d(TAG, "Deleting Profile Photo: FAIL: Re schedule");
            this.mServer = CatfishService.getServerHost();
            this.mService.scheduleRunnableToService(this, 2);
            deleteProfilePhoto.cleaningup();
            return false;
        } else if (deleteProfilePhoto.hasSuccess()) {
            Log.d(TAG, "Deleting Profile Photo...DONE");
            return true;
        } else {
            Log.e(TAG, "Deleting Profile Photo: ERROR: DROP");
            deleteProfilePhoto.cleaningup();
            return false;
        }
    }

    public void dropRunnable() {
        ObjectLockManager.releaseLockKey(this.mLockKey);
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        if (this.mChunkstream == null) {
            Log.d(TAG, "----PROFILE PHOTO: INVALID: CANCELED");
            ObjectLockManager.releaseLockKey(this.mLockKey);
            Toast.makeText(this.mService, R.string.profile_pict_error_title, 1).show();
            this.mChunkbuffer = null;
        } else if (!ObjectLockManager.isLockKeyLocked(this.mLockKey)) {
            Log.e(TAG, "INCONSISTENT LOCK!!!: DROP");
            try {
                this.mChunkstream.close();
            } catch (IOException e) {
            }
        } else if (ObjectLockManager.checkLockKeyString(this.mLockKey, this.mLockObj)) {
            Log.d(TAG, "WE HAVE HELD THE LOCK: Continue...");
            if (this.bNeedDelete) {
                if (processDeleteFirst()) {
                    this.bNeedDelete = false;
                } else {
                    ObjectLockManager.releaseLockKey(this.mLockKey);
                    return;
                }
            }
            try {
                if (this.bNeedRead) {
                    this.bNeedRead = false;
                    this.mChunksize = this.mChunkstream.read(this.mChunkbuffer, 0, mChunkMaxSize);
                }
                CatfishResult profilePhotoAsComplete;
                if (this.mChunksize <= 0) {
                    Log.d(TAG, "----PROFILE PHOTO: SENT COMPLETE");
                    profilePhotoAsComplete = this.catfishRestAPI.setProfilePhotoAsComplete(this.mServer, this.mUserpin);
                    if (profilePhotoAsComplete.hasSuccess()) {
                        Log.e(TAG, "Setting Profile Photo as Complete state: DONE");
                        ObjectLockManager.releaseLockKey(this.mLockKey);
                        this.mService.postRunnableToDbThread(new GetFriendPinsToNotify());
                        this.mService.postRunnableToDbThread(new AddRecentUpdate());
                    } else if (profilePhotoAsComplete.hasFailure()) {
                        Log.e(TAG, "Setting Profile Photo as Complete state: FAIL: Re schedule");
                        this.mServer = CatfishService.getServerHost();
                        this.mService.scheduleRunnableToService(new SetUploadAsComplete(), 2);
                    } else if (!profilePhotoAsComplete.hasSuccess()) {
                        Log.e(TAG, "Setting Profile Photo as Complete state: ERROR: DROP");
                        Toast.makeText(this.mService, R.string.profile_pict_error_title, 1).show();
                        ObjectLockManager.releaseLockKey(this.mLockKey);
                    }
                    try {
                        this.mChunkstream.close();
                    } catch (IOException e2) {
                    }
                    this.mChunkbuffer = null;
                    profilePhotoAsComplete.cleaningup();
                    return;
                }
                Log.d(TAG, "Chunk Send: bs=" + String.valueOf(this.mBytestart) + ", size=" + String.valueOf(this.mChunksize));
                profilePhotoAsComplete = this.catfishRestAPI.uploadProfilePhotoChunk(this.mServer, this.mUserpin, 1, this.mPhotosize, this.mBytestart, this.mChunksize, this.mChunkbuffer);
                if (profilePhotoAsComplete.hasSuccess()) {
                    this.mAge = System.currentTimeMillis();
                    if (this.mChunksize != (profilePhotoAsComplete.byteend - this.mBytestart) + 1) {
                        Log.d(TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                        this.mChunkbuffer = null;
                        ObjectLockManager.releaseLockKey(this.mLockKey);
                        Toast.makeText(this.mService, R.string.profile_pict_error_title, 1).show();
                        try {
                            this.mChunkstream.close();
                        } catch (IOException e3) {
                        }
                        profilePhotoAsComplete.cleaningup();
                        return;
                    }
                    Log.d(TAG, "Chunk Sent: " + String.valueOf(profilePhotoAsComplete.byteend - this.mBytestart) + " bytes: " + String.valueOf(this.mBytestart) + "-" + String.valueOf(profilePhotoAsComplete.byteend) + ": SELF RE-POST");
                    this.mChunksent += (profilePhotoAsComplete.byteend - this.mBytestart) + 1;
                    this.mBytestart = profilePhotoAsComplete.byteend + 1;
                    this.bNeedRead = true;
                    this.mAge = System.currentTimeMillis();
                    this.mService.postToServiceHandler(this, 2);
                } else if (profilePhotoAsComplete.hasFailure()) {
                    Log.d(TAG, "----PROFILE PHOTO: FAILURE !!!: Re Schedule");
                    this.bNeedRead = false;
                    this.mServer = CatfishService.getServerHost();
                    this.mService.scheduleRunnableToService(this, 2);
                } else {
                    Log.e(TAG, "----PROFILE PHOTO: ERROR: DROP");
                    this.mChunkbuffer = null;
                    ObjectLockManager.releaseLockKey(this.mLockKey);
                    Toast.makeText(this.mService, R.string.profile_pict_error_title, 1).show();
                    try {
                        this.mChunkstream.close();
                    } catch (IOException e4) {
                    }
                }
                profilePhotoAsComplete.cleaningup();
            } catch (IOException e5) {
                Log.d(TAG, "----PROFILE PHOTO: FAIL TO READ: CANCELED");
                ObjectLockManager.releaseLockKey(this.mLockKey);
                Toast.makeText(this.mService, R.string.profile_pict_error_title, 1).show();
                this.mChunkbuffer = null;
            }
        } else {
            Log.d(TAG, "OOPS LOCK ITS NOT MINE: CANCEL");
            ObjectLockManager.releaseLockKey(this.mLockKey);
            try {
                this.mChunkstream.close();
            } catch (IOException e6) {
            }
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

package com.catfiz.service;

import android.os.Bundle;
import android.support.v4.os.EnvironmentCompat;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.catfiz.media.CatfishPhotoStorage;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.util.Log;
import com.catfiz.util.ObjectLockManager;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class PromotePFDownloadExecutor implements IDropableRunnable, Runnable {
    private static final String TAG = "PromotePFDownloadExecutor";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = 0;
    private int mByteend = 0;
    private int mBytestart = 0;
    private byte[] mChunkbuffer = null;
    private FileOutputStream mChunkstream = null;
    private String mFriendpin = null;
    public String mLockKey = null;
    public String mLockObj = null;
    private String mObyekOwner = null;
    private int mPhotosize = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private String mUserpin = null;
    private int mWriten = 0;
    public int scheduleNum = 0;

    class GetProfilePhotoChunks implements IDropableRunnable, Runnable {
        private boolean bNotifyUI;
        private CatfishRESTAPI catfishRestAPI;
        private volatile long mAge;
        public int scheduleNum;

        private GetProfilePhotoChunks() {
            this.bNotifyUI = false;
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            Log.d(PromotePFDownloadExecutor.TAG, "Friend (" + PromotePFDownloadExecutor.this.mFriendpin + ") Photo Download: DROP BY SERVICE");
            ObjectLockManager.releaseLockKey(PromotePFDownloadExecutor.this.mLockKey);
            try {
                PromotePFDownloadExecutor.this.mChunkstream.flush();
                PromotePFDownloadExecutor.this.mChunkstream.close();
            } catch (IOException e) {
            }
            PromotePFDownloadExecutor.this.onDownloadPhotoFail();
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            int i = 0;
            if (!ObjectLockManager.isLockKeyLocked(PromotePFDownloadExecutor.this.mLockKey)) {
                Log.e(PromotePFDownloadExecutor.TAG, "GetProfilePhotoChunks: INCONSISTENT LOCK!!!: DROP");
                try {
                    PromotePFDownloadExecutor.this.mChunkstream.flush();
                    PromotePFDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e) {
                }
            } else if (ObjectLockManager.checkLockKeyString(PromotePFDownloadExecutor.this.mLockKey, PromotePFDownloadExecutor.this.mLockObj)) {
                Log.d(PromotePFDownloadExecutor.TAG, "GetProfilePhotoChunks: WE HAVE HELD THE LOCK: Continue...");
                if (CatfishPhotoStorage.isPhotoStorageMounted()) {
                    Log.d(PromotePFDownloadExecutor.TAG, "Get byte range: bs=" + String.valueOf(PromotePFDownloadExecutor.this.mBytestart) + ", " + "be=" + String.valueOf(PromotePFDownloadExecutor.this.mByteend) + ", " + "size=" + String.valueOf(PromotePFDownloadExecutor.this.mPhotosize) + ", " + "mWriten=" + String.valueOf(PromotePFDownloadExecutor.this.mWriten));
                    CatfishResult downloadProfilePhotoChunk = this.catfishRestAPI.downloadProfilePhotoChunk(PromotePFDownloadExecutor.this.mServer, PromotePFDownloadExecutor.this.mUserpin, PromotePFDownloadExecutor.this.mFriendpin, PromotePFDownloadExecutor.this.mBytestart, PromotePFDownloadExecutor.this.mByteend, PromotePFDownloadExecutor.this.mChunkstream);
                    Log.d(PromotePFDownloadExecutor.TAG, "Chunksize: " + String.valueOf(downloadProfilePhotoChunk.chunksize));
                    Bundle bundle;
                    if (downloadProfilePhotoChunk.hasSuccess() && downloadProfilePhotoChunk.chunksize != 0) {
                        this.mAge = System.currentTimeMillis();
                        if (downloadProfilePhotoChunk.chunksize > 0) {
                            PromotePFDownloadExecutor.this.mWriten = PromotePFDownloadExecutor.this.mWriten + downloadProfilePhotoChunk.chunksize;
                        }
                        if (PromotePFDownloadExecutor.this.mWriten < PromotePFDownloadExecutor.this.mPhotosize) {
                            PromotePFDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.growChunkSize(PromotePFDownloadExecutor.mChunkMaxSize);
                            PromotePFDownloadExecutor.this.mBytestart = PromotePFDownloadExecutor.this.mWriten;
                            PromotePFDownloadExecutor.this.mByteend = (PromotePFDownloadExecutor.this.mBytestart + PromotePFDownloadExecutor.mChunkMaxSize) - 1;
                            this.mAge = System.currentTimeMillis();
                            PromotePFDownloadExecutor.this.mService.postRunnableToService(this);
                            downloadProfilePhotoChunk.cleaningup();
                            return;
                        }
                        Log.d(PromotePFDownloadExecutor.TAG, "Get Profile Photo Chunks: DONE");
                        this.bNotifyUI = true;
                        ObjectLockManager.releaseLockKey(PromotePFDownloadExecutor.this.mLockKey);
                        try {
                            PromotePFDownloadExecutor.this.mChunkstream.flush();
                            PromotePFDownloadExecutor.this.mChunkstream.close();
                        } catch (IOException e2) {
                        }
                        if (PromotePFDownloadExecutor.this.mFriendpin.compareTo(PromotePFDownloadExecutor.this.mUserpin) == 0) {
                            CatfishPhotoStorage.setTempToUserPhotoProfile(PromotePFDownloadExecutor.this.mService);
                        } else {
                            CatfishPhotoStorage.setTempToPromoteFriendPhotoProfile(PromotePFDownloadExecutor.this.mService, PromotePFDownloadExecutor.this.mFriendpin);
                        }
                        PromotePFDownloadExecutor.this.onDownloadPhotoSuccess();
                        if (PromotePFDownloadExecutor.this.mObyekOwner.compareTo(CatfishService.getUserPIN()) == 0) {
                            i = 1;
                        }
                        if (i != 0) {
                            PromotePFDownloadExecutor.this.mService.signalHasCommentonStatus();
                        } else {
                            bundle = new Bundle();
                            bundle.putInt(EnvironmentCompat.MEDIA_UNKNOWN, MessageType.BCASTIMAGESTATUS.ordinal());
                            bundle.putString("unknownowner", PromotePFDownloadExecutor.this.mObyekOwner);
                            PromotePFDownloadExecutor.this.mService.signalHasNewMessage(1, bundle);
                        }
                    } else if (downloadProfilePhotoChunk.hasFailure()) {
                        Log.d(PromotePFDownloadExecutor.TAG, "Get Profile Photo Chunks: FAIL: Reschedule");
                        if (downloadProfilePhotoChunk.chunksize > 0) {
                            PromotePFDownloadExecutor.this.mWriten = PromotePFDownloadExecutor.this.mWriten + downloadProfilePhotoChunk.chunksize;
                            if (PromotePFDownloadExecutor.this.mWriten < PromotePFDownloadExecutor.this.mPhotosize) {
                                PromotePFDownloadExecutor.this.mBytestart = PromotePFDownloadExecutor.this.mWriten;
                                PromotePFDownloadExecutor.this.mByteend = (PromotePFDownloadExecutor.this.mWriten + PromotePFDownloadExecutor.mChunkMaxSize) - 1;
                                this.mAge = System.currentTimeMillis();
                                PromotePFDownloadExecutor.this.mService.postRunnableToService(this);
                                downloadProfilePhotoChunk.cleaningup();
                                return;
                            }
                            Log.d(PromotePFDownloadExecutor.TAG, "Get Profile Photo Chunks: DONE (In Failure)");
                            this.bNotifyUI = true;
                            ObjectLockManager.releaseLockKey(PromotePFDownloadExecutor.this.mLockKey);
                            try {
                                PromotePFDownloadExecutor.this.mChunkstream.flush();
                                PromotePFDownloadExecutor.this.mChunkstream.close();
                            } catch (IOException e3) {
                            }
                            if (PromotePFDownloadExecutor.this.mObyekOwner.compareTo(CatfishService.getUserPIN()) == 0) {
                                PromotePFDownloadExecutor.this.mService.signalHasCommentonStatus();
                            } else {
                                bundle = new Bundle();
                                bundle.putInt(EnvironmentCompat.MEDIA_UNKNOWN, MessageType.BCASTIMAGESTATUS.ordinal());
                                bundle.putString("unknownowner", PromotePFDownloadExecutor.this.mObyekOwner);
                                PromotePFDownloadExecutor.this.mService.signalHasNewMessage(1, bundle);
                            }
                            downloadProfilePhotoChunk.cleaningup();
                            return;
                        }
                        PromotePFDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(PromotePFDownloadExecutor.mChunkMaxSize);
                        PromotePFDownloadExecutor.this.mServer = CatfishService.getServerHost();
                        PromotePFDownloadExecutor.this.mService.scheduleRunnableToService(this, 0);
                        downloadProfilePhotoChunk.cleaningup();
                        return;
                    } else {
                        Log.d(PromotePFDownloadExecutor.TAG, "Get Profile Photo Chunks: ERROR: DROP");
                        ObjectLockManager.releaseLockKey(PromotePFDownloadExecutor.this.mLockKey);
                        PromotePFDownloadExecutor.this.onDownloadPhotoFail();
                    }
                    try {
                        PromotePFDownloadExecutor.this.mChunkstream.flush();
                        PromotePFDownloadExecutor.this.mChunkstream.close();
                    } catch (IOException e4) {
                    }
                    PromotePFDownloadExecutor.this.mChunkbuffer = null;
                    downloadProfilePhotoChunk.cleaningup();
                    if (this.bNotifyUI && PromotePFDownloadExecutor.this.mFriendpin.compareTo(PromotePFDownloadExecutor.this.mUserpin) != 0) {
                        PromotePFDownloadExecutor.this.mService.signalHasFriendProfileUpdate(PromotePFDownloadExecutor.this.mFriendpin);
                        return;
                    }
                    return;
                }
                Log.d(PromotePFDownloadExecutor.TAG, "Media not mounted when download chunk for " + PromotePFDownloadExecutor.this.mFriendpin + ": RESCHEDULE");
                ObjectLockManager.releaseLockKey(PromotePFDownloadExecutor.this.mLockKey);
                PromotePFDownloadExecutor.this.mService.scheduleRunnableToService(this, 0);
            } else {
                Log.d(PromotePFDownloadExecutor.TAG, "GetProfilePhotoChunks: OOPS LOCK ITS NOT MINE: CANCEL");
                ObjectLockManager.releaseLockKey(PromotePFDownloadExecutor.this.mLockKey);
                try {
                    PromotePFDownloadExecutor.this.mChunkstream.flush();
                    PromotePFDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e5) {
                }
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public PromotePFDownloadExecutor(CatfishService catfishService, String str, String str2, String str3, String str4) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mFriendpin = str3;
        this.mObyekOwner = str4;
        this.mLockKey = "promotepfdownload:" + this.mFriendpin;
        this.mLockObj = String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence());
        ObjectLockManager.acquireLockKey(this.mLockKey, this.mLockObj);
        this.mAge = System.currentTimeMillis();
    }

    public void dropRunnable() {
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void onDownloadPhotoFail() {
    }

    public void onDownloadPhotoSuccess() {
    }

    public void run() {
        if (!ObjectLockManager.isLockKeyLocked(this.mLockKey)) {
            Log.e(TAG, "INCONSISTENT LOCK!!!: DROP");
        } else if (ObjectLockManager.checkLockKeyString(this.mLockKey, this.mLockObj)) {
            Log.d(TAG, "WE HAVE HELD THE LOCK: Continue...");
            if (CatfishPhotoStorage.isPhotoStorageMounted()) {
                CatfishResult userProfileInfo = this.catfishRestAPI.getUserProfileInfo(this.mServer, this.mUserpin, this.mFriendpin);
                if (userProfileInfo.hasFailure()) {
                    Log.d(TAG, "Promote Friend Photo Download: FAIL: Re schedule");
                    this.mService.scheduleRunnableToService(this, 0);
                    userProfileInfo.cleaningup();
                    return;
                } else if (userProfileInfo.hasSuccess()) {
                    this.mPhotosize = userProfileInfo.photosize;
                    this.mByteend = mChunkMaxSize - 1;
                    try {
                        if (this.mFriendpin.compareTo(this.mUserpin) == 0) {
                            this.mChunkstream = new FileOutputStream(CatfishPhotoStorage.getUserProfilePhotoFileTemp(this.mService));
                        } else {
                            this.mChunkstream = new FileOutputStream(CatfishPhotoStorage.getPromoteFriendProfilePhotoFileTemp(this.mService, this.mFriendpin));
                        }
                        this.mService.postRunnableToService(new GetProfilePhotoChunks());
                        return;
                    } catch (FileNotFoundException e) {
                        Log.d(TAG, "Friend Photo Download: " + e.toString());
                        ObjectLockManager.releaseLockKey(this.mLockKey);
                        try {
                            this.mChunkstream.flush();
                            this.mChunkstream.close();
                            return;
                        } catch (Exception e2) {
                            return;
                        }
                    } catch (Exception e3) {
                        ObjectLockManager.releaseLockKey(this.mLockKey);
                        try {
                            this.mChunkstream.flush();
                            this.mChunkstream.close();
                            return;
                        } catch (Exception e4) {
                            return;
                        }
                    }
                } else {
                    Log.d(TAG, "Promote Friend Photo Download: ERROR: DROP");
                    ObjectLockManager.releaseLockKey(this.mLockKey);
                    userProfileInfo.cleaningup();
                    return;
                }
            }
            Log.d(TAG, "Promote Friend Photo Download:Media Storage is NOT MOUNTED: ABORT !!!");
            ObjectLockManager.releaseLockKey(this.mLockKey);
        } else {
            Log.d(TAG, "OOPS LOCK ITS NOT MINE: CANCEL");
            ObjectLockManager.releaseLockKey(this.mLockKey);
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

package com.catfiz.service;

import android.content.Intent;
import android.os.Bundle;
import android.os.Environment;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.Log;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class VoiceBcastDLoadExecutor implements IDropableRunnable, Runnable {
    private static final String TAG = "VoiceBcastDLoadExecutor";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    public static final String mParentPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ);
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = 0;
    private int mByteend = 0;
    private int mBytestart = 0;
    private byte[] mChunkbuffer = null;
    private FileOutputStream mChunkstream = null;
    private File mDataFile = null;
    private int mDatasize = 0;
    private String mMessage = null;
    private long mObjSequence = 0;
    private String mSenderpin = null;
    private long mSequence = 0;
    private String mServer = null;
    private CatfishService mService = null;
    private String mUserpin = null;
    private String mVoicePath = null;
    private int mWriten = 0;
    public int scheduleNum = 0;

    class GetDataStorageChunks implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private GetDataStorageChunks() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            Log.d(VoiceBcastDLoadExecutor.TAG, "Get byte range: bs=" + String.valueOf(VoiceBcastDLoadExecutor.this.mBytestart) + ", " + "be=" + String.valueOf(VoiceBcastDLoadExecutor.this.mByteend) + ", " + "size=" + String.valueOf(VoiceBcastDLoadExecutor.this.mDatasize) + ", " + "mWriten=" + String.valueOf(VoiceBcastDLoadExecutor.this.mWriten));
            CatfishResult downloadDataChunk = this.catfishRestAPI.downloadDataChunk(VoiceBcastDLoadExecutor.this.mServer, VoiceBcastDLoadExecutor.this.mUserpin, VoiceBcastDLoadExecutor.this.mSenderpin, VoiceBcastDLoadExecutor.this.mObjSequence, VoiceBcastDLoadExecutor.this.mBytestart, VoiceBcastDLoadExecutor.this.mByteend, VoiceBcastDLoadExecutor.this.mChunkstream);
            Log.d(VoiceBcastDLoadExecutor.TAG, "Chunksize: " + String.valueOf(downloadDataChunk.chunksize));
            if (downloadDataChunk.hasSuccess()) {
                this.mAge = System.currentTimeMillis();
                if (downloadDataChunk.chunksize > 0) {
                    VoiceBcastDLoadExecutor.this.mWriten = VoiceBcastDLoadExecutor.this.mWriten + downloadDataChunk.chunksize;
                }
                if (VoiceBcastDLoadExecutor.this.mWriten < VoiceBcastDLoadExecutor.this.mDatasize) {
                    VoiceBcastDLoadExecutor.mChunkMaxSize = CatfishRESTAPI.growChunkSize(VoiceBcastDLoadExecutor.mChunkMaxSize);
                    VoiceBcastDLoadExecutor.this.mBytestart = VoiceBcastDLoadExecutor.this.mWriten;
                    VoiceBcastDLoadExecutor.this.mByteend = (VoiceBcastDLoadExecutor.this.mBytestart + VoiceBcastDLoadExecutor.mChunkMaxSize) - 1;
                    VoiceBcastDLoadExecutor.this.mService.postToServiceHandler(this, 2);
                    downloadDataChunk.cleaningup();
                    return;
                }
                Log.d(VoiceBcastDLoadExecutor.TAG, "VBCAST RECEIVE: Get Data Chunk: DONE");
                VoiceBcastDLoadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDLUpdateDB());
            } else if (downloadDataChunk.hasFailure()) {
                Log.d(VoiceBcastDLoadExecutor.TAG, "VBCAST RECEIVE: Get Data Chunk: FAIL: Reschedule");
                if (downloadDataChunk.chunksize > 0) {
                    this.mAge = System.currentTimeMillis();
                    VoiceBcastDLoadExecutor.this.mWriten = VoiceBcastDLoadExecutor.this.mWriten + downloadDataChunk.chunksize;
                    if (VoiceBcastDLoadExecutor.this.mWriten < VoiceBcastDLoadExecutor.this.mDatasize) {
                        VoiceBcastDLoadExecutor.this.mBytestart = VoiceBcastDLoadExecutor.this.mWriten;
                        VoiceBcastDLoadExecutor.this.mByteend = (VoiceBcastDLoadExecutor.this.mWriten + VoiceBcastDLoadExecutor.mChunkMaxSize) - 1;
                        VoiceBcastDLoadExecutor.this.mService.postToServiceHandler(this, 2);
                        downloadDataChunk.cleaningup();
                        return;
                    }
                    Log.d(VoiceBcastDLoadExecutor.TAG, "VBCAST RECEIVE (In FAILURE): Get Data Chunk: DONE");
                    VoiceBcastDLoadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDLUpdateDB());
                    try {
                        VoiceBcastDLoadExecutor.this.mChunkstream.flush();
                        VoiceBcastDLoadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    downloadDataChunk.cleaningup();
                    return;
                }
                VoiceBcastDLoadExecutor.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(VoiceBcastDLoadExecutor.mChunkMaxSize);
                VoiceBcastDLoadExecutor.this.mServer = CatfishService.getServerHost();
                VoiceBcastDLoadExecutor.this.mService.scheduleRunnableToService(this, 2);
                downloadDataChunk.cleaningup();
                return;
            } else {
                Log.d(VoiceBcastDLoadExecutor.TAG, "VBCAST RECEIVE: Get Data Chunk: ERROR: DROP");
            }
            try {
                VoiceBcastDLoadExecutor.this.mChunkstream.flush();
                VoiceBcastDLoadExecutor.this.mChunkstream.close();
            } catch (IOException e2) {
            }
            VoiceBcastDLoadExecutor.this.mChunkbuffer = null;
            downloadDataChunk.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class VoiceBcastDLUpdateDB implements Runnable {
        private VoiceBcastDLUpdateDB() {
        }

        public void run() {
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(VoiceBcastDLoadExecutor.this.mService);
            FriendListDataStorage friendListDataStorage = new FriendListDataStorage(VoiceBcastDLoadExecutor.this.mService);
            CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
            Log.d(VoiceBcastDLoadExecutor.TAG, "mSenderpin : " + VoiceBcastDLoadExecutor.this.mSenderpin);
            catfishMessageObject.senderpin = VoiceBcastDLoadExecutor.this.mSenderpin;
            catfishMessageObject.sendername = friendListDataStorage.getFriendname(VoiceBcastDLoadExecutor.this.mSenderpin);
            catfishMessageObject.userpin = VoiceBcastDLoadExecutor.this.mUserpin;
            catfishMessageObject.messagetype = MessageType.BCASTVOICE;
            catfishMessageObject.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
            catfishMessageObject.message = VoiceBcastDLoadExecutor.this.mMessage;
            catfishMessageObject.deliverystatus = MessageDeliveryStatus.BCASTRECEIVED;
            catfishMessageObject.sequence = VoiceBcastDLoadExecutor.this.mSequence;
            catfishMessageObject.object_sequence = VoiceBcastDLoadExecutor.this.mObjSequence;
            catfishMessageObject.voicefilepath = VoiceBcastDLoadExecutor.this.mVoicePath;
            catfishDataStorage.storeSingleMessage(catfishMessageObject);
            catfishMessageObject.conversation_key = VoiceBcastDLoadExecutor.this.mSenderpin + ":" + VoiceBcastDLoadExecutor.this.mUserpin;
            VoiceBcastDLoadExecutor.this.sendBroadcastIntent(catfishMessageObject);
            Bundle bundle = new Bundle();
            bundle.putInt(VoiceBcastDLoadExecutor.this.mSenderpin, MessageType.BCASTVOICE.ordinal());
            VoiceBcastDLoadExecutor.this.mService.signalHasNewMessage(1, bundle);
        }
    }

    public VoiceBcastDLoadExecutor(CatfishService catfishService, String str, String str2, String str3, String str4, long j, long j2) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mSenderpin = str3;
        this.mMessage = str4;
        this.mSequence = j;
        this.mObjSequence = j2;
        this.mAge = System.currentTimeMillis();
        this.mVoicePath = mParentPath + "/voice/rvc" + str2 + String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence()) + ".3gp";
        this.mDataFile = new File(this.mVoicePath);
    }

    public void dropRunnable() {
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        String externalStorageState = Environment.getExternalStorageState();
        if (externalStorageState.equals("mounted")) {
            File parentFile = this.mDataFile.getParentFile();
            if (parentFile.exists() || parentFile.mkdirs()) {
                CatfishResult dataStorageInfo = this.catfishRestAPI.getDataStorageInfo(this.mServer, this.mUserpin, this.mSenderpin, this.mObjSequence);
                if (dataStorageInfo.hasFailure()) {
                    Log.d(TAG, "VBCAST RECEIVE: Get Info FAIL: Reschedule !!!");
                    this.mServer = CatfishService.getServerHost();
                    this.mService.scheduleRunnableToService(this, 2);
                    dataStorageInfo.cleaningup();
                    return;
                } else if (dataStorageInfo.hasNotFound()) {
                    Log.d(TAG, "VBCAST RECEIVE: NOT FOUND TRY TO WAIT AND GET AGAIN");
                    this.mService.scheduleRunnableToService(this, 2);
                    dataStorageInfo.cleaningup();
                    return;
                } else if (!dataStorageInfo.hasSuccess()) {
                    Log.e(TAG, "VBCAST RECEIVE: ERROR: DROP !!!");
                    dataStorageInfo.cleaningup();
                    return;
                } else if (dataStorageInfo.datasize != dataStorageInfo.currentdatasize) {
                    Log.e(TAG, "VBCAST RECEIVE: INVALID DATA SIZE: DROP !!!");
                    dataStorageInfo.cleaningup();
                    return;
                } else {
                    this.mDatasize = dataStorageInfo.datasize;
                    this.mByteend = mChunkMaxSize - 1;
                    try {
                        this.mChunkstream = new FileOutputStream(this.mDataFile);
                        this.mService.postToServiceHandler(new GetDataStorageChunks(), 2);
                        return;
                    } catch (FileNotFoundException e) {
                        Log.e(TAG, "VBCAST RECEIVE: " + e.toString());
                        return;
                    }
                }
            }
            Log.e(TAG, "VBCAST RECEIVE: Path to file could not be created.");
            return;
        }
        Log.e(TAG, "VBCAST RECEIVE: media not mounted in is state: " + externalStorageState + ":DROP !!!");
    }

    public void sendBroadcastIntent(CatfishMessageObject catfishMessageObject) {
        Intent intent = new Intent();
        String str = catfishMessageObject.userpin + ":" + catfishMessageObject.senderpin;
        intent.putExtra(TaskDataStorage.SENDERPIN, catfishMessageObject.senderpin);
        intent.putExtra(ServerMessageDataStorage.SENDERNAME, catfishMessageObject.sendername);
        intent.putExtra("conversation_key", str);
        intent.putExtra("image_path", catfishMessageObject.image_path);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, catfishMessageObject.sequence);
        intent.putExtra("imagethumb_uri", catfishMessageObject.imagethumb_uri);
        intent.putExtra(ServerMessageDataStorage.VOICEFILEPATH, catfishMessageObject.voicefilepath);
        intent.putExtra("datafile_path", catfishMessageObject.datafile_path);
        intent.putExtra(ServerMessageDataStorage.MESSAGE, catfishMessageObject.message);
        intent.putExtra(TaskDataStorage.MESSAGETYPE, catfishMessageObject.messagetype.ordinal());
        intent.putExtra("rcvtimestamp", catfishMessageObject.rcvtimestamp);
        intent.putExtra("object_owner", catfishMessageObject.object_owner);
        intent.putExtra("object_sequence", catfishMessageObject.object_sequence);
        intent.setAction(BroadcastIntents.ACTION_CHAT_MEDIA);
        this.mService.sendBroadcast(intent);
        Log.e(TAG, "SEND BROADCAST MEDIA FROM CHAT : VOICE");
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

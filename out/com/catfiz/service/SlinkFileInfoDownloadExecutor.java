package com.catfiz.service;

import android.os.Environment;
import com.catfiz.media.StorageDir;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.uidbexec.CUIDBSaveFizzlinkDlChace;
import com.catfiz.util.Log;
import com.catfiz.util.ObjectLockManager;
import com.catfiz.util.Utils;
import java.io.File;
import org.json.JSONObject;

public class SlinkFileInfoDownloadExecutor implements IDropableRunnable, Runnable {
    private static final String TAG = "SlinkFileInfoDownloadExecutor";
    public static final String mParentPath = StorageDir.getMediaDir(8);
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = 0;
    private ICatfishClientInterface mClient;
    private File mDataFile = null;
    private String mDataPath = null;
    private int mDatasize = 0;
    private String mFileName = null;
    public String mLockKey = null;
    public String mLockObj = null;
    private String mSenderName = null;
    private String mSenderPin = null;
    private String mServer = null;
    private CatfishService mService = null;
    private String mSlink = null;
    private String mUserpin = null;
    public int scheduleNum = 0;

    class SlinkInfoResponseExecutor implements Runnable {
        private ICatfishClientInterface mClient;
        private String[] mDataInfo;
        private String mDataName;
        private String mDataPath;
        private int mDataSize;

        public SlinkInfoResponseExecutor(ICatfishClientInterface iCatfishClientInterface, String str, String str2, int i, String[] strArr) {
            this.mDataName = str;
            this.mDataPath = str2;
            this.mDataSize = i;
            this.mDataInfo = strArr;
            this.mClient = iCatfishClientInterface;
        }

        public void run() {
            if (this.mClient != null && !this.mClient.isFinish()) {
                Log.d(SlinkFileInfoDownloadExecutor.TAG, "dataname:" + this.mDataName + ", size:" + this.mDataSize);
                this.mClient.onGetSlinkInfoResult(this.mDataName, this.mDataPath, this.mDataSize, this.mDataInfo);
                this.mClient = null;
            }
        }
    }

    public SlinkFileInfoDownloadExecutor(CatfishService catfishService, String str, String str2, String str3, ICatfishClientInterface iCatfishClientInterface) {
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mSlink = str3;
        this.mClient = iCatfishClientInterface;
        this.mLockKey = this.mSlink;
        this.mLockObj = String.valueOf(CatfishRESTAPI.uniqueMonotonicSequence());
        ObjectLockManager.acquireLockKey(this.mLockKey, this.mLockObj);
        this.mAge = System.currentTimeMillis();
    }

    public void dropRunnable() {
        ObjectLockManager.releaseLockKey(this.mLockKey);
    }

    public long getAge() {
        return this.mAge;
    }

    public String getMsgFromJson(String str, String str2) {
        String str3 = null;
        if (!(str == null || str2 == null)) {
            try {
                JSONObject jSONObject = new JSONObject(str);
                if (jSONObject.has(str2)) {
                    str3 = jSONObject.getString(str2);
                }
            } catch (Exception e) {
                Log.e(TAG, "Error: " + e.toString());
            }
        }
        return str3;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    protected void postResponse(Runnable runnable) {
        CatfishService serviceInstance = CatfishService.getServiceInstance();
        if (serviceInstance != null) {
            serviceInstance.postToMainHandler(runnable);
        }
    }

    public void run() {
        if (!ObjectLockManager.isLockKeyLocked(this.mLockKey)) {
            Log.e(TAG, "SLINKINFO: INCONSISTENT LOCK!!!: DROP");
        } else if (ObjectLockManager.checkLockKeyString(this.mLockKey, this.mLockObj)) {
            Log.d(TAG, "SLINKINFO: WE HAVE HELD THE LOCK: Continue...");
            CatfishResult slinkInfo = this.catfishRestAPI.getSlinkInfo(this.mUserpin, this.mSlink);
            if (slinkInfo.hasFailure()) {
                Log.d(TAG, "SLINKINFO: Get Slink Info FAIL: Reschedule !!!");
                this.mService.scheduleRunnableToService(this, 2);
                slinkInfo.cleaningup();
            } else if (slinkInfo.hasNotFound()) {
                Log.d(TAG, "SLINKINFO: NOT FOUND: DROP !!!");
                ObjectLockManager.releaseLockKey(this.mLockKey);
                postResponse(new SlinkInfoResponseExecutor(this.mClient, null, null, 0, null));
                slinkInfo.cleaningup();
            } else if (!slinkInfo.hasSuccess()) {
                Log.e(TAG, "SLINKINFO: ERROR: DROP !!!");
                ObjectLockManager.releaseLockKey(this.mLockKey);
                postResponse(new SlinkInfoResponseExecutor(this.mClient, null, null, 0, null));
                slinkInfo.cleaningup();
            } else if (slinkInfo.datasize != slinkInfo.currentdatasize) {
                Log.e(TAG, "SLINKINFO: INVALID DATA SIZE: DROP !!! (USER COULD TRY AGAIN)");
                ObjectLockManager.releaseLockKey(this.mLockKey);
                postResponse(new SlinkInfoResponseExecutor(this.mClient, null, null, 0, null));
                slinkInfo.cleaningup();
            } else {
                this.mFileName = slinkInfo.obyek_name;
                if (this.mFileName == null) {
                    this.mFileName = "file_unkown";
                }
                this.mFileName = Utils.buildFileName(this.mFileName, slinkInfo.mime_type);
                this.mSenderPin = slinkInfo.userpin;
                this.mSenderName = slinkInfo.username;
                this.mDatasize = slinkInfo.datasize;
                this.mDataPath = mParentPath + this.mFileName;
                this.mDataFile = new File(this.mDataPath);
                Log.d(TAG, "slink data path: " + this.mDataPath);
                String externalStorageState = Environment.getExternalStorageState();
                if (externalStorageState.equals("mounted")) {
                    File parentFile = this.mDataFile.getParentFile();
                    if (parentFile.exists() || parentFile.mkdirs()) {
                        postResponse(new SlinkInfoResponseExecutor(this.mClient, this.mFileName, this.mDataPath, this.mDatasize, new String[]{String.valueOf(slinkInfo.dataType), slinkInfo.desciption, this.mSenderName, this.mSenderPin}));
                        CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
                        catfishMessageObject.slink = this.mSlink;
                        catfishMessageObject.datafile_path = this.mDataPath;
                        catfishMessageObject.datasize = this.mDatasize;
                        catfishMessageObject.filename = this.mFileName;
                        catfishMessageObject.sendername = this.mSenderName;
                        catfishMessageObject.senderpin = this.mSenderPin;
                        catfishMessageObject.desc = slinkInfo.desciption;
                        catfishMessageObject.datatype = slinkInfo.dataType;
                        catfishMessageObject.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                        this.mService.postToDBHandler(new CUIDBSaveFizzlinkDlChace(catfishMessageObject));
                        ObjectLockManager.releaseLockKey(this.mLockKey);
                        if (getMsgFromJson(slinkInfo.desciption, "objsequencethumb") != null) {
                            Log.d(TAG, "!@@@ objsequencethumb:" + Long.parseLong(getMsgFromJson(slinkInfo.desciption, "objsequencethumb")) + " ownerpin:" + this.mSenderPin);
                            this.mService.postToServiceHandler(new SlinkThumbDownloadExecutor(this.mService, this.mServer, this.mUserpin, this.mSenderPin, this.mClient, Long.parseLong(getMsgFromJson(slinkInfo.desciption, "objsequencethumb")), this.mSlink, this.mFileName), 2);
                        } else {
                            Log.d(TAG, "-- no thumb objsequence found in desc, thumb not downloaded");
                        }
                        slinkInfo.cleaningup();
                        return;
                    }
                    Log.e(TAG, "GETSLINKDNAME: Path to file could not be created.");
                    ObjectLockManager.releaseLockKey(this.mLockKey);
                    return;
                }
                Log.e(TAG, "GETSLINKDNAME: media not mounted in is state: " + externalStorageState + ":DROP !!!");
                ObjectLockManager.releaseLockKey(this.mLockKey);
            }
        } else {
            Log.d(TAG, "SLINKINFO: OOPS LOCK ITS NOT MINE: CANCEL");
            ObjectLockManager.releaseLockKey(this.mLockKey);
        }
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

package com.catfiz.service;

import android.content.Intent;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.setting.CatfishPreferences;
import com.catfiz.svcpersistent.TaskDataStorage;
import com.catfiz.util.Log;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class VoiceBcastUploadExecutor implements Runnable {
    private static final String TAG = "VoiceBcastUploadExecutor";
    public static final int mChunkMaxSize = 262144;
    private static String mServer = null;
    private static String mUsername = null;
    private static String mUserpin = null;
    public boolean bNeedRead = true;
    public int mBytestart = 0;
    public byte[] mChunkbuffer = null;
    public int mChunksent = 0;
    public int mChunksize = 0;
    public FileInputStream mChunkstream = null;
    public File mDataFile = null;
    public int mDatasize = 0;
    private String mMessage = null;
    CatfishMessageObject mMessageObject = null;
    private long mObjSequence = 0;
    private String mRcpts = null;
    private String[] mRecipients = null;
    private long mSequence = 0;
    private CatfishService mService = null;

    class VoiceBcastDeliveryStatus implements Runnable {
        private MessageDeliveryStatus mDeliveryStatus = MessageDeliveryStatus.UNDEFINED;

        public VoiceBcastDeliveryStatus(MessageDeliveryStatus messageDeliveryStatus) {
            this.mDeliveryStatus = messageDeliveryStatus;
        }

        public void run() {
            CatfishDataStorage catfishDataStorage = new CatfishDataStorage(VoiceBcastUploadExecutor.this.mService);
            VoiceBcastUploadExecutor.this.mMessageObject.deliverystatus = this.mDeliveryStatus;
            VoiceBcastUploadExecutor.this.mMessageObject.recipients = VoiceBcastUploadExecutor.this.mRecipients;
            if (catfishDataStorage.updateBCASTSentStatus(VoiceBcastUploadExecutor.this.mMessageObject)) {
                Log.d(VoiceBcastUploadExecutor.TAG, "---VBCAST: Signaling for BCAST Response");
                VoiceBcastUploadExecutor.this.mService.signalHasBCASTResponse();
                return;
            }
            Log.e(VoiceBcastUploadExecutor.TAG, "----VBCAST: FAIL TO UPDATE DELVERY STATUS IN DB");
        }
    }

    class VoiceBcastNotifyRecipients implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private VoiceBcastNotifyRecipients() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult sendBcastMessageWType = this.catfishRestAPI.sendBcastMessageWType(VoiceBcastUploadExecutor.mServer, VoiceBcastUploadExecutor.mUserpin, VoiceBcastUploadExecutor.this.mRcpts, MessageType.BCASTVOICE.ordinal(), VoiceBcastUploadExecutor.this.mMessage, VoiceBcastUploadExecutor.this.mSequence, VoiceBcastUploadExecutor.this.mObjSequence);
            if (sendBcastMessageWType.hasSuccess()) {
                VoiceBcastUploadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDeliveryStatus(MessageDeliveryStatus.BCASTSENT));
            } else if (sendBcastMessageWType.hasFailure()) {
                Log.d(VoiceBcastUploadExecutor.TAG, "----VBCAST: BCAST NOTIFY FAILURE !!!: Re Schedule");
                VoiceBcastUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(VoiceBcastUploadExecutor.TAG, "----VBCAST: ERROR: DROP !!!");
                VoiceBcastUploadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
            }
            sendBcastMessageWType.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class VoiceBcastUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private VoiceBcastUploadChunk() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (VoiceBcastUploadExecutor.this.mChunkstream == null) {
                Log.d(VoiceBcastUploadExecutor.TAG, "----VBCAST: INVALID CHUNKSTREAM (NULL): CANCELED");
                VoiceBcastUploadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                VoiceBcastUploadExecutor.this.mChunkbuffer = null;
                return;
            }
            try {
                if (VoiceBcastUploadExecutor.this.bNeedRead) {
                    VoiceBcastUploadExecutor.this.bNeedRead = false;
                    VoiceBcastUploadExecutor.this.mChunksize = VoiceBcastUploadExecutor.this.mChunkstream.read(VoiceBcastUploadExecutor.this.mChunkbuffer, 0, VoiceBcastUploadExecutor.mChunkMaxSize);
                }
                if (VoiceBcastUploadExecutor.this.mChunksize <= 0) {
                    Log.d(VoiceBcastUploadExecutor.TAG, "----VBCAST: SENT COMPLETE");
                    if (VoiceBcastUploadExecutor.this.mMessageObject != null) {
                        VoiceBcastUploadExecutor.this.sendBroadcastIntent(VoiceBcastUploadExecutor.this.mMessageObject);
                    }
                    Log.d(VoiceBcastUploadExecutor.TAG, "----VBCAST: Post To Notify Recipients");
                    VoiceBcastUploadExecutor.this.mService.postToServiceHandler(new VoiceBcastNotifyRecipients(), 2);
                    try {
                        VoiceBcastUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    VoiceBcastUploadExecutor.this.mChunkbuffer = null;
                    return;
                }
                CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(VoiceBcastUploadExecutor.mServer, VoiceBcastUploadExecutor.mUserpin, VoiceBcastUploadExecutor.this.mObjSequence, VoiceBcastUploadExecutor.this.mDatasize, VoiceBcastUploadExecutor.this.mBytestart, VoiceBcastUploadExecutor.this.mChunksize, VoiceBcastUploadExecutor.this.mChunkbuffer);
                if (uploadDataChunk.hasSuccess()) {
                    this.mAge = System.currentTimeMillis();
                    if (uploadDataChunk.byteend == 0) {
                        Log.d(VoiceBcastUploadExecutor.TAG, "----Byte End is 0: RESEND");
                        VoiceBcastUploadExecutor.this.bNeedRead = false;
                        VoiceBcastUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        return;
                    } else if (VoiceBcastUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - VoiceBcastUploadExecutor.this.mBytestart) + 1) {
                        Log.d(VoiceBcastUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                        VoiceBcastUploadExecutor.this.mChunkbuffer = null;
                        try {
                            VoiceBcastUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e2) {
                        }
                        VoiceBcastUploadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                        uploadDataChunk.cleaningup();
                        return;
                    } else {
                        Log.d(VoiceBcastUploadExecutor.TAG, "Chunk Sent: " + String.valueOf(uploadDataChunk.byteend - VoiceBcastUploadExecutor.this.mBytestart) + " bytes: " + String.valueOf(VoiceBcastUploadExecutor.this.mBytestart) + "-" + String.valueOf(uploadDataChunk.byteend) + ": SELF RE-POST");
                        VoiceBcastUploadExecutor voiceBcastUploadExecutor = VoiceBcastUploadExecutor.this;
                        voiceBcastUploadExecutor.mChunksent += (uploadDataChunk.byteend - VoiceBcastUploadExecutor.this.mBytestart) + 1;
                        VoiceBcastUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                        VoiceBcastUploadExecutor.this.bNeedRead = true;
                        VoiceBcastUploadExecutor.this.mService.postToServiceHandler(this, 2);
                    }
                } else if (uploadDataChunk.hasFailure()) {
                    Log.d(VoiceBcastUploadExecutor.TAG, "----VBCAST: FAILURE !!!: Re Schedule");
                    VoiceBcastUploadExecutor.mServer = CatfishService.getServerHost();
                    VoiceBcastUploadExecutor.this.bNeedRead = false;
                    VoiceBcastUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                } else {
                    Log.e(VoiceBcastUploadExecutor.TAG, "----VBCAST: ERROR: DROP");
                    VoiceBcastUploadExecutor.this.mChunkbuffer = null;
                    try {
                        VoiceBcastUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e3) {
                    }
                    VoiceBcastUploadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
                }
                uploadDataChunk.cleaningup();
            } catch (IOException e4) {
                Log.d(VoiceBcastUploadExecutor.TAG, "----VBCAST: FAIL TO READ STREAM: CANCELED");
                VoiceBcastUploadExecutor.this.mChunkbuffer = null;
                VoiceBcastUploadExecutor.this.mService.postRunnableToDbThread(new VoiceBcastDeliveryStatus(MessageDeliveryStatus.BCASTFAIL));
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public VoiceBcastUploadExecutor(CatfishService catfishService, String str, String str2, String[] strArr, String str3, String str4) {
        CatfishPreferences catfishPreferences = CatfishService.getCatfishPreferences();
        this.mService = catfishService;
        mServer = str;
        mUserpin = str2;
        mUsername = catfishPreferences.getString(CatfishService.USERNAME_PREF, null);
        this.mRecipients = strArr;
        this.mMessage = str4;
        this.mSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mObjSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mDataFile = new File(str3);
        this.mDatasize = Long.valueOf(this.mDataFile.length()).intValue();
        try {
            this.mChunkstream = new FileInputStream(this.mDataFile);
            this.mChunkbuffer = new byte[mChunkMaxSize];
        } catch (FileNotFoundException e) {
            Log.e(TAG, "----VBCAST FAIL TO ACCESS DATA FILE: " + e.toString());
            this.mChunkstream = null;
        }
    }

    private void sendBroadcastIntent(CatfishMessageObject catfishMessageObject) {
        String[] split = this.mRcpts.split(",");
        Log.d(TAG, "prepare for sending broadcast to gallery with recipients : " + this.mRcpts);
        Log.d(TAG, "recipients size : " + split.length);
        for (int i = 0; i < split.length; i++) {
            Intent intent = new Intent();
            Log.d(TAG, "sending broadcast to gallery with recipient : " + split[i] + "sequence : " + catfishMessageObject.sequence);
            String str = catfishMessageObject.userpin + ":" + split[i];
            intent.putExtra(TaskDataStorage.SENDERPIN, catfishMessageObject.userpin);
            intent.putExtra(ServerMessageDataStorage.SENDERNAME, catfishMessageObject.username);
            intent.putExtra("conversation_key", str);
            intent.putExtra("image_path", catfishMessageObject.image_path);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, catfishMessageObject.sequence);
            intent.putExtra("imagethumb_uri", catfishMessageObject.imagethumb_uri);
            intent.putExtra(ServerMessageDataStorage.VOICEFILEPATH, catfishMessageObject.voicefilepath);
            intent.putExtra("datafile_path", catfishMessageObject.datafile_path);
            intent.putExtra(ServerMessageDataStorage.MESSAGE, catfishMessageObject.message);
            intent.putExtra(TaskDataStorage.MESSAGETYPE, catfishMessageObject.messagetype.ordinal());
            intent.putExtra("rcvtimestamp", catfishMessageObject.rcvtimestamp + ((long) i));
            intent.putExtra("object_owner", catfishMessageObject.object_owner);
            intent.putExtra("object_sequence", catfishMessageObject.object_sequence);
            intent.setAction(BroadcastIntents.ACTION_CHAT_MEDIA);
            this.mService.sendBroadcast(intent);
        }
        Log.e(TAG, "SEND BROADCAST MEDIA FROM CHAT : VOICE");
    }

    public void run() {
        Log.d(TAG, "----VBCAST: Put Message in recipients record: " + this.mDataFile.getAbsolutePath());
        CatfishDataStorage catfishDataStorage = new CatfishDataStorage(this.mService);
        FriendListDataStorage friendListDataStorage = new FriendListDataStorage(this.mService);
        this.mMessageObject = new CatfishMessageObject();
        this.mMessageObject.messagetype = MessageType.BCASTVOICE;
        this.mMessageObject.userpin = mUserpin;
        this.mMessageObject.username = mUsername;
        this.mMessageObject.message = this.mMessage;
        this.mMessageObject.sequence = this.mSequence;
        this.mMessageObject.object_sequence = this.mObjSequence;
        this.mMessageObject.voicefilepath = this.mDataFile.getAbsolutePath();
        this.mMessageObject.deliverystatus = MessageDeliveryStatus.BCASTQUEUE;
        this.mRcpts = new String();
        int length = this.mRecipients.length;
        int i = length - 1;
        catfishDataStorage.beginTransaction();
        int i2 = 0;
        int i3 = i;
        while (i2 < length) {
            try {
                this.mMessageObject.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
                this.mMessageObject.recipient = this.mRecipients[i2];
                catfishDataStorage.storeUserMessage(this.mMessageObject);
                friendListDataStorage.updateActivityCount(this.mMessageObject.recipient, 600);
                friendListDataStorage.setFriendLastActivity(this.mMessageObject.recipient, this.mMessageObject.rcvtimestamp);
                friendListDataStorage.updateLastChatActivity(this.mMessageObject.recipient, this.mMessageObject.rcvtimestamp);
                friendListDataStorage.setLastMessage(true, this.mMessageObject.recipient, this.mMessageObject.sequence, this.mMessageObject.message, this.mMessageObject.deliverystatus.ordinal(), this.mMessageObject.messagetype.ordinal(), this.mMessageObject.voicefilepath);
                if (i3 > 0) {
                    this.mRcpts += this.mRecipients[i2] + ",";
                } else {
                    this.mRcpts += this.mRecipients[i2];
                }
                i2++;
                i3--;
            } catch (Throwable th) {
                catfishDataStorage.endTransaction();
            }
        }
        catfishDataStorage.setTransactionSuccessful();
        catfishDataStorage.endTransaction();
        Log.d(TAG, "----VBCAST: Put Message in recipients record: DONE");
        Log.d(TAG, "----VBCAST: Post To Service: Upload DATA Chunks");
        this.mService.postToServiceHandler(new VoiceBcastUploadChunk(), 2);
    }
}

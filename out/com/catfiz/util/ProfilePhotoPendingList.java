package com.catfiz.util;

import com.catfiz.service.CatfishService;
import com.catfiz.service.PPFDownloadExecutor;
import java.util.ArrayList;
import java.util.HashMap;

public class ProfilePhotoPendingList {
    private static final String TAG = "ProfilePhotoPendingList";
    private volatile ArrayList mPendingTask = new ArrayList();
    private volatile ArrayList mProfilePhotoPendingPIN = new ArrayList();
    private volatile HashMap mTaskTracker = new HashMap();

    class ProfilePhotoPendingTask {
        private static final int mMaxExecuting = 2;
        private static final long mTaskDuration = 300000;
        public int mExecuteCount = 0;
        public String mPIN;
        public long mTaskDeadline = (System.currentTimeMillis() + mTaskDuration);

        public ProfilePhotoPendingTask(String str) {
            this.mPIN = str;
        }

        public boolean isAllowToPush() {
            return this.mExecuteCount < mMaxExecuting;
        }

        public boolean isTimeToExecute() {
            return System.currentTimeMillis() >= this.mTaskDeadline;
        }

        public void setToNextDeadline() {
            this.mTaskDeadline = System.currentTimeMillis() + mTaskDuration;
        }
    }

    private PPFDownloadExecutor createPPFDownloadExecutor(CatfishService catfishService, String str) {
        return new PPFDownloadExecutor(catfishService, CatfishService.getServerHost(), CatfishService.getUserPIN(), str, true);
    }

    private ProfilePhotoPendingTask getPendingTask(String str) {
        if (this.mTaskTracker.containsKey(str)) {
            ProfilePhotoPendingTask profilePhotoPendingTask = (ProfilePhotoPendingTask) this.mTaskTracker.get(str);
            profilePhotoPendingTask.mExecuteCount++;
            profilePhotoPendingTask.setToNextDeadline();
            Log.d(TAG, "Task " + str + " is EXISTS in tracker.");
            return profilePhotoPendingTask;
        }
        profilePhotoPendingTask = new ProfilePhotoPendingTask(str);
        this.mTaskTracker.put(str, profilePhotoPendingTask);
        Log.d(TAG, "Task " + str + " is CREATED.");
        return profilePhotoPendingTask;
    }

    private String popPending() {
        if (isEmpty()) {
            Log.d(TAG, "No pending task in list");
            return null;
        }
        String str = (String) this.mProfilePhotoPendingPIN.get(0);
        if (((ProfilePhotoPendingTask) this.mPendingTask.get(0)).isTimeToExecute()) {
            this.mPendingTask.remove(0);
            this.mProfilePhotoPendingPIN.remove(0);
            Log.d(TAG, "Pop from pending list: " + str);
            return str;
        }
        Log.d(TAG, "No pending task in deadline: count=" + this.mPendingTask.size());
        return null;
    }

    public synchronized void executeNextPending(CatfishService catfishService) {
        String popPending = popPending();
        if (popPending != null) {
            Log.d(TAG, "Excute by Downloader: Download photo profile for " + popPending);
            catfishService.postRunnableToService(createPPFDownloadExecutor(catfishService, popPending), 2);
        }
    }

    public synchronized void executePendingByService(CatfishService catfishService) {
        String popPending = popPending();
        if (popPending != null) {
            Log.d(TAG, "Excute by Service: Download photo profile for " + popPending);
            catfishService.postToServiceHandler(createPPFDownloadExecutor(catfishService, popPending), 2);
        }
    }

    public synchronized int getCount() {
        return this.mProfilePhotoPendingPIN.size();
    }

    public synchronized boolean isEmpty() {
        return this.mProfilePhotoPendingPIN.size() <= 0;
    }

    public synchronized boolean isPending(String str) {
        return this.mProfilePhotoPendingPIN.contains(str);
    }

    public synchronized void pushFrontPending(String str, long j) {
        if (this.mProfilePhotoPendingPIN.contains(str)) {
            Log.d(TAG, "Already in pending list: " + str);
        } else {
            ProfilePhotoPendingTask pendingTask = getPendingTask(str);
            if (pendingTask.isAllowToPush()) {
                if (j == 0) {
                    pendingTask.mTaskDeadline = System.currentTimeMillis();
                } else {
                    pendingTask.mTaskDeadline = j;
                }
                this.mPendingTask.add(0, pendingTask);
                this.mProfilePhotoPendingPIN.add(0, str);
                Log.d(TAG, "Push to pending list: " + str);
            } else {
                Log.d(TAG, "Pending is reach maximum time: DROP: " + str);
                removePendingTask(str);
            }
        }
    }

    public synchronized void pushPending(String str) {
        if (this.mProfilePhotoPendingPIN.contains(str)) {
            Log.d(TAG, "Already in pending list: " + str);
        } else {
            ProfilePhotoPendingTask pendingTask = getPendingTask(str);
            if (pendingTask.isAllowToPush()) {
                this.mPendingTask.add(pendingTask);
                this.mProfilePhotoPendingPIN.add(str);
                Log.d(TAG, "Push to pending list: " + str);
            } else {
                Log.d(TAG, "Pending is reach maximum time: DROP: " + str);
                removePendingTask(str);
            }
        }
    }

    public synchronized void removeFromPending(String str) {
        if (this.mProfilePhotoPendingPIN.contains(str)) {
            Log.d(TAG, "Remove from pending list: " + str);
            int indexOf = this.mProfilePhotoPendingPIN.indexOf(str);
            this.mProfilePhotoPendingPIN.remove(indexOf);
            this.mPendingTask.remove(indexOf);
        }
    }

    public synchronized void removePendingTask(String str) {
        if (this.mTaskTracker.containsKey(str)) {
            this.mTaskTracker.remove(str);
        }
    }
}

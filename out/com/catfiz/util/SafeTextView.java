package com.catfiz.util;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.text.Layout;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.Spanned;
import android.text.style.StyleSpan;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.WindowManager;
import android.widget.TextView;
import android.widget.TextView.BufferType;
import com.catfiz.clickablespan.ClickableImageSpan;
import java.util.ArrayList;
import java.util.List;

public class SafeTextView extends TextView {
    private static final String TAG = "SafeTextView";
    private boolean mDiscardNextActionUp;
    private boolean mOnFallback;

    class FixingResult {
        public final boolean fixed;
        public final List spansWithSpacesAfter;
        public final List spansWithSpacesBefore;

        private FixingResult(boolean z, List list, List list2) {
            this.fixed = z;
            this.spansWithSpacesBefore = list;
            this.spansWithSpacesAfter = list2;
        }

        public static FixingResult fixed(List list, List list2) {
            return new FixingResult(true, list, list2);
        }

        public static FixingResult notFixed() {
            return new FixingResult(false, null, null);
        }
    }

    public SafeTextView(Context context) {
        super(context);
        this.mDiscardNextActionUp = false;
        this.mOnFallback = false;
        this.mOnFallback = false;
    }

    public SafeTextView(Context context, AttributeSet attributeSet) {
        super(context, attributeSet);
        this.mDiscardNextActionUp = false;
        this.mOnFallback = false;
        this.mOnFallback = false;
    }

    public SafeTextView(Context context, AttributeSet attributeSet, int i) {
        super(context, attributeSet, i);
        this.mDiscardNextActionUp = false;
        this.mOnFallback = false;
        this.mOnFallback = false;
    }

    private FixingResult addSpacesAroundSpansUntilFixed(SpannableStringBuilder spannableStringBuilder, int i, int i2) {
        int i3 = 0;
        Object[] spans = spannableStringBuilder.getSpans(0, spannableStringBuilder.length(), Object.class);
        List arrayList = new ArrayList(spans.length);
        List arrayList2 = new ArrayList(spans.length);
        int length = spans.length;
        while (i3 < length) {
            Object obj = spans[i3];
            int spanStart = spannableStringBuilder.getSpanStart(obj);
            if (isNotSpace(spannableStringBuilder, spanStart - 1)) {
                spannableStringBuilder.insert(spanStart, " ");
                arrayList.add(obj);
            }
            spanStart = spannableStringBuilder.getSpanEnd(obj);
            if (isNotSpace(spannableStringBuilder, spanStart)) {
                spannableStringBuilder.insert(spanStart, " ");
                arrayList2.add(obj);
            }
            try {
                setTextAndMeasure(spannableStringBuilder, i, i2);
                return FixingResult.fixed(arrayList, arrayList2);
            } catch (IndexOutOfBoundsException e) {
                i3++;
            }
        }
        Log.d(TAG, "Could not fix the Spanned by adding spaces around spans");
        return FixingResult.notFixed();
    }

    private void fallbackToString(int i, int i2) {
        Log.d(TAG, "Fallback to unspanned text");
        this.mOnFallback = true;
        setTextAndMeasure(getText().toString(), i, i2);
    }

    private void fixOnMeasure(int i, int i2) {
        CharSequence text = getText();
        if ((text instanceof Spanned) || (text instanceof SpannableString)) {
            try {
                fixSpannedWithSpaces(new SpannableStringBuilder(text), i, i2);
                return;
            } catch (IndexOutOfBoundsException e) {
                Log.d(TAG, "fixSpannedWithSpaces FAIL, try to fallback to text...");
                fallbackToString(i, i2);
                return;
            }
        }
        Log.d(TAG, "The text isn't a Spanned");
        fallbackToString(i, i2);
    }

    private void fixSpannedWithSpaces(SpannableStringBuilder spannableStringBuilder, int i, int i2) {
        System.currentTimeMillis();
        FixingResult addSpacesAroundSpansUntilFixed = addSpacesAroundSpansUntilFixed(spannableStringBuilder, i, i2);
        if (addSpacesAroundSpansUntilFixed.fixed) {
            removeUnneededSpaces(i, i2, spannableStringBuilder, addSpacesAroundSpansUntilFixed);
        } else {
            fallbackToString(i, i2);
        }
    }

    private Rect getRectClickedSpan(double d, double d2) {
        double lineRight;
        Rect rect;
        Rect rect2 = new Rect();
        Layout layout = getLayout();
        double primaryHorizontal = (double) layout.getPrimaryHorizontal((int) d);
        double primaryHorizontal2 = (double) layout.getPrimaryHorizontal((int) d2);
        int lineForOffset = layout.getLineForOffset((int) d);
        int lineForOffset2 = layout.getLineForOffset((int) d2);
        Object obj = lineForOffset != lineForOffset2 ? 1 : null;
        layout.getLineBounds(lineForOffset, rect2);
        int[] iArr = new int[]{0, 0};
        getLocationOnScreen(iArr);
        double scrollY = (double) ((iArr[1] - getScrollY()) + getCompoundPaddingTop());
        rect2.top = (int) (((double) rect2.top) + scrollY);
        rect2.bottom = (int) (((double) rect2.bottom) + scrollY);
        if (obj != null) {
            if ((rect2.top > ((WindowManager) getContext().getSystemService("window")).getDefaultDisplay().getHeight() - rect2.bottom ? 1 : null) != null) {
                lineRight = (double) layout.getLineRight(lineForOffset);
                primaryHorizontal2 = primaryHorizontal;
                rect = rect2;
            } else {
                rect = new Rect();
                layout.getLineBounds(lineForOffset2, rect);
                rect.top = (int) (((double) rect.top) + scrollY);
                rect.bottom = (int) (((double) rect.bottom) + scrollY);
                double d3 = primaryHorizontal2;
                primaryHorizontal2 = (double) layout.getLineLeft(lineForOffset2);
                lineRight = d3;
            }
        } else {
            lineRight = primaryHorizontal2;
            primaryHorizontal2 = primaryHorizontal;
            rect = rect2;
        }
        rect.left = (int) (((double) rect.left) + (((((double) iArr[0]) + primaryHorizontal2) + ((double) getCompoundPaddingLeft())) - ((double) getScrollX())));
        rect.right = (int) ((lineRight + ((double) rect.left)) - primaryHorizontal2);
        rect.top += 3;
        return rect;
    }

    private boolean isNotSpace(CharSequence charSequence, int i) {
        return i < 0 || charSequence.charAt(i) != ' ';
    }

    private void removeUnneededSpaces(int i, int i2, SpannableStringBuilder spannableStringBuilder, FixingResult fixingResult) {
        for (Object spanEnd : fixingResult.spansWithSpacesAfter) {
            int spanEnd2 = spannableStringBuilder.getSpanEnd(spanEnd);
            spannableStringBuilder.delete(spanEnd2, spanEnd2 + 1);
            try {
                setTextAndMeasure(spannableStringBuilder, i, i2);
            } catch (IndexOutOfBoundsException e) {
                spannableStringBuilder.insert(spanEnd2, " ");
            }
        }
        Object obj = 1;
        for (Object obj2 : fixingResult.spansWithSpacesBefore) {
            int spanStart = spannableStringBuilder.getSpanStart(obj2);
            spannableStringBuilder.delete(spanStart - 1, spanStart);
            try {
                setTextAndMeasure(spannableStringBuilder, i, i2);
                obj2 = null;
            } catch (IndexOutOfBoundsException e2) {
                spannableStringBuilder.insert(spanStart - 1, " ");
                obj2 = 1;
            }
        }
        if (obj2 != null) {
            setText(spannableStringBuilder);
            super.measure(i, i2);
        }
    }

    private void setTextAndMeasure(CharSequence charSequence, int i, int i2) {
        setText(charSequence);
        super.measure(i, i2);
    }

    public void onDraw(Canvas canvas) {
        try {
            super.onDraw(canvas);
        } catch (Exception e) {
        }
    }

    public void onMeasure(int i, int i2) {
        try {
            super.onMeasure(i, i2);
        } catch (IndexOutOfBoundsException e) {
            Log.d(TAG, "onMeasure FAIL, try to handling...");
            if (!this.mOnFallback && i != 0 && i2 != 0) {
                fixOnMeasure(i, i2);
            }
        } catch (Exception e2) {
        }
    }

    public boolean onTouchEvent(MotionEvent motionEvent) {
        int actionMasked = motionEvent.getActionMasked();
        boolean onTouchEvent = super.onTouchEvent(motionEvent);
        if (this.mDiscardNextActionUp && actionMasked == 1) {
            this.mDiscardNextActionUp = false;
            return onTouchEvent;
        }
        if (actionMasked == 1 || actionMasked == 0) {
            Layout layout = getLayout();
            if (isEnabled() && (getText() instanceof Spanned) && layout != null) {
                int i;
                int scrollX = getScrollX() + (((int) motionEvent.getX()) - getTotalPaddingLeft());
                int y = (((int) motionEvent.getY()) - getTotalPaddingTop()) + getScrollY();
                int offsetForHorizontal = layout.getOffsetForHorizontal(layout.getLineForVertical(y), (float) scrollX);
                ClickableImageSpan[] clickableImageSpanArr = (ClickableImageSpan[]) ((Spanned) getText()).getSpans(offsetForHorizontal, offsetForHorizontal, ClickableImageSpan.class);
                if (clickableImageSpanArr.length > 0) {
                    Spanned spanned = (Spanned) getText();
                    Rect rectClickedSpan = getRectClickedSpan((double) spanned.getSpanStart(clickableImageSpanArr[0]), (double) spanned.getSpanEnd(clickableImageSpanArr[0]));
                    if (rectClickedSpan.left > rectClickedSpan.right) {
                        Log.d(TAG, "Rectangle coordinat is right to left orientation: swap");
                        int i2 = rectClickedSpan.left;
                        rectClickedSpan.left = rectClickedSpan.right;
                        rectClickedSpan.right = i2;
                    }
                    int[] iArr = new int[2];
                    getLocationOnScreen(iArr);
                    if (rectClickedSpan.contains(scrollX + iArr[0], y + iArr[1])) {
                        if (actionMasked == 1) {
                            clickableImageSpanArr[0].onClick(this, rectClickedSpan);
                        }
                        i = 1;
                        if (i != 0) {
                            return true;
                        }
                    }
                }
                boolean z = false;
                if (i != 0) {
                    return true;
                }
            }
        }
        return onTouchEvent;
    }

    public boolean performLongClick() {
        boolean performLongClick = super.performLongClick();
        if (performLongClick) {
            this.mDiscardNextActionUp = true;
        }
        return performLongClick;
    }

    public void setGravity(int i) {
        try {
            super.setGravity(i);
        } catch (IndexOutOfBoundsException e) {
            setText(getText().toString());
            super.setGravity(i);
        }
    }

    public void setText(CharSequence charSequence, BufferType bufferType) {
        try {
            super.setText(charSequence, bufferType);
        } catch (IndexOutOfBoundsException e) {
            Log.d(TAG, "setText FAIL. Try to handle.");
            if (!(charSequence instanceof Spanned) && !(charSequence instanceof SpannableString)) {
                return;
            }
            CharSequence spannableStringBuilder;
            StyleSpan[] styleSpanArr;
            if (charSequence instanceof SpannableString) {
                SpannableString spannableString = (SpannableString) charSequence;
                spannableStringBuilder = new SpannableStringBuilder(spannableString);
                styleSpanArr = (StyleSpan[]) spannableString.getSpans(0, spannableString.length(), StyleSpan.class);
                if (styleSpanArr.length > 1) {
                    spannableStringBuilder.removeSpan(styleSpanArr[0]);
                }
                try {
                    super.setText(spannableStringBuilder, bufferType);
                } catch (IndexOutOfBoundsException e2) {
                    Log.e(TAG, "SafeText FAIL(1) to handle android BUG");
                    e2.printStackTrace();
                }
            } else if (charSequence instanceof SpannableStringBuilder) {
                spannableStringBuilder = new SpannableStringBuilder(charSequence);
                styleSpanArr = (StyleSpan[]) spannableStringBuilder.getSpans(0, spannableStringBuilder.length(), StyleSpan.class);
                if (styleSpanArr.length > 1) {
                    spannableStringBuilder.removeSpan(styleSpanArr[0]);
                }
                try {
                    super.setText(spannableStringBuilder, bufferType);
                } catch (IndexOutOfBoundsException e22) {
                    Log.e(TAG, "SafeText FAIL(2) to handle android BUG");
                    e22.printStackTrace();
                }
            }
        }
    }
}

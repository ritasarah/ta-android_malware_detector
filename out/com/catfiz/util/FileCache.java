package com.catfiz.util;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import android.util.Log;
import com.catfiz.service.FriendListDataStorage;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class FileCache implements Closeable {
    private static final String CACHE_DIR = "fileCache";
    private static FileCache mSingleton;
    private static final SimpleDateFormat sDateFormat = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
    private final File mCacheDir;
    private SQLiteDatabase mDB;

    class FileDBSQLHelper extends SQLiteOpenHelper {
        public static final String DB_NAME = "filecache.db";

        public FileDBSQLHelper(Context context) {
            super(context, DB_NAME, null, 1);
        }

        public void onCreate(SQLiteDatabase sQLiteDatabase) {
            try {
                sQLiteDatabase.execSQL("CREATE TABLE IF NOT EXISTS fileCache ( key TEXT PRIMARY KEY, filename TEXT, dateInsert INTEGER);");
            } catch (Throwable e) {
                Log.e(getClass().getName(), "Unable to create database", e);
            }
        }

        public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) {
        }
    }

    public class WriteAsync {
        protected File cacheFile;
        protected String cacheFilename;
        protected String key;
        private boolean mIsCommited = false;
        protected OutputStream os;

        public void commit() {
            FileCache.this.insertEntry(this.key, this.cacheFilename);
            this.mIsCommited = true;
        }

        public void finished() {
            if (!this.mIsCommited) {
                try {
                    this.os.close();
                } catch (Throwable e) {
                    Log.e(getClass().getName(), "cannot close failed outputstream", e);
                }
                this.cacheFile.delete();
            }
        }

        public OutputStream getOutputStream() {
            return this.os;
        }
    }

    private FileCache(Context context) {
        this.mCacheDir = new File(context.getCacheDir(), CACHE_DIR);
        if (this.mCacheDir.exists() || this.mCacheDir.mkdir()) {
            this.mDB = new FileDBSQLHelper(context).getWritableDatabase();
            return;
        }
        throw new IOException("Cannot create cache directory: " + this.mCacheDir.getAbsolutePath());
    }

    private String createCacheFilename(String str) {
        String createCacheFilename;
        Exception e;
        try {
            String sha1Hash = StringUtil.getSha1Hash(str);
            Cursor query;
            try {
                query = this.mDB.query(CACHE_DIR, new String[]{FriendListDataStorage.FILENAME}, "filename=?", new String[]{sha1Hash}, null, null, null);
                createCacheFilename = query.getCount() > 0 ? createCacheFilename(StringUtil.getSha1Hash(sha1Hash)) : sha1Hash;
                try {
                    query.close();
                } catch (Exception e2) {
                    e = e2;
                    e.printStackTrace();
                    return createCacheFilename;
                }
            } catch (Exception e3) {
                e = e3;
                createCacheFilename = sha1Hash;
                e.printStackTrace();
                return createCacheFilename;
            } catch (Throwable th) {
                query.close();
            }
        } catch (Exception e32) {
            Exception exception = e32;
            createCacheFilename = null;
            e = exception;
            e.printStackTrace();
            return createCacheFilename;
        }
        return createCacheFilename;
    }

    private File getCacheFile(String str) {
        return new File(this.mCacheDir, str);
    }

    public static FileCache getFileCache(Context context) {
        FileCache fileCache;
        synchronized (FileCache.class) {
            if (mSingleton == null) {
                mSingleton = new FileCache(context);
            }
            fileCache = mSingleton;
        }
        return fileCache;
    }

    private void insertEntry(String str, String str2) {
        ContentValues contentValues = new ContentValues();
        contentValues.put("key", str);
        contentValues.put(FriendListDataStorage.FILENAME, str2);
        contentValues.put("dateInsert", Long.valueOf(Long.valueOf(sDateFormat.format(new Date())).longValue()));
        this.mDB.replace(CACHE_DIR, null, contentValues);
    }

    public void close() {
        this.mDB.close();
    }

    public synchronized void delete(String str) {
        String cacheFilename = getCacheFilename(str);
        if (cacheFilename != null) {
            try {
                getCacheFile(cacheFilename).delete();
            } catch (Throwable th) {
                this.mDB.delete(CACHE_DIR, "key=?", new String[]{str});
            }
        }
        this.mDB.delete(CACHE_DIR, "key=?", new String[]{str});
    }

    public synchronized void deleteOldest() {
        Cursor query = this.mDB.query(CACHE_DIR, new String[]{"key"}, null, null, null, null, "dateInsert ASC");
        try {
            if (query.moveToFirst()) {
                delete(query.getString(0));
            }
            query.close();
        } catch (Throwable th) {
            query.close();
        }
    }

    public synchronized InputStream get(String str) {
        InputStream fileInputStream;
        String cacheFilename = getCacheFilename(str);
        if (cacheFilename != null) {
            File cacheFile = getCacheFile(cacheFilename);
            if (cacheFile.exists() && cacheFile.isFile() && cacheFile.canRead()) {
                try {
                    fileInputStream = new FileInputStream(cacheFile);
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                    fileInputStream = null;
                }
            } else {
                this.mDB.delete(CACHE_DIR, "key=?", new String[]{str});
            }
        }
        fileInputStream = null;
        return fileInputStream;
    }

    public String getCacheFilename(String str) {
        String str2 = null;
        if (str != null) {
            Cursor query = this.mDB.query(CACHE_DIR, new String[]{FriendListDataStorage.FILENAME}, "key=?", new String[]{str}, null, null, null);
            try {
                if (query.moveToFirst()) {
                    str2 = query.getString(0);
                }
                query.close();
            } catch (Throwable th) {
                query.close();
            }
        }
        return str2;
    }

    public synchronized File getFile(String str) {
        File cacheFile;
        String cacheFilename = getCacheFilename(str);
        if (cacheFilename != null) {
            cacheFile = getCacheFile(cacheFilename);
            if (!(cacheFile.exists() && cacheFile.isFile() && cacheFile.canRead())) {
                this.mDB.delete(CACHE_DIR, "key=?", new String[]{str});
            }
        }
        cacheFile = null;
        return cacheFile;
    }

    public int numFiles() {
        int i = -1;
        Cursor rawQuery = this.mDB.rawQuery("SELECT COUNT(*) FROM fileCache", null);
        try {
            if (rawQuery.moveToFirst()) {
                i = rawQuery.getInt(0);
            }
            rawQuery.close();
            return i;
        } catch (Throwable th) {
            rawQuery.close();
        }
    }

    public WriteAsync put(String str) {
        WriteAsync writeAsync = new WriteAsync();
        String cacheFilename = getCacheFilename(str);
        if (cacheFilename == null) {
            cacheFilename = createCacheFilename(str);
        }
        File cacheFile = getCacheFile(cacheFilename);
        if (this.mCacheDir.exists() || !this.mCacheDir.mkdir()) {
        }
        if (!cacheFile.exists()) {
            cacheFile.createNewFile();
        }
        writeAsync.os = new FileOutputStream(cacheFile);
        writeAsync.key = str;
        writeAsync.cacheFilename = cacheFilename;
        writeAsync.cacheFile = cacheFile;
        return writeAsync;
    }

    public synchronized void put(String str, InputStream inputStream) {
        String cacheFilename = getCacheFilename(str);
        if (cacheFilename == null) {
            cacheFilename = createCacheFilename(str);
        }
        File cacheFile = getCacheFile(cacheFilename);
        try {
            if (this.mCacheDir.exists() || !this.mCacheDir.mkdir()) {
            }
            if (!cacheFile.exists()) {
                cacheFile.createNewFile();
            }
            FileOutputStream fileOutputStream = new FileOutputStream(cacheFile);
            byte[] bArr = new byte[AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT];
            while (true) {
                int read = inputStream.read(bArr);
                if (read == -1) {
                    break;
                }
                fileOutputStream.write(bArr, 0, read);
            }
            fileOutputStream.close();
            insertEntry(str, cacheFilename);
        } catch (Throwable e) {
            Log.e(getClass().getName(), "Error while putting", e);
        }
        return;
    }
}

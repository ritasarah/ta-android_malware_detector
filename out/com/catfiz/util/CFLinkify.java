package com.catfiz.util;

import android.content.Context;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.method.LinkMovementMethod;
import android.text.method.MovementMethod;
import android.text.util.Linkify.MatchFilter;
import android.text.util.Linkify.TransformFilter;
import android.webkit.WebView;
import android.widget.TextView;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.http.protocol.HTTP;

public class CFLinkify {
    public static final int ALL = (NIC | 31);
    public static final int EMAIL_ADDRESSES = 2;
    private static final String FIZZLINK_HOST = "m.catfiz.com/";
    private static final String FIZZLINK_SCHEME = "catfiz://";
    public static final int MAP_ADDRESSES = 8;
    public static int NIC = 32;
    public static final int PHONE_NUMBERS = 4;
    public static final int PHONE_NUMBERS_ONLY = 16;
    private static final int PHONE_NUMBER_MINIMUM_DIGITS = 5;
    private static final String TAG = "CFLinkify";
    public static final int WEB_URLS = 1;
    public static final MatchFilter sPhoneNumberMatchFilter = new MatchFilter() {
        public final boolean acceptMatch(CharSequence charSequence, int i, int i2) {
            int i3 = CFLinkify.ALL;
            while (i < i2) {
                if (Character.isDigit(charSequence.charAt(i))) {
                    i3 += CFLinkify.WEB_URLS;
                    if (i3 >= CFLinkify.PHONE_NUMBER_MINIMUM_DIGITS) {
                        return true;
                    }
                }
                i += CFLinkify.WEB_URLS;
            }
            return false;
        }
    };
    public static final MatchFilter sUrlMatchFilter = new MatchFilter() {
        public final boolean acceptMatch(CharSequence charSequence, int i, int i2) {
            return i == 0 || charSequence.charAt(i - 1) != '@';
        }
    };

    private static final void addLinkMovementMethod(TextView textView) {
        MovementMethod movementMethod = textView.getMovementMethod();
        if ((movementMethod == null || !(movementMethod instanceof LinkMovementMethod)) && textView.getLinksClickable()) {
            textView.setMovementMethod(LinkMovementMethod.getInstance());
        }
    }

    public static final void addLinks(TextView textView, Pattern pattern, String str) {
        addLinks(textView, pattern, str, null, null);
    }

    public static final void addLinks(TextView textView, Pattern pattern, String str, MatchFilter matchFilter, TransformFilter transformFilter) {
        Spannable valueOf = SpannableString.valueOf(textView.getText());
        if (addLinks(valueOf, pattern, str, matchFilter, transformFilter)) {
            textView.setText(valueOf);
            addLinkMovementMethod(textView);
        }
    }

    public static final boolean addLinks(Context context, Spannable spannable, int i) {
        if (i == 0) {
            return false;
        }
        CFURLSpan[] cFURLSpanArr = (CFURLSpan[]) spannable.getSpans(ALL, spannable.length(), CFURLSpan.class);
        for (int length = cFURLSpanArr.length - 1; length >= 0; length--) {
            spannable.removeSpan(cFURLSpanArr[length]);
        }
        ArrayList arrayList = new ArrayList();
        if ((i & WEB_URLS) != 0) {
            Pattern pattern = Patterns.WEB_URL;
            String[] strArr = new String[PHONE_NUMBERS];
            strArr[ALL] = "http://";
            strArr[WEB_URLS] = "https://";
            strArr[EMAIL_ADDRESSES] = "rtsp://";
            strArr[3] = FIZZLINK_SCHEME;
            gatherWebLinks(arrayList, spannable, pattern, strArr, sUrlMatchFilter, null);
        }
        if ((i & EMAIL_ADDRESSES) != 0) {
            pattern = Patterns.EMAIL_ADDRESS;
            strArr = new String[WEB_URLS];
            strArr[ALL] = "mailto:";
            gatherLinks(arrayList, spannable, pattern, strArr, null, null, null);
        }
        if ((i & PHONE_NUMBERS) != 0) {
            Spannable spannable2 = spannable;
            gatherLinks(arrayList, spannable2, Patterns.PHONE, new String[]{"tel:", "Tel:", "telp:", "Telp:", "tlp:", "Tlp:"}, "tel:", sPhoneNumberMatchFilter, null);
        }
        if ((i & PHONE_NUMBERS_ONLY) != 0) {
            pattern = Patterns.PHONEONLY;
            strArr = new String[WEB_URLS];
            strArr[ALL] = "tel:";
            gatherLinks(arrayList, spannable, pattern, strArr, null, sPhoneNumberMatchFilter, null);
        }
        if ((NIC & i) != 0) {
            pattern = Patterns.NIC;
            strArr = new String[WEB_URLS];
            strArr[ALL] = CFURLSpan.NIC_SCHEME;
            gatherLinks(arrayList, spannable, pattern, strArr, null, null, null);
        }
        if ((i & MAP_ADDRESSES) != 0) {
            gatherMapLinks(arrayList, spannable);
        }
        pruneOverlaps(arrayList);
        if (arrayList.size() == 0) {
            return false;
        }
        Iterator it = arrayList.iterator();
        while (it.hasNext()) {
            CFLinkSpec cFLinkSpec = (CFLinkSpec) it.next();
            applyLink(context, cFLinkSpec.url, cFLinkSpec.linktype, cFLinkSpec.start, cFLinkSpec.end, spannable);
        }
        return true;
    }

    public static final boolean addLinks(Spannable spannable, int i) {
        if (i == 0) {
            return false;
        }
        CFURLSpan[] cFURLSpanArr = (CFURLSpan[]) spannable.getSpans(ALL, spannable.length(), CFURLSpan.class);
        for (int length = cFURLSpanArr.length - 1; length >= 0; length--) {
            spannable.removeSpan(cFURLSpanArr[length]);
        }
        ArrayList arrayList = new ArrayList();
        if ((i & WEB_URLS) != 0) {
            Pattern pattern = Patterns.WEB_URL;
            String[] strArr = new String[PHONE_NUMBERS];
            strArr[ALL] = "http://";
            strArr[WEB_URLS] = "https://";
            strArr[EMAIL_ADDRESSES] = "rtsp://";
            strArr[3] = FIZZLINK_SCHEME;
            gatherWebLinks(arrayList, spannable, pattern, strArr, sUrlMatchFilter, null);
        }
        if ((i & EMAIL_ADDRESSES) != 0) {
            pattern = Patterns.EMAIL_ADDRESS;
            strArr = new String[WEB_URLS];
            strArr[ALL] = "mailto:";
            gatherLinks(arrayList, spannable, pattern, strArr, null, null, null);
        }
        if ((i & PHONE_NUMBERS) != 0) {
            Spannable spannable2 = spannable;
            gatherLinks(arrayList, spannable2, Patterns.PHONE, new String[]{"tel:", "Tel:", "telp:", "Telp:", "tlp:", "Tlp:"}, "tel:", sPhoneNumberMatchFilter, null);
        }
        if ((i & PHONE_NUMBERS_ONLY) != 0) {
            pattern = Patterns.PHONEONLY;
            strArr = new String[WEB_URLS];
            strArr[ALL] = "tel:";
            gatherLinks(arrayList, spannable, pattern, strArr, null, sPhoneNumberMatchFilter, null);
        }
        if ((NIC & i) != 0) {
            pattern = Patterns.NIC;
            strArr = new String[WEB_URLS];
            strArr[ALL] = CFURLSpan.NIC_SCHEME;
            gatherLinks(arrayList, spannable, pattern, strArr, null, null, null);
        }
        if ((i & MAP_ADDRESSES) != 0) {
            gatherMapLinks(arrayList, spannable);
        }
        pruneOverlaps(arrayList);
        if (arrayList.size() == 0) {
            return false;
        }
        Iterator it = arrayList.iterator();
        while (it.hasNext()) {
            CFLinkSpec cFLinkSpec = (CFLinkSpec) it.next();
            applyLink(cFLinkSpec.url, cFLinkSpec.start, cFLinkSpec.end, spannable);
        }
        return true;
    }

    public static final boolean addLinks(Spannable spannable, Pattern pattern, String str) {
        return addLinks(spannable, pattern, str, null, null);
    }

    public static final boolean addLinks(Spannable spannable, Pattern pattern, String str, MatchFilter matchFilter, TransformFilter transformFilter) {
        String toLowerCase = str == null ? "" : str.toLowerCase(Locale.US);
        Matcher matcher = pattern.matcher(spannable);
        boolean z = false;
        while (matcher.find()) {
            int start = matcher.start();
            int end = matcher.end();
            if (matchFilter != null ? matchFilter.acceptMatch(spannable, start, end) : true) {
                String group = matcher.group(ALL);
                String[] strArr = new String[WEB_URLS];
                strArr[ALL] = toLowerCase;
                applyLink(makeUrl(group, strArr, null, matcher, transformFilter), start, end, spannable);
                z = true;
            }
        }
        return z;
    }

    public static final boolean addLinks(TextView textView, int i) {
        if (i == 0) {
            return false;
        }
        CharSequence text = textView.getText();
        Context context = textView.getContext();
        if (!(text instanceof Spannable)) {
            Spannable valueOf = SpannableString.valueOf(text);
            if (!addLinks(context, valueOf, i)) {
                return false;
            }
            addLinkMovementMethod(textView);
            textView.setText(valueOf);
            return true;
        } else if (!addLinks(context, (Spannable) text, i)) {
            return false;
        } else {
            addLinkMovementMethod(textView);
            return true;
        }
    }

    private static final void applyLink(Context context, String str, int i, int i2, int i3, Spannable spannable) {
        spannable.setSpan(new CFURLSpan(str, i2, i3), i2, i3, 33);
    }

    private static final void applyLink(String str, int i, int i2, Spannable spannable) {
        spannable.setSpan(new CFURLSpan(str, i, i2), i, i2, 33);
    }

    private static final void gatherLinks(ArrayList arrayList, Spannable spannable, Pattern pattern, String[] strArr, String str, MatchFilter matchFilter, TransformFilter transformFilter) {
        Matcher matcher = pattern.matcher(spannable);
        while (matcher.find()) {
            int start = matcher.start();
            int end = matcher.end();
            if (matchFilter == null || matchFilter.acceptMatch(spannable, start, end)) {
                CFLinkSpec cFLinkSpec = new CFLinkSpec();
                cFLinkSpec.url = makeUrl(matcher.group(ALL), strArr, str, matcher, transformFilter);
                cFLinkSpec.start = start;
                cFLinkSpec.end = end;
                arrayList.add(cFLinkSpec);
            }
        }
    }

    private static final void gatherMapLinks(ArrayList arrayList, Spannable spannable) {
        String obj = spannable.toString();
        int i = ALL;
        while (true) {
            String findAddress = WebView.findAddress(obj);
            if (findAddress != null) {
                int indexOf = obj.indexOf(findAddress);
                if (indexOf >= 0) {
                    CFLinkSpec cFLinkSpec = new CFLinkSpec();
                    int length = findAddress.length() + indexOf;
                    cFLinkSpec.start = indexOf + i;
                    cFLinkSpec.end = i + length;
                    obj = obj.substring(length);
                    i += length;
                    try {
                        cFLinkSpec.url = "geo:0,0?q=" + URLEncoder.encode(findAddress, HTTP.UTF_8);
                        arrayList.add(cFLinkSpec);
                    } catch (UnsupportedEncodingException e) {
                    }
                } else {
                    return;
                }
            }
            return;
        }
    }

    private static final void gatherWebLinks(ArrayList arrayList, Spannable spannable, Pattern pattern, String[] strArr, MatchFilter matchFilter, TransformFilter transformFilter) {
        Matcher matcher = pattern.matcher(spannable);
        while (matcher.find()) {
            int start = matcher.start();
            int end = matcher.end();
            if (matchFilter == null || matchFilter.acceptMatch(spannable, start, end)) {
                CFLinkSpec makeLinkSpec = makeLinkSpec(new CFLinkSpec(), matcher.group(ALL), strArr, matcher, transformFilter);
                makeLinkSpec.start = start;
                makeLinkSpec.end = end;
                arrayList.add(makeLinkSpec);
            }
        }
    }

    private static final CFLinkSpec makeLinkSpec(CFLinkSpec cFLinkSpec, String str, String[] strArr, Matcher matcher, TransformFilter transformFilter) {
        boolean z;
        String transformUrl = transformFilter != null ? transformFilter.transformUrl(matcher, str) : str;
        for (int i = ALL; i < strArr.length; i += WEB_URLS) {
            if (transformUrl.regionMatches(true, ALL, strArr[i], ALL, strArr[i].length())) {
                cFLinkSpec.linktype = WEB_URLS;
                transformUrl = strArr[i] + transformUrl.substring(strArr[i].length()).trim();
                z = true;
                break;
            }
        }
        z = ALL;
        if (!z) {
            transformUrl = transformUrl.regionMatches(true, ALL, FIZZLINK_HOST, ALL, FIZZLINK_HOST.length()) ? FIZZLINK_SCHEME + transformUrl : strArr[ALL] + transformUrl;
        }
        cFLinkSpec.url = transformUrl;
        return cFLinkSpec;
    }

    private static final String makeUrl(String str, String[] strArr, String str2, Matcher matcher, TransformFilter transformFilter) {
        boolean z;
        String transformUrl = transformFilter != null ? transformFilter.transformUrl(matcher, str) : str;
        int i = ALL;
        while (i < strArr.length) {
            if (transformUrl.regionMatches(true, ALL, strArr[i], ALL, strArr[i].length())) {
                if (str2 != null) {
                    transformUrl = str2 + transformUrl.substring(strArr[i].length()).trim();
                    z = true;
                } else {
                    transformUrl = strArr[i] + transformUrl.substring(strArr[i].length()).trim();
                    z = true;
                }
                if (!z) {
                    return transformUrl;
                }
                return transformUrl.regionMatches(true, ALL, FIZZLINK_HOST, ALL, FIZZLINK_HOST.length()) ? FIZZLINK_SCHEME + transformUrl : str2 == null ? str2 + transformUrl : strArr[ALL] + transformUrl;
            } else {
                i += WEB_URLS;
            }
        }
        z = ALL;
        if (!z) {
            return transformUrl;
        }
        if (transformUrl.regionMatches(true, ALL, FIZZLINK_HOST, ALL, FIZZLINK_HOST.length())) {
        }
    }

    private static final void pruneOverlaps(ArrayList arrayList) {
        Collections.sort(arrayList, new Comparator() {
            public final int compare(CFLinkSpec cFLinkSpec, CFLinkSpec cFLinkSpec2) {
                return cFLinkSpec.start < cFLinkSpec2.start ? -1 : cFLinkSpec.start > cFLinkSpec2.start ? CFLinkify.WEB_URLS : cFLinkSpec.end < cFLinkSpec2.end ? CFLinkify.WEB_URLS : cFLinkSpec.end <= cFLinkSpec2.end ? CFLinkify.ALL : -1;
            }

            public final boolean equals(Object obj) {
                return false;
            }
        });
        int size = arrayList.size();
        int i = ALL;
        int i2 = size;
        while (i < i2 - 1) {
            CFLinkSpec cFLinkSpec = (CFLinkSpec) arrayList.get(i);
            CFLinkSpec cFLinkSpec2 = (CFLinkSpec) arrayList.get(i + WEB_URLS);
            if (cFLinkSpec.start <= cFLinkSpec2.start && cFLinkSpec.end > cFLinkSpec2.start) {
                size = cFLinkSpec2.end <= cFLinkSpec.end ? i + WEB_URLS : cFLinkSpec.end - cFLinkSpec.start > cFLinkSpec2.end - cFLinkSpec2.start ? i + WEB_URLS : cFLinkSpec.end - cFLinkSpec.start < cFLinkSpec2.end - cFLinkSpec2.start ? i : -1;
                if (size != -1) {
                    arrayList.remove(size);
                    i2--;
                }
            }
            i += WEB_URLS;
        }
    }
}

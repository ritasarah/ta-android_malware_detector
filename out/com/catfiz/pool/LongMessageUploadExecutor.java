package com.catfiz.pool;

import com.catfiz.service.CatfishMessageObject;
import com.catfiz.service.CatfishRESTAPI;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.service.CatfishService;
import com.catfiz.service.CatfishUIBinder.DatabaseRequestOP;
import com.catfiz.service.ICatfishClientInterface;
import com.catfiz.service.ICatfishUIBinder;
import com.catfiz.service.IDropableRunnable;
import com.catfiz.service.LongMessageExecutor;
import com.catfiz.service.uidbexec.CUIDatabaseRequestExecutor;
import com.catfiz.util.Log;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LongMessageUploadExecutor implements Runnable {
    private static final String TAG = "LongMessageUploadExecutor";
    public static final int mChunkMaxSize = 262144;
    private static String mServer = null;
    private static String mUsername = null;
    private static String mUserpin = null;
    public boolean bNeedRead = true;
    public int mBytestart = 0;
    public byte[] mChunkbuffer = null;
    public int mChunksent = 0;
    public int mChunksize = 0;
    public FileInputStream mChunkstream = null;
    private ICatfishClientInterface mClientInterface = null;
    public File mDataFile = null;
    private String mDataPath = null;
    public volatile int mDatasize = 0;
    private ICatfishUIBinder mIbinder = null;
    private CatfishMessageObject mMessage = null;
    private volatile long mObjSequence = 0;
    private long mSequence = 0;
    private CatfishService mService = null;
    private String mTopic_key = null;

    class PoolDataUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private PoolDataUploadChunk() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            Log.d(LongMessageUploadExecutor.TAG, "UPLOAD DROPPED");
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (LongMessageUploadExecutor.this.mChunkstream == null) {
                Log.d(LongMessageUploadExecutor.TAG, "----POOLBCAST: INVALID CHUNKSTREAM (NULL): CANCELED");
                LongMessageUploadExecutor.this.mChunkbuffer = null;
                return;
            }
            try {
                if (LongMessageUploadExecutor.this.bNeedRead) {
                    LongMessageUploadExecutor.this.bNeedRead = false;
                    LongMessageUploadExecutor.this.mChunksize = LongMessageUploadExecutor.this.mChunkstream.read(LongMessageUploadExecutor.this.mChunkbuffer, 0, LongMessageUploadExecutor.mChunkMaxSize);
                }
                if (LongMessageUploadExecutor.this.mChunksize <= 0) {
                    Log.d(LongMessageUploadExecutor.TAG, "----POOLBCAST: SENT COMPLETE");
                    try {
                        LongMessageUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    LongMessageUploadExecutor.this.mService.postToServiceHandler(new PoolUploadNotifyMember());
                    LongMessageUploadExecutor.this.mChunkbuffer = null;
                    return;
                }
                Log.d(LongMessageUploadExecutor.TAG, "Get byte range: bs=" + String.valueOf(LongMessageUploadExecutor.this.mBytestart) + ", " + "chsize=" + String.valueOf(LongMessageUploadExecutor.this.mChunksize) + ", " + "size=" + String.valueOf(LongMessageUploadExecutor.this.mDatasize) + ", ");
                CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(LongMessageUploadExecutor.mServer, LongMessageUploadExecutor.mUserpin, LongMessageUploadExecutor.this.mObjSequence, LongMessageUploadExecutor.this.mDatasize, LongMessageUploadExecutor.this.mBytestart, LongMessageUploadExecutor.this.mChunksize, LongMessageUploadExecutor.this.mChunkbuffer);
                if (uploadDataChunk.hasSuccess()) {
                    if (uploadDataChunk.byteend == 0) {
                        Log.d(LongMessageUploadExecutor.TAG, "----Byte End is 0: RESEND");
                        LongMessageUploadExecutor.this.bNeedRead = false;
                        LongMessageUploadExecutor.this.mService.postToServiceHandler(this);
                        return;
                    } else if (LongMessageUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - LongMessageUploadExecutor.this.mBytestart) + 1) {
                        Log.d(LongMessageUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                        LongMessageUploadExecutor.this.mChunkbuffer = null;
                        try {
                            LongMessageUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e2) {
                        }
                        uploadDataChunk.cleaningup();
                        return;
                    } else {
                        Log.d(LongMessageUploadExecutor.TAG, "Chunk Sent: " + String.valueOf(uploadDataChunk.byteend - LongMessageUploadExecutor.this.mBytestart) + " bytes: " + String.valueOf(LongMessageUploadExecutor.this.mBytestart) + "-" + String.valueOf(uploadDataChunk.byteend) + ": SELF RE-POST");
                        LongMessageUploadExecutor longMessageUploadExecutor = LongMessageUploadExecutor.this;
                        longMessageUploadExecutor.mChunksent += (uploadDataChunk.byteend - LongMessageUploadExecutor.this.mBytestart) + 1;
                        LongMessageUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                        LongMessageUploadExecutor.this.bNeedRead = true;
                        LongMessageUploadExecutor.this.mService.postToServiceHandler(this);
                    }
                } else if (uploadDataChunk.hasFailure()) {
                    Log.d(LongMessageUploadExecutor.TAG, "----POOLBCAST: FAILURE !!!: Re Schedule");
                    LongMessageUploadExecutor.this.bNeedRead = false;
                    LongMessageUploadExecutor.mServer = CatfishService.getServerHost();
                    LongMessageUploadExecutor.this.mService.scheduleRunnableToService(this);
                } else {
                    Log.e(LongMessageUploadExecutor.TAG, "----POOLBCAST: ERROR: DROP");
                    LongMessageUploadExecutor.this.mChunkbuffer = null;
                    try {
                        LongMessageUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e3) {
                    }
                }
                uploadDataChunk.cleaningup();
            } catch (IOException e4) {
                LongMessageUploadExecutor.this.mChunkbuffer = null;
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class PoolUploadNotifyMember implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private PoolUploadNotifyMember() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult conferenceSendData = this.catfishRestAPI.conferenceSendData(LongMessageUploadExecutor.mServer, LongMessageUploadExecutor.mUserpin, LongMessageUploadExecutor.mUsername, LongMessageUploadExecutor.this.mTopic_key.split(":")[0], Long.parseLong(LongMessageUploadExecutor.this.mTopic_key.split(":")[1]), MessageType.BCASTCONFERENCE_LONGMESSAGE.ordinal(), null, LongMessageUploadExecutor.this.mSequence, LongMessageUploadExecutor.this.mObjSequence);
            if (conferenceSendData.hasSuccess()) {
                Log.d(LongMessageUploadExecutor.TAG, "PoolUploadNotifyMember:" + LongMessageUploadExecutor.this.mSequence + " " + LongMessageUploadExecutor.this.mMessage.sequence);
                PoolDataStorage poolDataStorage = new PoolDataStorage(LongMessageUploadExecutor.this.mService);
                CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
                catfishMessageObject.topic_key = LongMessageUploadExecutor.this.mTopic_key;
                catfishMessageObject.sequence = LongMessageUploadExecutor.this.mMessage.sequence;
                String longMessage = LongMessageExecutor.getLongMessage(LongMessageUploadExecutor.this.mMessage.sequence);
                String str = "";
                if (!(longMessage == null || longMessage.isEmpty())) {
                    str = longMessage.substring(0, LongMessageExecutor.LONG_MESSAGE_CHAR_PREVIEW);
                }
                catfishMessageObject.message = str;
                poolDataStorage.updateDiscussMessage(catfishMessageObject);
                LongMessageUploadExecutor.this.mService.postToDBHandler(new CUIDatabaseRequestExecutor(LongMessageUploadExecutor.this.mIbinder, LongMessageUploadExecutor.this.mClientInterface, LongMessageUploadExecutor.this.mMessage, DatabaseRequestOP.UPDATEPOOLSTATUSTOSENT));
            } else if (conferenceSendData.hasFailure()) {
                LongMessageUploadExecutor.mServer = CatfishService.getServerHost();
                LongMessageUploadExecutor.this.mService.scheduleRunnableToService(this);
            } else {
                Log.e(LongMessageUploadExecutor.TAG, "Error Sending Data: DROP");
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public LongMessageUploadExecutor(ICatfishUIBinder iCatfishUIBinder, ICatfishClientInterface iCatfishClientInterface, CatfishService catfishService, String str, String str2, String str3, String str4, String str5, CatfishMessageObject catfishMessageObject) {
        this.mTopic_key = str4;
        this.mClientInterface = iCatfishClientInterface;
        this.mService = catfishService;
        mServer = str;
        mUserpin = str2;
        mUsername = str3;
        this.mDataPath = str5;
        this.mSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mObjSequence = this.mSequence;
        this.mDataFile = new File(str5);
        this.mDatasize = Long.valueOf(this.mDataFile.length()).intValue();
        try {
            this.mChunkstream = new FileInputStream(this.mDataFile);
            this.mChunkbuffer = new byte[mChunkMaxSize];
        } catch (FileNotFoundException e) {
            Log.e(TAG, "----POOLLONGMESSAGE FAIL TO ACCESS DATA FILE: " + e.toString());
            this.mChunkstream = null;
        }
        this.mMessage = catfishMessageObject;
        this.mIbinder = iCatfishUIBinder;
    }

    public void run() {
        this.mService.postToServiceHandler(new PoolDataUploadChunk());
    }
}

package com.catfiz.pool;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.Uri;
import android.os.Environment;
import android.support.v4.content.LocalBroadcastManager;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.catfiz.R;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.media.MediaScanOnlyNotifier;
import com.catfiz.media.StorageDir;
import com.catfiz.pool.PoolDataUploadExecutor.PoolDataType;
import com.catfiz.service.CatfishMessageObject;
import com.catfiz.service.CatfishRESTAPI;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.service.CatfishService;
import com.catfiz.service.IDropableRunnable;
import com.catfiz.service.ServerMessageDataStorage;
import com.catfiz.service.SlinkFileInfoExecutor;
import com.catfiz.service.uisvcexec.GetStreamThumbnailExecutor;
import com.catfiz.svcpersistent.DataStorageDownloadBase;
import com.catfiz.svcpersistent.DataStorageDownloadInfo.DataStorageStreamType;
import com.catfiz.util.Log;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import org.apache.commons.logging.impl.SimpleLog;
import org.apache.http.HttpStatus;
import org.apache.http.conn.routing.HttpRouteDirector;
import org.apache.http.protocol.HTTP;

public class PoolLimitedDownloadExecutor extends DataStorageDownloadBase implements IDropableRunnable, Runnable {
    private static final String LONG_MESSAGE = "_longmessage_";
    private static final String TAG = "PoolLimitedDownloadExecutor";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    public static final String mParentFilePath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/pool/");
    public static final String mParentPPPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/files/");
    public static final String mParentVoicePath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/voice/");
    private static String mServer = null;
    private static String mUserpin = null;
    private boolean cancelDownload = false;
    private CatfishRESTAPI catfishRestAPI = null;
    private long mAge = 0;
    private int mByteend = 0;
    private int mBytestart = 0;
    private BroadcastReceiver mCancelDownloadReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            long longExtra = intent.getLongExtra(ServerMessageDataStorage.SEQUENCE, 0);
            if (longExtra == 0) {
                Log.d(PoolLimitedDownloadExecutor.TAG, "INVALID SEQUENCE: DO NOT CANCEL");
            } else if (PoolLimitedDownloadExecutor.this.mObjSequence == 0 || PoolLimitedDownloadExecutor.this.mObjSequence != longExtra) {
                Log.d(PoolLimitedDownloadExecutor.TAG, "Current Object Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(PoolLimitedDownloadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + longExtra);
                PoolLimitedDownloadExecutor.this.cancelDownload = true;
            }
        }
    };
    private byte[] mChunkbuffer = null;
    private FileOutputStream mChunkstream = null;
    private File mDataFile = null;
    private String mDataPath = null;
    private int mDataType = 0;
    private int mDatasize = 0;
    private String mMessage = null;
    private String mMessageComment = null;
    private int mMessageType;
    private long mObjSequence = 0;
    public String mParentPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/pool/");
    private String mSenderpin = null;
    private long mSequence = 0;
    private CatfishService mService = null;
    private String mSlink = null;
    private int mTryToDownload = 0;
    private int mWriten = 0;
    private long maxFileSize = 0;
    private String messageTemp = "";
    private Uri photo_uri = null;
    private boolean requestToDownload = false;
    public int scheduleNum = 0;
    private String topic_key = null;

    class GetDataStorageChunks implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private GetDataStorageChunks() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadFail());
            LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).unregisterReceiver(PoolLimitedDownloadExecutor.this.mCancelDownloadReceiver);
            PoolLimitedDownloadExecutor.this.deleteTaskState(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), false);
            Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
            intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
            intent.putExtra(CatfishService.PROGRESS_STATE, 4);
            LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void proceedToCompleted() {
            Log.d(PoolLimitedDownloadExecutor.TAG, " --- proceedToCompleted --- ");
            try {
                PoolLimitedDownloadExecutor.this.mChunkstream.flush();
                PoolLimitedDownloadExecutor.this.mChunkstream.close();
            } catch (IOException e) {
            }
            if (PoolLimitedDownloadExecutor.this.mDataType == PoolDataType.TOPIC_IMAGE.ordinal() || PoolLimitedDownloadExecutor.this.mDataType == PoolDataType.FILE.ordinal() || PoolLimitedDownloadExecutor.this.mDataType == PoolDataType.VIDEO.ordinal()) {
                String extension = Utils.getExtension(PoolLimitedDownloadExecutor.this.mDataFile.getName());
                Log.d(PoolLimitedDownloadExecutor.TAG, "url :" + extension);
                if (Utils.getFileTypeFromPath(extension) == 1) {
                    Log.d(PoolLimitedDownloadExecutor.TAG, "--- proceedToCompleted ImageThumbnailer image ---");
                    new ImageThumbnailer(PoolLimitedDownloadExecutor.this.mService, PoolLimitedDownloadExecutor.this.mSenderpin, 0, 2.0f) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                Log.d(PoolLimitedDownloadExecutor.TAG, "--- onPostExecute ImageThumbnailer result ---" + uri.toString());
                                PoolLimitedDownloadExecutor.this.photo_uri = uri;
                            }
                            PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadComplete(PoolLimitedDownloadExecutor.this.mDataType));
                        }
                    }.execute(new Uri[]{Uri.fromFile(PoolLimitedDownloadExecutor.this.mDataFile)});
                } else if (Utils.getFileTypeFromPath(extension) == 6) {
                    new ImageThumbnailer(PoolLimitedDownloadExecutor.this.mService, PoolLimitedDownloadExecutor.this.mSenderpin, 0, true, PoolLimitedDownloadExecutor.this.mDataFile.getAbsolutePath()) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                PoolLimitedDownloadExecutor.this.photo_uri = uri;
                            }
                            PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadComplete(PoolLimitedDownloadExecutor.this.mDataType));
                        }
                    }.execute(new Uri[]{Uri.fromFile(PoolLimitedDownloadExecutor.this.mDataFile)});
                } else {
                    PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadComplete(PoolLimitedDownloadExecutor.this.mDataType));
                }
            } else {
                PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadComplete(PoolLimitedDownloadExecutor.this.mDataType));
            }
            LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).unregisterReceiver(PoolLimitedDownloadExecutor.this.mCancelDownloadReceiver);
        }

        public void run() {
            if (PoolLimitedDownloadExecutor.this.cancelDownload) {
                Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
                intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent);
                LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).unregisterReceiver(PoolLimitedDownloadExecutor.this.mCancelDownloadReceiver);
                PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadFail());
                PoolLimitedDownloadExecutor.this.deleteTaskState(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), false);
                return;
            }
            CatfishResult downloadDataChunk = this.catfishRestAPI.downloadDataChunk(PoolLimitedDownloadExecutor.mServer, PoolLimitedDownloadExecutor.mUserpin, PoolLimitedDownloadExecutor.this.mSenderpin, PoolLimitedDownloadExecutor.this.mObjSequence, PoolLimitedDownloadExecutor.this.mBytestart, PoolLimitedDownloadExecutor.this.mByteend, PoolLimitedDownloadExecutor.this.mChunkstream);
            if (PoolLimitedDownloadExecutor.this.cancelDownload) {
                intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
                intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent);
                LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).unregisterReceiver(PoolLimitedDownloadExecutor.this.mCancelDownloadReceiver);
                PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadFail());
                PoolLimitedDownloadExecutor.this.deleteTaskState(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), false);
                return;
            }
            Log.d(PoolLimitedDownloadExecutor.TAG, "POOLDOWNLOAD Chunksize: " + String.valueOf(downloadDataChunk.chunksize));
            int access$1700;
            Intent intent2;
            if (downloadDataChunk.hasSuccess()) {
                this.mAge = System.currentTimeMillis();
                PoolLimitedDownloadExecutor.this.mTryToDownload = 0;
                if (downloadDataChunk.chunksize > 0) {
                    PoolLimitedDownloadExecutor.this.mWriten = PoolLimitedDownloadExecutor.this.mWriten + downloadDataChunk.chunksize;
                }
                access$1700 = (PoolLimitedDownloadExecutor.this.mWriten * 100) / PoolLimitedDownloadExecutor.this.mDatasize;
                intent2 = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                intent2.putExtra(CatfishService.PROGRESS_VALUE, access$1700);
                intent2.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
                intent2.putExtra(CatfishService.PROGRESS_STATE, 1);
                LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent2);
                if (PoolLimitedDownloadExecutor.this.mWriten < PoolLimitedDownloadExecutor.this.mDatasize) {
                    PoolLimitedDownloadExecutor.this.mBytestart = PoolLimitedDownloadExecutor.this.mByteend + 1;
                    PoolLimitedDownloadExecutor.this.mByteend = ((PoolLimitedDownloadExecutor.this.mDatasize - PoolLimitedDownloadExecutor.this.mWriten > PoolLimitedDownloadExecutor.mChunkMaxSize ? PoolLimitedDownloadExecutor.mChunkMaxSize : PoolLimitedDownloadExecutor.this.mDatasize - PoolLimitedDownloadExecutor.this.mWriten) + PoolLimitedDownloadExecutor.this.mBytestart) - 1;
                    PoolLimitedDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.growChunkSize(PoolLimitedDownloadExecutor.mChunkMaxSize);
                    PoolLimitedDownloadExecutor.this.mTryToDownload = 0;
                    PoolLimitedDownloadExecutor.this.mService.postRunnableToService(this, 2);
                    downloadDataChunk.cleaningup();
                    return;
                }
                Log.d(PoolLimitedDownloadExecutor.TAG, "POOLDOWNLOAD RECEIVE: Get Data Chunk: DONE");
                proceedToCompleted();
                downloadDataChunk.cleaningup();
                PoolLimitedDownloadExecutor.this.deleteTaskState(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), false);
            } else if (downloadDataChunk.hasFailure()) {
                Log.d(PoolLimitedDownloadExecutor.TAG, "POOLDOWNLOAD RECEIVE: Get Data Chunk: FAIL: Reschedule");
                if (downloadDataChunk.chunksize > 0) {
                    this.mAge = System.currentTimeMillis();
                    PoolLimitedDownloadExecutor.this.mTryToDownload = 0;
                    PoolLimitedDownloadExecutor.this.mWriten = PoolLimitedDownloadExecutor.this.mWriten + downloadDataChunk.chunksize;
                    access$1700 = (PoolLimitedDownloadExecutor.this.mWriten * 100) / PoolLimitedDownloadExecutor.this.mDatasize;
                    intent2 = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                    intent2.putExtra(CatfishService.PROGRESS_VALUE, access$1700);
                    intent2.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
                    intent2.putExtra(CatfishService.PROGRESS_STATE, 1);
                    LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent2);
                    if (PoolLimitedDownloadExecutor.this.mWriten < PoolLimitedDownloadExecutor.this.mDatasize) {
                        PoolLimitedDownloadExecutor.this.mBytestart = PoolLimitedDownloadExecutor.this.mWriten;
                        PoolLimitedDownloadExecutor.this.mByteend = (PoolLimitedDownloadExecutor.this.mWriten + PoolLimitedDownloadExecutor.mChunkMaxSize) - 1;
                        PoolLimitedDownloadExecutor.this.mService.postRunnableToService(this, 2);
                        downloadDataChunk.cleaningup();
                        return;
                    }
                    Log.d(PoolLimitedDownloadExecutor.TAG, "POOLDOWNLOAD RECEIVE (In FAILURE): Get Data Chunk: DONE");
                    proceedToCompleted();
                    PoolLimitedDownloadExecutor.this.deleteTaskState(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), false);
                    downloadDataChunk.cleaningup();
                    return;
                }
                PoolLimitedDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(PoolLimitedDownloadExecutor.mChunkMaxSize);
                PoolLimitedDownloadExecutor.mServer = CatfishService.getServerHost();
                intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
                intent.putExtra(CatfishService.PROGRESS_STATE, 4);
                LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent);
                if (PoolLimitedDownloadExecutor.this.mTryToDownload < 5) {
                    PoolLimitedDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    PoolLimitedDownloadExecutor.this.mTryToDownload = PoolLimitedDownloadExecutor.this.mTryToDownload + 1;
                } else {
                    dropRunnable();
                }
                downloadDataChunk.cleaningup();
            } else if (downloadDataChunk.hasNotFound()) {
                Log.d(PoolLimitedDownloadExecutor.TAG, "POOLDOWNLOAD RECEIVE: NOT FOUND, TRY TO WAIT AND GET AGAIN");
                if (PoolLimitedDownloadExecutor.this.mTryToDownload < 5) {
                    intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                    intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                    intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
                    intent.putExtra(CatfishService.PROGRESS_STATE, 4);
                    LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent);
                    LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).unregisterReceiver(PoolLimitedDownloadExecutor.this.mCancelDownloadReceiver);
                    PoolLimitedDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    PoolLimitedDownloadExecutor.this.mTryToDownload = PoolLimitedDownloadExecutor.this.mTryToDownload + 1;
                } else {
                    intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                    intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                    intent.putExtra(CatfishService.PROGRESS_STATE, 4);
                    intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
                    LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent);
                    LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).unregisterReceiver(PoolLimitedDownloadExecutor.this.mCancelDownloadReceiver);
                    PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadError(HttpStatus.SC_MULTIPLE_CHOICES));
                    PoolLimitedDownloadExecutor.this.deleteTaskState(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), false);
                }
                downloadDataChunk.cleaningup();
            } else {
                intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
                intent.putExtra(CatfishService.PROGRESS_STATE, 4);
                LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent);
                LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).unregisterReceiver(PoolLimitedDownloadExecutor.this.mCancelDownloadReceiver);
                Log.d(PoolLimitedDownloadExecutor.TAG, "POOLDOWNLOAD RECEIVE: Get Data Chunk: ERROR: DROP");
                PoolLimitedDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadError(HttpStatus.SC_OK));
                PoolLimitedDownloadExecutor.this.deleteTaskState(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), false);
                try {
                    PoolLimitedDownloadExecutor.this.mChunkstream.flush();
                    PoolLimitedDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e) {
                }
                PoolLimitedDownloadExecutor.this.mChunkbuffer = null;
                downloadDataChunk.cleaningup();
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class GetSlinkFromServer implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private long mAge = System.currentTimeMillis();
        private int mDataType;
        private boolean mIsSent = false;
        public int scheduleNum = 0;
        private boolean send = true;

        public GetSlinkFromServer(int i) {
            this.mDataType = i;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult slink = this.catfishRestAPI.getSlink(PoolLimitedDownloadExecutor.mServer, PoolLimitedDownloadExecutor.this.mSenderpin, PoolLimitedDownloadExecutor.this.mSenderpin, PoolLimitedDownloadExecutor.this.mSequence);
            if (slink.hasSuccess()) {
                PoolLimitedDownloadExecutor.this.mSlink = slink.slink;
                PoolLimitedDownloadExecutor.this.mService.postToDBHandler(new PoolNotifyDownloadPending(this.mDataType));
                Log.d(PoolLimitedDownloadExecutor.TAG, "----GetSlinkFromServer: SUCCESS !!!: " + PoolLimitedDownloadExecutor.this.mSlink);
            } else if (slink.hasFailure()) {
                Log.d(PoolLimitedDownloadExecutor.TAG, "----GetSlinkFromServer: FAILURE !!!: Re Schedule");
                PoolLimitedDownloadExecutor.mServer = CatfishService.getServerHost();
                PoolLimitedDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(PoolLimitedDownloadExecutor.TAG, "----GetSlinkFromServer: ERROR: DROP");
            }
            slink.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class PoolNotifyDownloadComplete implements Runnable {
        private int mDataType;

        public PoolNotifyDownloadComplete(int i) {
            this.mDataType = i;
        }

        public void run() {
            boolean z;
            PoolDataStorage poolDataStorage = new PoolDataStorage(PoolLimitedDownloadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            obtain.topic_key = PoolLimitedDownloadExecutor.this.topic_key;
            obtain.sequence = PoolLimitedDownloadExecutor.this.mSequence;
            obtain.datatype = Utils.poolDataTypeToFileType(this.mDataType);
            if (this.mDataType == PoolDataType.VOICE.ordinal()) {
                obtain.message = PoolLimitedDownloadExecutor.this.mService.getString(R.string.voice_received);
                z = false;
            } else if (this.mDataType == PoolDataType.TOPIC_IMAGE.ordinal()) {
                poolDataStorage.deleteSingleDiscussConverence(PoolLimitedDownloadExecutor.this.topic_key, PoolLimitedDownloadExecutor.this.mSequence);
                obtain.image_path = PoolLimitedDownloadExecutor.this.mDataFile.getAbsolutePath();
                if (PoolLimitedDownloadExecutor.this.photo_uri != null) {
                    obtain.imagethumb_uri = PoolLimitedDownloadExecutor.this.photo_uri.toString();
                }
                poolDataStorage.updateSingleTopicContent(obtain);
                z = true;
            } else if (this.mDataType == PoolDataType.TOPIC_ATTACH.ordinal()) {
                poolDataStorage.deleteSingleDiscussConverence(PoolLimitedDownloadExecutor.this.topic_key, PoolLimitedDownloadExecutor.this.mSequence);
                obtain.datafile_path = PoolLimitedDownloadExecutor.this.mDataFile.getAbsolutePath();
                poolDataStorage.updateSingleTopicContent(obtain);
                z = false;
            } else if (this.mDataType == PoolDataType.FRIEND_PP.ordinal()) {
                poolDataStorage.deleteSingleDiscussConverence(PoolLimitedDownloadExecutor.this.topic_key, PoolLimitedDownloadExecutor.this.mSequence);
                z = false;
            } else if (this.mDataType == PoolDataType.VIDEO.ordinal()) {
                obtain.message = "Video Chat Received";
                obtain.datafile_path = PoolLimitedDownloadExecutor.this.mDataFile.getAbsolutePath();
                if (PoolLimitedDownloadExecutor.this.photo_uri != null) {
                    obtain.imagethumb_uri = PoolLimitedDownloadExecutor.this.photo_uri.toString();
                    z = true;
                } else {
                    z = true;
                }
            } else {
                if (PoolLimitedDownloadExecutor.this.mMessageComment != null) {
                    Log.d(PoolLimitedDownloadExecutor.TAG, "mMessageComment == null , isinya:" + PoolLimitedDownloadExecutor.this.mMessageComment);
                    try {
                        if (PoolLimitedDownloadExecutor.this.mMessageComment != null) {
                            PoolLimitedDownloadExecutor.this.mMessageComment = PoolLimitedDownloadExecutor.this.mMessageComment.replace(new String(PoolDataUploadExecutor.messageCharSubstitute, HTTP.UTF_8), ":");
                        }
                    } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                    }
                    obtain.message = PoolDataStorage.messageWithMetaInfoBuilder(PoolLimitedDownloadExecutor.this.mMessageComment, PoolLimitedDownloadExecutor.this.mDataFile);
                } else {
                    Log.d(PoolLimitedDownloadExecutor.TAG, "mMessageComment == null");
                    obtain.message = PoolDataStorage.messageWithMetaInfoBuilder("", PoolLimitedDownloadExecutor.this.mDataFile);
                    if (PoolLimitedDownloadExecutor.this.mDataFile.getName().endsWith("svg") || PoolLimitedDownloadExecutor.this.mDataFile.getName().endsWith("svgz") || PoolLimitedDownloadExecutor.this.mDataFile.getName().endsWith("svg.gz") || PoolLimitedDownloadExecutor.this.mDataFile.getName().endsWith(".sticker")) {
                        obtain.message = "";
                    }
                }
                obtain.datafile_path = PoolLimitedDownloadExecutor.this.mDataFile.getAbsolutePath();
                if (PoolLimitedDownloadExecutor.this.photo_uri != null) {
                    obtain.imagethumb_uri = PoolLimitedDownloadExecutor.this.photo_uri.toString();
                }
                z = true;
            }
            obtain.deliverystatus = MessageDeliveryStatus.BCASTRECEIVED;
            poolDataStorage.setUnReadItemInTopic(PoolLimitedDownloadExecutor.this.topic_key, 1);
            poolDataStorage.updateDiscussContent(obtain);
            PoolLimitedDownloadExecutor.this.mService.signalNewPoolMessageReceived(obtain.topic_key);
            if (z) {
                if (PoolLimitedDownloadExecutor.this.mMessageComment != null) {
                    obtain.message = PoolLimitedDownloadExecutor.this.mMessageComment;
                } else {
                    obtain.message = "";
                }
                obtain.senderpin = PoolLimitedDownloadExecutor.this.mSenderpin;
                obtain.rcvtimestamp = PoolLimitedDownloadExecutor.this.mSequence;
                obtain.slink = poolDataStorage.getSlink(PoolLimitedDownloadExecutor.this.topic_key, obtain.sequence);
                Log.d(PoolLimitedDownloadExecutor.TAG, "get slink :" + obtain.slink);
                PoolLimitedDownloadExecutor.this.mService.postRunnableToService(new GetStreamThumbnailExecutor(PoolLimitedDownloadExecutor.this.mService, obtain.slink));
                CatfishService access$200 = PoolLimitedDownloadExecutor.this.mService;
                CatfishService access$2002 = PoolLimitedDownloadExecutor.this.mService;
                long access$400 = PoolLimitedDownloadExecutor.this.mSequence;
                PoolLimitedDownloadExecutor.this.mService;
                access$200.postRunnableToService(new SlinkFileInfoExecutor(access$2002, access$400, CatfishService.getCurrentServerHost(), PoolLimitedDownloadExecutor.this.mSlink, false, true), 2);
            }
            Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
            intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolLimitedDownloadExecutor.this.mSequence);
            intent.putExtra(CatfishService.PROGRESS_STATE, 2);
            LocalBroadcastManager.getInstance(PoolLimitedDownloadExecutor.this.mService).sendBroadcast(intent);
            obtain.recycle();
            String extension = Utils.getExtension(PoolLimitedDownloadExecutor.this.mDataFile.getAbsolutePath());
            MediaScanOnlyNotifier mediaScanOnlyNotifier = new MediaScanOnlyNotifier(PoolLimitedDownloadExecutor.this.mService, PoolLimitedDownloadExecutor.this.mDataFile.getAbsolutePath(), extension == null ? "*/*" : Utils.getmimetypeFromExtension(extension));
        }
    }

    class PoolNotifyDownloadError implements Runnable {
        public static final int CANCELED = 100;
        public static final int ERROR = 200;
        public static final int NOTFOUND = 300;
        private int mErrorType;

        public PoolNotifyDownloadError(int i) {
            this.mErrorType = i;
        }

        public void run() {
            switch (this.mErrorType) {
                case ERROR /*200*/:
                case NOTFOUND /*300*/:
                    new PoolDataStorage(PoolLimitedDownloadExecutor.this.mService).deleteSingleDiscussConverence(PoolLimitedDownloadExecutor.this.topic_key, PoolLimitedDownloadExecutor.this.mSequence);
                    return;
                default:
                    return;
            }
        }
    }

    class PoolNotifyDownloadFail implements Runnable {
        private PoolNotifyDownloadFail() {
        }

        public void run() {
            if (PoolLimitedDownloadExecutor.this.mDataType != PoolDataType.VOICE.ordinal()) {
                PoolDataStorage poolDataStorage = new PoolDataStorage(PoolLimitedDownloadExecutor.this.mService);
                CatfishMessageObject obtain = CatfishMessageObject.obtain();
                obtain.topic_key = PoolLimitedDownloadExecutor.this.topic_key;
                obtain.sequence = PoolLimitedDownloadExecutor.this.mSequence;
                obtain.message = PoolLimitedDownloadExecutor.this.mDataFile.getName().replace(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), "");
                obtain.datafile_path = String.valueOf(PoolLimitedDownloadExecutor.this.mObjSequence) + ":" + String.valueOf(PoolLimitedDownloadExecutor.this.mBytestart) + ":" + String.valueOf(PoolLimitedDownloadExecutor.this.mByteend) + ":" + String.valueOf(PoolLimitedDownloadExecutor.this.mWriten);
                if (PoolLimitedDownloadExecutor.this.mMessageComment != null) {
                    obtain.datafile_path += ":" + PoolLimitedDownloadExecutor.this.mMessageComment;
                }
                obtain.deliverystatus = MessageDeliveryStatus.CONFRCFAILDOWNLOAD;
                poolDataStorage.updateDiscussContent(obtain);
                obtain.recycle();
            }
        }
    }

    class PoolNotifyDownloadPending implements Runnable {
        private int mDataType;

        public PoolNotifyDownloadPending(int i) {
            this.mDataType = i;
        }

        public void run() {
            Log.d(PoolLimitedDownloadExecutor.TAG, "~~~~~~~~~~PoolNotifyDownloadPending");
            PoolDataStorage poolDataStorage = new PoolDataStorage(PoolLimitedDownloadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            obtain.topic_key = PoolLimitedDownloadExecutor.this.topic_key;
            obtain.sequence = PoolLimitedDownloadExecutor.this.mSequence;
            obtain.datatype = Utils.poolDataTypeToFileType(this.mDataType);
            obtain.message = PoolLimitedDownloadExecutor.this.mDataFile.getName().replace(String.valueOf(PoolLimitedDownloadExecutor.this.mSequence), "");
            if (!PoolLimitedDownloadExecutor.this.messageTemp.equals("")) {
                obtain.message = PoolLimitedDownloadExecutor.this.messageTemp;
            }
            obtain.deliverystatus = MessageDeliveryStatus.CONFRCPENDINGDOWNLOAD;
            obtain.datafile_path = String.valueOf(PoolLimitedDownloadExecutor.this.mObjSequence) + ":" + String.valueOf(PoolLimitedDownloadExecutor.this.mBytestart) + ":" + String.valueOf(PoolLimitedDownloadExecutor.this.mByteend) + ":" + String.valueOf(PoolLimitedDownloadExecutor.this.mWriten);
            if (PoolLimitedDownloadExecutor.this.mMessageComment != null) {
                obtain.datafile_path += ":" + PoolLimitedDownloadExecutor.this.mMessageComment;
            }
            Log.d(PoolLimitedDownloadExecutor.TAG, "----GetSlinkFromServer: !!!: " + PoolLimitedDownloadExecutor.this.mSlink);
            if (PoolLimitedDownloadExecutor.this.mSlink != null) {
                obtain.slink = PoolLimitedDownloadExecutor.this.mSlink;
                PoolLimitedDownloadExecutor.this.mService.postRunnableToService(new GetStreamThumbnailExecutor(PoolLimitedDownloadExecutor.this.mService, obtain.slink));
                CatfishService access$200 = PoolLimitedDownloadExecutor.this.mService;
                CatfishService access$2002 = PoolLimitedDownloadExecutor.this.mService;
                long access$400 = PoolLimitedDownloadExecutor.this.mSequence;
                PoolLimitedDownloadExecutor.this.mService;
                access$200.postRunnableToService(new SlinkFileInfoExecutor(access$2002, access$400, CatfishService.getCurrentServerHost(), PoolLimitedDownloadExecutor.this.mSlink, false, true), 2);
                Log.d(PoolLimitedDownloadExecutor.TAG, "----GetSlinkFromServer: SUCCESS SAVE!!!: " + PoolLimitedDownloadExecutor.this.mSlink);
                if (poolDataStorage.updateDiscussContent(obtain)) {
                    PoolLimitedDownloadExecutor.this.mService.signalNewPoolMessageReceived(obtain.topic_key);
                }
            } else {
                PoolLimitedDownloadExecutor.this.mService.postRunnableToService(new GetSlinkFromServer(this.mDataType), 2);
            }
            obtain.recycle();
        }
    }

    public PoolLimitedDownloadExecutor(CatfishService catfishService, String str, String str2, String str3, String str4, String str5, long j, long j2, long j3, boolean z, int i, int i2, int i3, String str6, int i4) {
        this.mBytestart = i;
        this.mByteend = i2;
        this.mWriten = i3;
        this.mMessageType = i4;
        this.mService = catfishService;
        mServer = str;
        mUserpin = str2;
        this.topic_key = str3;
        this.mSenderpin = str4;
        this.mSequence = j;
        this.mObjSequence = j2;
        this.maxFileSize = j3;
        this.requestToDownload = z;
        Log.d(TAG, " isi message yang mw di download adalah : " + str5);
        if (str5.startsWith("file:")) {
            this.mDataType = PoolDataType.FILE.ordinal();
            this.mParentPath = mParentFilePath;
            Log.d(TAG, "Message Type: FILE");
        } else if (str5.startsWith("voice:")) {
            this.mDataType = PoolDataType.VOICE.ordinal();
            this.mParentPath = mParentVoicePath;
            Log.d(TAG, "Message Type: VOICE");
        } else if (str5.startsWith("topic_image:")) {
            this.mDataType = PoolDataType.TOPIC_IMAGE.ordinal();
            this.mParentPath = mParentFilePath;
            this.requestToDownload = true;
            Log.d(TAG, "Message Type: TOPIC_IMAGE");
        } else if (str5.startsWith("topic_attach:")) {
            this.mDataType = PoolDataType.TOPIC_ATTACH.ordinal();
            this.mParentPath = mParentFilePath;
            this.requestToDownload = true;
            Log.d(TAG, "Message Type: TOPIC ATTACHMENT FILE");
        } else if (str5.startsWith("friend_pp:")) {
            this.mDataType = PoolDataType.FRIEND_PP.ordinal();
            this.mParentPath = mParentPPPath;
            Log.d(TAG, "Message Type: FRIEND PP");
        } else if (str5.startsWith("video:")) {
            this.mDataType = PoolDataType.VIDEO.ordinal();
            this.mParentPath = mParentFilePath;
            Log.d(TAG, "Message Type: VIDEO");
        } else {
            this.mDataType = PoolDataType.FILE.ordinal();
            this.mParentPath = mParentFilePath;
            Log.d(TAG, "Message Type: UNKNOWN: SET AS FILE");
        }
        if (!this.requestToDownload && str5.split(":")[0] != null) {
            if (str5.startsWith("voice:")) {
                this.messageTemp = str5;
            }
            this.mMessage = str5.split(":")[1];
            if (str5.split(":").length > 2) {
                this.mMessageComment = str5.split(":")[2];
            }
            if (str5.split(":").length > 3) {
                this.mSlink = str5.split(":")[3];
            }
        } else if (str5.split(":")[0] != null) {
            this.mMessage = str5;
            if (str5.startsWith("voice:")) {
                this.mMessage = str5.split(":")[1];
                if (str5.split(":").length > 2) {
                    this.mMessageComment = str5.split(":")[2];
                }
            } else if (str5.startsWith("topic_image:") || str5.startsWith("topic_attach:")) {
                this.mMessage = str5.split(":")[1];
            }
        }
        if (str6 != null) {
            this.mMessageComment = str6;
        }
        Log.d(TAG, " isi message setelah di split : " + this.mMessage + " request to download : " + z);
        switch (Utils.getFileTypeFromPath(this.mMessage)) {
            case e.b /*1*/:
                this.mParentPath = StorageDir.getGroupChatDir(0);
                break;
            case e.c /*2*/:
                this.mParentPath = StorageDir.getGroupChatDir(4);
                break;
            case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                this.mParentPath = StorageDir.getGroupChatDir(2);
                break;
            case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                this.mParentPath = StorageDir.getGroupChatDir(1);
                break;
            default:
                this.mParentPath = StorageDir.getGroupChatDir(3);
                break;
        }
        this.mDataPath = this.mParentPath + String.valueOf(j) + this.mMessage;
        if (this.mDataType == PoolDataType.FRIEND_PP.ordinal()) {
            this.mDataPath = this.mParentPath + this.mMessage;
        }
        Log.d(TAG, "(PoolLimitedDownload)simpan sebagai : " + this.mDataPath);
        this.mDataFile = new File(this.mDataPath);
        this.mAge = System.currentTimeMillis();
        Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
        intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
        intent.putExtra(CatfishService.PROGRESS_STATE, 1);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelDownloadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_POOL_DOWNLOAD));
        Log.d(TAG, "mSlink = " + this.mSlink);
    }

    public void dropRunnable() {
        this.mService.postRunnableToDbThread(new PoolNotifyDownloadFail());
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
        deleteTaskState(String.valueOf(this.mSequence), false);
        Intent intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
        intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
        intent.putExtra(CatfishService.PROGRESS_STATE, 4);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        String externalStorageState = Environment.getExternalStorageState();
        if (externalStorageState.equals("mounted")) {
            if (this.mDataType == PoolDataType.TOPIC_IMAGE.ordinal() || this.mDataType == PoolDataType.TOPIC_ATTACH.ordinal()) {
                Log.d(TAG, "Topic key = " + this.topic_key + " msenderpin = " + this.mSenderpin);
                if (this.topic_key.split(":")[0].compareTo(this.mSenderpin) != 0) {
                    return;
                }
            }
            File parentFile = this.mDataFile.getParentFile();
            if (!parentFile.exists()) {
                parentFile.mkdirs();
            }
            Log.d(TAG, "path dari mdata file :" + parentFile.getAbsolutePath());
            File file = new File(parentFile, ".nomedia");
            if (file.exists()) {
                file.delete();
            }
            CatfishResult dataStorageInfo = this.catfishRestAPI.getDataStorageInfo(mServer, mUserpin, this.mSenderpin, this.mObjSequence);
            Intent intent;
            if (this.cancelDownload) {
                this.mService.postRunnableToDbThread(new PoolNotifyDownloadError(100));
                LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                if (dataStorageInfo != null) {
                    dataStorageInfo.cleaningup();
                }
                intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
                LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
                LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                return;
            } else if (dataStorageInfo.hasFailure()) {
                Log.d(TAG, "POOLDOWNLOAD GETDATAINFO: Get Info FAIL: Reschedule !!!");
                mServer = CatfishService.getServerHost();
                if (this.mTryToDownload < 5) {
                    this.mService.scheduleRunnableToService(this, 2);
                    this.mTryToDownload++;
                } else {
                    dropRunnable();
                }
                dataStorageInfo.cleaningup();
                return;
            } else if (dataStorageInfo.hasNotFound()) {
                Log.d(TAG, "POOLDOWNLOAD GETDATAINFO: NOT FOUND, TRY TO WAIT AND GET AGAIN");
                if (this.mTryToDownload < 5) {
                    this.mService.scheduleRunnableToService(this, 2);
                    this.mTryToDownload++;
                } else {
                    this.mService.postRunnableToDbThread(new PoolNotifyDownloadError(HttpStatus.SC_MULTIPLE_CHOICES));
                    LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                }
                dataStorageInfo.cleaningup();
                return;
            } else if (dataStorageInfo.hasSuccess()) {
                this.mDatasize = dataStorageInfo.datasize;
                if (this.mByteend == 0) {
                    this.mByteend = mChunkMaxSize - 1;
                }
                if (isResumeProcess() && this.mDataFile.exists()) {
                    this.mWriten = (int) this.mDataFile.length();
                    this.mBytestart = this.mWriten;
                    this.mByteend = (this.mBytestart + mChunkMaxSize) - 1;
                }
                if (((long) this.mDatasize) < this.maxFileSize || this.requestToDownload) {
                    try {
                        if (this.mBytestart == 0 && this.mDataFile.exists()) {
                            this.mDataFile.delete();
                        }
                        this.mChunkstream = new FileOutputStream(this.mDataFile, true);
                        intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                        intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
                        intent.putExtra(CatfishService.PROGRESS_STATE, 1);
                        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
                        updateTaskState(String.valueOf(this.mSequence), this.mDataFile.getAbsolutePath(), this.mDatasize, DataStorageStreamType.POOL_DATA.ordinal(), null, false);
                        if (this.mMessageType == MessageType.BCASTCONFERENCE_VIDEO.ordinal()) {
                            Log.d(TAG, "POOLDOWNLOAD GETDATAINFO: DONE");
                            this.mService.postRunnableToDbThread(new PoolNotifyDownloadComplete(this.mDataType));
                            return;
                        }
                        this.mService.postRunnableToService(new GetDataStorageChunks(), 2);
                        return;
                    } catch (FileNotFoundException e) {
                        Log.e(TAG, "POOLDOWNLOAD RECEIVE: " + e.toString());
                        return;
                    }
                }
                Log.d(TAG, "remove notification front progress");
                intent = new Intent(BroadcastIntents.ACTION_DOWNLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
                intent.putExtra(CatfishService.PROGRESS_STATE, 5);
                LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
                Log.d(TAG, "POOLDOWNLOAD: Data exceed max size: PENDING");
                this.mService.postRunnableToDbThread(new PoolNotifyDownloadPending(this.mDataType));
                LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                return;
            } else {
                Log.e(TAG, "POOLDOWNLOAD GETDATAINFO: ERROR: DROP !!!");
                this.mService.postRunnableToDbThread(new PoolNotifyDownloadError(HttpStatus.SC_OK));
                LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
                dataStorageInfo.cleaningup();
                return;
            }
        }
        Log.e(TAG, "POOLDOWNLOAD RECEIVE: media not mounted in is state: " + externalStorageState + ":DROP !!!");
        LocalBroadcastManager.getInstance(this.mService).unregisterReceiver(this.mCancelDownloadReceiver);
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

package com.catfiz.pool;

import android.database.Cursor;
import com.catfiz.R;
import com.catfiz.service.CatfishMessageObject;
import com.catfiz.service.CatfishRESTAPI;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.service.CatfishService;
import com.catfiz.service.CatfishUIBinder.DatabaseRequestOP;
import com.catfiz.service.ICatfishClientInterface;
import com.catfiz.service.IDropableRunnable;
import com.catfiz.util.Log;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class PoolTopicDataUploadExecutor implements Runnable {
    private static final String TAG = "PoolDataUploadExecutor";
    public static final int mChunkMaxSize = 262144;
    private static ICatfishClientInterface mClientInterface = null;
    private static String mDataPath = null;
    private static String mServer = null;
    private static String mUsername = null;
    private static String mUserpin = null;
    private static String topic_key = null;
    public boolean bNeedRead = true;
    private int datatype = 0;
    public int mBytestart = 0;
    public byte[] mChunkbuffer = null;
    public int mChunksent = 0;
    public int mChunksize = 0;
    public FileInputStream mChunkstream = null;
    public File mDataFile = null;
    public int mDatasize = 0;
    CatfishMessageObject mMessageObject = null;
    private volatile long mObjSequence = 0;
    private String mRcpts = null;
    private String[] mRecipients = null;
    private long mSequence = 0;
    private CatfishService mService = null;

    public enum PoolDataType {
        FILE,
        VOICE,
        IMAGE
    }

    class PoolDataUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private PoolDataUploadChunk() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (PoolTopicDataUploadExecutor.this.mChunkstream == null) {
                PoolTopicDataUploadExecutor.this.mChunkbuffer = null;
                return;
            }
            try {
                if (PoolTopicDataUploadExecutor.this.bNeedRead) {
                    PoolTopicDataUploadExecutor.this.bNeedRead = false;
                    PoolTopicDataUploadExecutor.this.mChunksize = PoolTopicDataUploadExecutor.this.mChunkstream.read(PoolTopicDataUploadExecutor.this.mChunkbuffer, 0, PoolTopicDataUploadExecutor.mChunkMaxSize);
                }
                if (PoolTopicDataUploadExecutor.this.mChunksize <= 0) {
                    Log.d(PoolTopicDataUploadExecutor.TAG, "----POOLBCAST: SENT COMPLETE");
                    try {
                        PoolTopicDataUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    PoolTopicDataUploadExecutor.this.mService.postToServiceHandler(new PoolUploadNotifyMember(), 2);
                    PoolTopicDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyUploadCompleate());
                    PoolTopicDataUploadExecutor.this.mChunkbuffer = null;
                    return;
                }
                CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(PoolTopicDataUploadExecutor.mServer, PoolTopicDataUploadExecutor.mUserpin, PoolTopicDataUploadExecutor.this.mObjSequence, PoolTopicDataUploadExecutor.this.mDatasize, PoolTopicDataUploadExecutor.this.mBytestart, PoolTopicDataUploadExecutor.this.mChunksize, PoolTopicDataUploadExecutor.this.mChunkbuffer);
                if (uploadDataChunk.hasSuccess()) {
                    if (uploadDataChunk.byteend == 0) {
                        Log.d(PoolTopicDataUploadExecutor.TAG, "----Byte End is 0: RESEND");
                        PoolTopicDataUploadExecutor.this.bNeedRead = false;
                        PoolTopicDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        return;
                    } else if (PoolTopicDataUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - PoolTopicDataUploadExecutor.this.mBytestart) + 1) {
                        Log.d(PoolTopicDataUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                        PoolTopicDataUploadExecutor.this.mChunkbuffer = null;
                        try {
                            PoolTopicDataUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e2) {
                        }
                        uploadDataChunk.cleaningup();
                        return;
                    } else {
                        PoolTopicDataUploadExecutor poolTopicDataUploadExecutor = PoolTopicDataUploadExecutor.this;
                        poolTopicDataUploadExecutor.mChunksent += (uploadDataChunk.byteend - PoolTopicDataUploadExecutor.this.mBytestart) + 1;
                        PoolTopicDataUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                        PoolTopicDataUploadExecutor.this.bNeedRead = true;
                        PoolTopicDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                    }
                } else if (uploadDataChunk.hasFailure()) {
                    PoolTopicDataUploadExecutor.mServer = CatfishService.getServerHost();
                    PoolTopicDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                } else {
                    Log.e(PoolTopicDataUploadExecutor.TAG, "----POOLBCAST: ERROR: DROP");
                    PoolTopicDataUploadExecutor.this.mChunkbuffer = null;
                    try {
                        PoolTopicDataUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e3) {
                    }
                }
                uploadDataChunk.cleaningup();
            } catch (IOException e4) {
                PoolTopicDataUploadExecutor.this.mChunkbuffer = null;
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public class PoolDatabaseRespon implements Runnable {
        private Cursor ifcursor = null;
        private ICatfishClientInterface ifselfclient = null;
        private String uniqueKey = null;

        public PoolDatabaseRespon(ICatfishClientInterface iCatfishClientInterface, String str, Cursor cursor) {
            this.uniqueKey = str;
            this.ifselfclient = iCatfishClientInterface;
            this.ifcursor = cursor;
        }

        public void run() {
            if (this.ifselfclient != null && !this.ifselfclient.isFinish()) {
                String str = this.uniqueKey;
                PoolTopicDataUploadExecutor.this.mService;
                if (str.compareTo(CatfishService.CONVERSATION_DELETED) == 0) {
                    this.ifselfclient.onPoolTopicDeleted(null);
                    if (this.ifcursor != null) {
                        this.ifcursor.close();
                        return;
                    }
                    return;
                }
                this.ifselfclient.onDatabaseResponse(this.uniqueKey, this.ifselfclient.transfromDBCursor(DatabaseRequestOP.GET_POOL_DISCUSS, this.ifcursor, 0), 0);
            } else if (this.ifcursor != null) {
                this.ifcursor.close();
            }
        }
    }

    class PoolNotifyUploadCompleate implements Runnable {
        private PoolNotifyUploadCompleate() {
        }

        public void run() {
            PoolDataStorage poolDataStorage = new PoolDataStorage(PoolTopicDataUploadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            obtain.topic_key = PoolTopicDataUploadExecutor.topic_key;
            obtain.sequence = PoolTopicDataUploadExecutor.this.mSequence;
            obtain.deliverystatus = MessageDeliveryStatus.BCASTSENT;
            if (PoolTopicDataUploadExecutor.this.datatype == PoolDataType.VOICE.ordinal()) {
                obtain.message = PoolTopicDataUploadExecutor.this.mService.getString(R.string.voice_sent);
            } else {
                obtain.message = PoolTopicDataUploadExecutor.this.mService.getString(R.string.file) + " : " + PoolTopicDataUploadExecutor.this.mDataFile.getName() + " " + PoolTopicDataUploadExecutor.this.mService.getString(R.string.sent_upper);
            }
            if (poolDataStorage.updateDiscussContent(obtain)) {
                Cursor discuss = poolDataStorage.getDiscuss(obtain.topic_key);
                CatfishService access$800 = PoolTopicDataUploadExecutor.this.mService;
                PoolTopicDataUploadExecutor poolTopicDataUploadExecutor = PoolTopicDataUploadExecutor.this;
                ICatfishClientInterface access$1100 = PoolTopicDataUploadExecutor.mClientInterface;
                PoolTopicDataUploadExecutor.this.mService;
                access$800.postToMainHandler(new PoolDatabaseRespon(access$1100, CatfishService.GET_DISCUSS_MESSAGE_CONVERSATION_KEY, discuss));
            }
            obtain.recycle();
        }
    }

    class PoolUploadNotifyMember implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private PoolUploadNotifyMember() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult conferenceSendData = this.catfishRestAPI.conferenceSendData(PoolTopicDataUploadExecutor.mServer, PoolTopicDataUploadExecutor.mUserpin, PoolTopicDataUploadExecutor.mUsername, PoolTopicDataUploadExecutor.topic_key.split(":")[0], Long.parseLong(PoolTopicDataUploadExecutor.topic_key.split(":")[1]), MessageType.BCASTCONFERENCE.ordinal(), PoolTopicDataUploadExecutor.this.datatype == PoolDataType.VOICE.ordinal() ? "voice:" + PoolTopicDataUploadExecutor.this.mDataFile.getName() : "file:" + PoolTopicDataUploadExecutor.this.mDataFile.getName(), PoolTopicDataUploadExecutor.this.mSequence, PoolTopicDataUploadExecutor.this.mObjSequence);
            if (!conferenceSendData.hasSuccess()) {
                if (conferenceSendData.hasFailure()) {
                    PoolTopicDataUploadExecutor.mServer = CatfishService.getServerHost();
                    PoolTopicDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    return;
                }
                Log.e(PoolTopicDataUploadExecutor.TAG, "Error Sending Data: DROP");
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public PoolTopicDataUploadExecutor(ICatfishClientInterface iCatfishClientInterface, CatfishService catfishService, String str, String str2, String str3, String str4, String str5, int i) {
        topic_key = str4;
        mClientInterface = iCatfishClientInterface;
        this.mService = catfishService;
        mServer = str;
        mUserpin = str2;
        mUsername = str3;
        mDataPath = str5;
        this.mSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mObjSequence = this.mSequence;
        this.datatype = i;
        this.mDataFile = new File(str5);
        this.mDatasize = Long.valueOf(this.mDataFile.length()).intValue();
        try {
            this.mChunkstream = new FileInputStream(this.mDataFile);
            this.mChunkbuffer = new byte[mChunkMaxSize];
        } catch (FileNotFoundException e) {
            Log.e(TAG, "----POOLBCAST FAIL TO ACCESS DATA FILE: " + e.toString());
            this.mChunkstream = null;
        }
    }

    public void run() {
        PoolDataStorage poolDataStorage = new PoolDataStorage(this.mService);
        CatfishMessageObject obtain = CatfishMessageObject.obtain();
        obtain.userpin = mUserpin;
        obtain.username = mUsername;
        obtain.topic_key = topic_key;
        if (this.datatype == PoolDataType.VOICE.ordinal()) {
            obtain.voicefilepath = mDataPath;
        } else {
            obtain.datafile_path = mDataPath;
        }
        if (this.datatype == PoolDataType.VOICE.ordinal()) {
            this.mService.getString(R.string.sending_voice);
        } else {
            obtain.message = this.mService.getString(R.string.sending_file) + " : " + this.mDataFile.getName();
        }
        obtain.object_owner = topic_key.split(":")[0];
        obtain.object_sequence = Long.parseLong(topic_key.split(":")[1]);
        obtain.rcvtimestamp = this.mSequence;
        obtain.sequence = this.mSequence;
        obtain.messagetype = MessageType.BCASTCONFERENCE;
        if (poolDataStorage.storeSingleDiscuss(obtain)) {
            Cursor discuss = poolDataStorage.getDiscuss(obtain.topic_key);
            CatfishService catfishService = this.mService;
            ICatfishClientInterface iCatfishClientInterface = mClientInterface;
            CatfishService catfishService2 = this.mService;
            catfishService.postToMainHandler(new PoolDatabaseRespon(iCatfishClientInterface, CatfishService.GET_DISCUSS_MESSAGE_CONVERSATION_KEY, discuss));
        }
        obtain.recycle();
        this.mService.postToServiceHandler(new PoolDataUploadChunk(), 2);
    }
}

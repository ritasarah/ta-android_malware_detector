package com.catfiz.pool;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.Cursor;
import android.net.Uri;
import android.support.v4.content.LocalBroadcastManager;
import android.webkit.MimeTypeMap;
import com.albus.util.AlbusModelObject;
import com.catfiz.R;
import com.catfiz.intents.BroadcastIntents;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.service.CatfishMessageObject;
import com.catfiz.service.CatfishRESTAPI;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishRESTAPI.MessageType;
import com.catfiz.service.CatfishService;
import com.catfiz.service.CatfishUIBinder.DatabaseRequestOP;
import com.catfiz.service.ICatfishClientInterface;
import com.catfiz.service.IDropableRunnable;
import com.catfiz.service.ServerMessageDataStorage;
import com.catfiz.service.SlinkFileInfoExecutor;
import com.catfiz.service.uisvcexec.GetStreamThumbnailExecutor;
import com.catfiz.svcpersistent.DataStorageDownloadInfo.DataStorageStreamType;
import com.catfiz.svcpersistent.DataStorageUploadBase;
import com.catfiz.util.FizzlinkUtil;
import com.catfiz.util.Log;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import org.apache.http.HttpStatus;
import org.apache.http.protocol.HTTP;
import org.json.JSONException;
import org.json.JSONObject;

public class PoolDataUploadExecutor extends DataStorageUploadBase implements Runnable {
    private static final String LONG_MESSAGE = "_longmessage_";
    private static final String TAG = "PoolDataUploadExecutor";
    private static final int mChunkMaxSize = 262144;
    public static final byte[] messageCharSubstitute = new byte[]{(byte) -18, (byte) -86, (byte) -86};
    private boolean bNeedRead = true;
    private boolean cancelUpload = false;
    private int datatype = 0;
    private int mBytestart = 0;
    private BroadcastReceiver mCancelUploadReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            long longExtra = intent.getLongExtra(ServerMessageDataStorage.SEQUENCE, 0);
            if (longExtra == 0) {
                Log.d(PoolDataUploadExecutor.TAG, "INVALID SEQUENCE: DO NOT CANCEL");
            } else if (PoolDataUploadExecutor.this.mSequence == 0 || PoolDataUploadExecutor.this.mSequence != longExtra) {
                Log.d(PoolDataUploadExecutor.TAG, "Current Sequence is INVALID or 0: DO NOT CANCEL");
            } else {
                Log.d(PoolDataUploadExecutor.TAG, "-----BATALKAN DOWNLOAD ---- SEQ-NYA = " + longExtra + " OBJSEQ=" + PoolDataUploadExecutor.this.mObjSequence + " SEQ " + PoolDataUploadExecutor.this.mSequence);
                PoolDataUploadExecutor.this.cancelUpload = true;
            }
        }
    };
    private byte[] mChunkbuffer = null;
    private int mChunksent = 0;
    private int mChunksize = 0;
    private FileInputStream mChunkstream = null;
    private ICatfishClientInterface mClientInterface = null;
    private File mDataFile = null;
    private String mDataPath = null;
    private volatile int mDatasize = 0;
    private String mMessage = null;
    CatfishMessageObject mMessageObject = null;
    private volatile long mObjSequence = 0;
    private String mRawMessage = null;
    private String mRcpts = null;
    private String[] mRecipients = null;
    private long mSequence = 0;
    private volatile long mSequenceThumb = 0;
    private volatile String mServer = null;
    private CatfishService mService = null;
    private String mSlink = null;
    private String mThumburi = null;
    private volatile String mUsername = null;
    private volatile String mUserpin = null;
    private String topic_key = null;

    class GetSlinkFromServer implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        private boolean mIsSent;
        public int scheduleNum;
        private boolean send;

        private GetSlinkFromServer() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.send = true;
            this.mIsSent = false;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            CatfishResult slink = this.catfishRestAPI.getSlink(PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mSequence);
            if (slink.hasSuccess()) {
                PoolDataUploadExecutor.this.mSlink = slink.slink;
                if (PoolDataUploadExecutor.this.datatype == PoolDataType.VIDEO.ordinal()) {
                    PoolDataUploadExecutor.this.mService.postToServiceHandler(new GetStreamThumbnailExecutor(PoolDataUploadExecutor.this.mService, PoolDataUploadExecutor.this.mSlink), 2);
                    CatfishService access$000 = PoolDataUploadExecutor.this.mService;
                    CatfishService access$0002 = PoolDataUploadExecutor.this.mService;
                    long access$1100 = PoolDataUploadExecutor.this.mSequence;
                    PoolDataUploadExecutor.this.mService;
                    access$000.postRunnableToService(new SlinkFileInfoExecutor(access$0002, access$1100, CatfishService.getCurrentServerHost(), PoolDataUploadExecutor.this.mSlink, false, true), 2);
                }
                Log.d(PoolDataUploadExecutor.TAG, "----GetSlinkFromServer: SUCCESS !!!: " + PoolDataUploadExecutor.this.mSlink);
                PoolDataUploadExecutor.this.mService.postToServiceHandler(new PoolUploadNotifyMember(), 2);
                if (!(PoolDataUploadExecutor.this.datatype == PoolDataType.TOPIC_IMAGE.ordinal() || PoolDataUploadExecutor.this.datatype == PoolDataType.TOPIC_ATTACH.ordinal())) {
                    PoolDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyUploadComplete());
                }
            } else if (slink.hasFailure()) {
                Log.d(PoolDataUploadExecutor.TAG, "----GetSlinkFromServer: FAILURE !!!: Re Schedule");
                PoolDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                PoolDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(PoolDataUploadExecutor.TAG, "----GetSlinkFromServer: ERROR: DROP");
            }
            slink.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public enum PoolDataType {
        UNDEFINED,
        FILE,
        VOICE,
        IMAGE,
        TOPIC_IMAGE,
        TOPIC_ATTACH,
        FRIEND_PP,
        VIDEO,
        LONG_MESSAGE
    }

    class PoolDataUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private PoolDataUploadChunk() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
            Log.d(PoolDataUploadExecutor.TAG, "UPLOAD DROPPED");
            PoolDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyUploadFailed());
            LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
            PoolDataUploadExecutor.this.deleteTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), false);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            JSONObject jSONObject = new JSONObject();
            try {
                jSONObject.put("dataType", PoolDataUploadExecutor.this.datatype);
                jSONObject.put(ServerMessageDataStorage.MESSAGE, PoolDataUploadExecutor.this.mRawMessage);
                PoolDataUploadExecutor.this.updateTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), PoolDataUploadExecutor.this.mDataFile.getAbsolutePath(), PoolDataUploadExecutor.this.mDatasize, PoolDataUploadExecutor.this.mBytestart, DataStorageStreamType.POOL_DATA.ordinal(), jSONObject.toString(), false);
            } catch (JSONException e) {
                e.printStackTrace();
            }
            if (PoolDataUploadExecutor.this.mChunkstream == null) {
                Log.d(PoolDataUploadExecutor.TAG, "----POOLBCAST: INVALID CHUNKSTREAM (NULL): CANCELED");
                LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                intent.putExtra(CatfishService.PROGRESS_STATE, 4);
                LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent);
                PoolDataUploadExecutor.this.deleteTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), false);
                PoolDataUploadExecutor.this.mChunkbuffer = null;
                return;
            }
            try {
                if (PoolDataUploadExecutor.this.bNeedRead) {
                    PoolDataUploadExecutor.this.bNeedRead = false;
                    PoolDataUploadExecutor.this.mChunksize = PoolDataUploadExecutor.this.mChunkstream.read(PoolDataUploadExecutor.this.mChunkbuffer, 0, PoolDataUploadExecutor.mChunkMaxSize);
                }
                if (PoolDataUploadExecutor.this.mChunksize <= 0) {
                    Log.d(PoolDataUploadExecutor.TAG, "----POOLBCAST: SENT COMPLETE");
                    LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                    Log.d(PoolDataUploadExecutor.TAG, "mengirim broadcast 100 % untuk pool");
                    try {
                        PoolDataUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e2) {
                    }
                    PoolDataUploadExecutor.this.mService.postToServiceHandler(new SetDsName(), 2);
                    if (PoolDataUploadExecutor.this.datatype == PoolDataType.TOPIC_ATTACH.ordinal()) {
                        PoolDataUploadExecutor.this.mService.postToDBHandler(new Runnable() {
                            public void run() {
                                PoolDataStorage poolDataStorage = new PoolDataStorage(PoolDataUploadExecutor.this.mService);
                                CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
                                catfishMessageObject.topic_key = PoolDataUploadExecutor.this.topic_key;
                                catfishMessageObject.datafile_path = PoolDataUploadExecutor.this.mDataFile.getAbsolutePath();
                                poolDataStorage.updateSingleTopicContent(catfishMessageObject);
                            }
                        });
                    }
                    PoolDataUploadExecutor.this.deleteTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), false);
                    PoolDataUploadExecutor.this.mChunkbuffer = null;
                } else if (PoolDataUploadExecutor.this.cancelUpload) {
                    intent = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                    intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                    intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                    intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                    LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent);
                    PoolDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyUploadFailed());
                    PoolDataUploadExecutor.this.deleteTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), false);
                } else {
                    Log.d(PoolDataUploadExecutor.TAG, "Get byte range: bs=" + String.valueOf(PoolDataUploadExecutor.this.mBytestart) + ", " + "chsize=" + String.valueOf(PoolDataUploadExecutor.this.mChunksize) + ", " + "size=" + String.valueOf(PoolDataUploadExecutor.this.mDatasize) + ", ");
                    CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mObjSequence, PoolDataUploadExecutor.this.mDatasize, PoolDataUploadExecutor.this.mBytestart, PoolDataUploadExecutor.this.mChunksize, PoolDataUploadExecutor.this.mChunkbuffer);
                    if (PoolDataUploadExecutor.this.cancelUpload) {
                        intent = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                        intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
                        intent.putExtra(CatfishService.PROGRESS_STATE, 3);
                        intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                        LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent);
                        PoolDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyUploadFailed());
                        PoolDataUploadExecutor.this.deleteTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), false);
                        return;
                    }
                    Intent intent2;
                    if (uploadDataChunk.hasSuccess()) {
                        this.mAge = System.currentTimeMillis();
                        if (uploadDataChunk.byteend == 0) {
                            Log.d(PoolDataUploadExecutor.TAG, "----Byte End is 0: RESEND");
                            PoolDataUploadExecutor.this.bNeedRead = false;
                            intent = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                            intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                            intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                            intent.putExtra(CatfishService.PROGRESS_STATE, 4);
                            LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent);
                            PoolDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                            return;
                        } else if (PoolDataUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - PoolDataUploadExecutor.this.mBytestart) + 1) {
                            Log.d(PoolDataUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                            LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                            PoolDataUploadExecutor.this.mChunkbuffer = null;
                            try {
                                intent2 = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                                intent2.putExtra(CatfishService.PROGRESS_VALUE, 0);
                                intent2.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                                intent2.putExtra(CatfishService.PROGRESS_STATE, 4);
                                LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent2);
                                PoolDataUploadExecutor.this.mChunkstream.close();
                            } catch (IOException e3) {
                            }
                            PoolDataUploadExecutor.this.deleteTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), false);
                            uploadDataChunk.cleaningup();
                            return;
                        } else {
                            Log.d(PoolDataUploadExecutor.TAG, "Chunk Sent: " + String.valueOf(uploadDataChunk.byteend - PoolDataUploadExecutor.this.mBytestart) + " bytes: " + String.valueOf(PoolDataUploadExecutor.this.mBytestart) + "-" + String.valueOf(uploadDataChunk.byteend) + ": SELF RE-POST");
                            PoolDataUploadExecutor.this.mChunksent = PoolDataUploadExecutor.this.mChunksent + ((uploadDataChunk.byteend - PoolDataUploadExecutor.this.mBytestart) + 1);
                            PoolDataUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                            int access$3100 = (PoolDataUploadExecutor.this.mChunksent * 100) / PoolDataUploadExecutor.this.mDatasize;
                            Intent intent3 = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                            intent3.putExtra(CatfishService.PROGRESS_VALUE, access$3100);
                            intent3.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                            LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent3);
                            PoolDataUploadExecutor.this.bNeedRead = true;
                            PoolDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        }
                    } else if (uploadDataChunk.hasFailure()) {
                        Log.d(PoolDataUploadExecutor.TAG, "----POOLBCAST: FAILURE !!!: Re Schedule");
                        PoolDataUploadExecutor.this.bNeedRead = false;
                        PoolDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                        intent2 = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                        intent2.putExtra(CatfishService.PROGRESS_VALUE, 0);
                        intent2.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                        intent2.putExtra(CatfishService.PROGRESS_STATE, 4);
                        LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent2);
                        PoolDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    } else {
                        Log.e(PoolDataUploadExecutor.TAG, "----POOLBCAST: ERROR: DROP");
                        LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                        intent2 = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                        intent2.putExtra(CatfishService.PROGRESS_VALUE, 0);
                        intent2.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                        intent2.putExtra(CatfishService.PROGRESS_STATE, 4);
                        LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent2);
                        PoolDataUploadExecutor.this.mChunkbuffer = null;
                        try {
                            PoolDataUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e4) {
                        }
                        PoolDataUploadExecutor.this.deleteTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), false);
                    }
                    uploadDataChunk.cleaningup();
                }
            } catch (IOException e5) {
                LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                PoolDataUploadExecutor.this.mChunkbuffer = null;
                intent = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
                intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
                intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
                intent.putExtra(CatfishService.PROGRESS_STATE, 4);
                LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent);
                PoolDataUploadExecutor.this.deleteTaskState(String.valueOf(PoolDataUploadExecutor.this.mSequence), false);
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public class PoolDatabaseRespon implements Runnable {
        private Cursor ifcursor = null;
        private ICatfishClientInterface ifselfclient = null;
        private String uniqueKey = null;

        public PoolDatabaseRespon(ICatfishClientInterface iCatfishClientInterface, String str, Cursor cursor) {
            this.uniqueKey = str;
            this.ifselfclient = iCatfishClientInterface;
            this.ifcursor = cursor;
        }

        public void run() {
            if (this.ifselfclient != null && !this.ifselfclient.isFinish()) {
                String str = this.uniqueKey;
                PoolDataUploadExecutor.this.mService;
                if (str.compareTo(CatfishService.CONVERSATION_DELETED) == 0) {
                    this.ifselfclient.onPoolTopicDeleted(null);
                    if (this.ifcursor != null) {
                        this.ifcursor.close();
                        return;
                    }
                    return;
                }
                this.ifselfclient.onDatabaseResponse(this.uniqueKey, this.ifselfclient.transfromDBCursor(DatabaseRequestOP.GET_POOL_DISCUSS, this.ifcursor, 0), 0);
            } else if (this.ifcursor != null) {
                this.ifcursor.close();
            }
        }
    }

    public class PoolNotifyThumbnailReady implements Runnable {
        private String thumb_uri = null;

        public PoolNotifyThumbnailReady(Uri uri) {
            if (uri != null) {
                this.thumb_uri = uri.toString();
            }
            PoolDataUploadExecutor.this.mThumburi = this.thumb_uri;
        }

        public void run() {
            PoolDataStorage poolDataStorage = new PoolDataStorage(PoolDataUploadExecutor.this.mService);
            CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
            catfishMessageObject.topic_key = PoolDataUploadExecutor.this.topic_key;
            catfishMessageObject.imagethumb_uri = this.thumb_uri;
            Cursor allTopic;
            CatfishService access$000;
            PoolDataUploadExecutor poolDataUploadExecutor;
            ICatfishClientInterface access$3900;
            if (PoolDataUploadExecutor.this.datatype == PoolDataType.TOPIC_IMAGE.ordinal()) {
                catfishMessageObject.image_path = PoolDataUploadExecutor.this.mDataFile.getAbsolutePath();
                if (this.thumb_uri != null) {
                    poolDataStorage.updateSingleTopicContent(catfishMessageObject);
                }
                allTopic = poolDataStorage.getAllTopic();
                access$000 = PoolDataUploadExecutor.this.mService;
                poolDataUploadExecutor = PoolDataUploadExecutor.this;
                access$3900 = PoolDataUploadExecutor.this.mClientInterface;
                PoolDataUploadExecutor.this.mService;
                access$000.postToMainHandler(new PoolDatabaseRespon(access$3900, CatfishService.GET_ALL_TOPIC_CONVERSATION_KEY, allTopic));
            } else if (PoolDataUploadExecutor.this.datatype == PoolDataType.FILE.ordinal() || PoolDataUploadExecutor.this.datatype == PoolDataType.VIDEO.ordinal()) {
                catfishMessageObject.sequence = PoolDataUploadExecutor.this.mSequence;
                if (this.thumb_uri != null) {
                    poolDataStorage.updateDiscussContent(catfishMessageObject);
                }
                allTopic = poolDataStorage.getDiscuss(PoolDataUploadExecutor.this.topic_key);
                access$000 = PoolDataUploadExecutor.this.mService;
                poolDataUploadExecutor = PoolDataUploadExecutor.this;
                access$3900 = PoolDataUploadExecutor.this.mClientInterface;
                PoolDataUploadExecutor.this.mService;
                access$000.postToMainHandler(new PoolDatabaseRespon(access$3900, CatfishService.GET_DISCUSS_MESSAGE_CONVERSATION_KEY, allTopic));
            }
        }
    }

    class PoolNotifyUploadComplete implements Runnable {
        private PoolNotifyUploadComplete() {
        }

        public void run() {
            Log.d(PoolDataUploadExecutor.TAG, "Upload Complete. Notify UI");
            PoolDataStorage poolDataStorage = new PoolDataStorage(PoolDataUploadExecutor.this.mService);
            CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
            catfishMessageObject.topic_key = PoolDataUploadExecutor.this.topic_key;
            catfishMessageObject.sequence = PoolDataUploadExecutor.this.mSequence;
            catfishMessageObject.deliverystatus = MessageDeliveryStatus.BCASTSENT;
            catfishMessageObject.slink = PoolDataUploadExecutor.this.mSlink;
            if (PoolDataUploadExecutor.this.datatype == PoolDataType.VOICE.ordinal()) {
                catfishMessageObject.message = PoolDataUploadExecutor.this.mService.getString(R.string.voice_sent);
            } else if (PoolDataUploadExecutor.this.mMessage == null || PoolDataUploadExecutor.this.mMessage.length() <= 0) {
                catfishMessageObject.message = PoolDataStorage.messageWithMetaInfoBuilder("", PoolDataUploadExecutor.this.mDataFile);
            } else {
                catfishMessageObject.message = PoolDataStorage.messageWithMetaInfoBuilder(PoolDataUploadExecutor.this.mMessage, PoolDataUploadExecutor.this.mDataFile);
            }
            PoolDataUploadExecutor.this.topic_key + String.valueOf(PoolDataUploadExecutor.this.mSequence);
            catfishMessageObject.updateLastMessageStatus = true;
            if (poolDataStorage.updateDiscussContent(catfishMessageObject)) {
                Log.d(PoolDataUploadExecutor.TAG, "UPDATE POOL CONTENT: SUCCESS");
            } else {
                Log.d(PoolDataUploadExecutor.TAG, "UPDATE POOL CONTENT: FAIL");
            }
            Cursor discuss = poolDataStorage.getDiscuss(catfishMessageObject.topic_key);
            CatfishService access$000 = PoolDataUploadExecutor.this.mService;
            PoolDataUploadExecutor poolDataUploadExecutor = PoolDataUploadExecutor.this;
            ICatfishClientInterface access$3900 = PoolDataUploadExecutor.this.mClientInterface;
            PoolDataUploadExecutor.this.mService;
            access$000.postToMainHandler(new PoolDatabaseRespon(access$3900, CatfishService.GET_DISCUSS_MESSAGE_CONVERSATION_KEY, discuss));
            Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
            intent.putExtra(CatfishService.PROGRESS_VALUE, HttpStatus.SC_SWITCHING_PROTOCOLS);
            intent.putExtra(CatfishService.PROGRESS_STATE, 2);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, PoolDataUploadExecutor.this.mSequence);
            LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).sendBroadcast(intent);
        }
    }

    class PoolNotifyUploadFailed implements Runnable {
        private PoolNotifyUploadFailed() {
        }

        public void run() {
            PoolDataStorage poolDataStorage = new PoolDataStorage(PoolDataUploadExecutor.this.mService);
            CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
            catfishMessageObject.topic_key = PoolDataUploadExecutor.this.topic_key;
            catfishMessageObject.sequence = PoolDataUploadExecutor.this.mSequence;
            catfishMessageObject.message = PoolDataStorage.messageWithMetaInfoBuilder("", PoolDataUploadExecutor.this.mDataFile);
            catfishMessageObject.deliverystatus = MessageDeliveryStatus.BCASTFAIL;
            catfishMessageObject.updateLastMessageStatus = true;
            if (poolDataStorage.updateDiscussContent(catfishMessageObject)) {
                Cursor discuss = poolDataStorage.getDiscuss(catfishMessageObject.topic_key);
                CatfishService access$000 = PoolDataUploadExecutor.this.mService;
                PoolDataUploadExecutor poolDataUploadExecutor = PoolDataUploadExecutor.this;
                ICatfishClientInterface access$3900 = PoolDataUploadExecutor.this.mClientInterface;
                PoolDataUploadExecutor.this.mService;
                access$000.postToMainHandler(new PoolDatabaseRespon(access$3900, CatfishService.GET_DISCUSS_MESSAGE_CONVERSATION_KEY, discuss));
            }
        }
    }

    class PoolUploadNotifyMember implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        public int scheduleNum;

        private PoolUploadNotifyMember() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            r9 = PoolDataUploadExecutor.this.datatype == PoolDataType.VOICE.ordinal() ? "voice:" + PoolDataUploadExecutor.this.mDataFile.getName() : PoolDataUploadExecutor.this.datatype == PoolDataType.TOPIC_IMAGE.ordinal() ? "topic_image:" + PoolDataUploadExecutor.this.mDataFile.getName() : PoolDataUploadExecutor.this.datatype == PoolDataType.TOPIC_ATTACH.ordinal() ? "topic_attach:" + PoolDataUploadExecutor.this.mDataFile.getName() : PoolDataUploadExecutor.this.datatype == PoolDataType.FRIEND_PP.ordinal() ? "friend_pp:" + PoolDataUploadExecutor.this.mDataFile.getName() : PoolDataUploadExecutor.this.datatype == PoolDataType.VIDEO.ordinal() ? "video:" + PoolDataUploadExecutor.this.mDataFile.getName() + ":" + PoolDataUploadExecutor.this.mMessage : "file:" + PoolDataUploadExecutor.this.mDataFile.getName() + ":" + PoolDataUploadExecutor.this.mMessage + ":" + PoolDataUploadExecutor.this.mSlink;
            CatfishResult conferenceSendData = PoolDataUploadExecutor.this.datatype == PoolDataType.TOPIC_IMAGE.ordinal() ? this.catfishRestAPI.conferenceSendData(PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mUsername, PoolDataUploadExecutor.this.topic_key.split(":")[0], Long.parseLong(PoolDataUploadExecutor.this.topic_key.split(":")[1]), MessageType.BCASTCONFERENCE.ordinal(), r9, PoolDataUploadExecutor.this.mSequence, PoolDataUploadExecutor.this.mObjSequence) : PoolDataUploadExecutor.this.datatype == PoolDataType.TOPIC_ATTACH.ordinal() ? this.catfishRestAPI.conferenceSendData(PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mUsername, PoolDataUploadExecutor.this.topic_key.split(":")[0], Long.parseLong(PoolDataUploadExecutor.this.topic_key.split(":")[1]), MessageType.BCASTCONFERENCE.ordinal(), r9, PoolDataUploadExecutor.this.mSequence, PoolDataUploadExecutor.this.mObjSequence) : PoolDataUploadExecutor.this.datatype == PoolDataType.VIDEO.ordinal() ? this.catfishRestAPI.conferenceSendData(PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mUsername, PoolDataUploadExecutor.this.topic_key.split(":")[0], Long.parseLong(PoolDataUploadExecutor.this.topic_key.split(":")[1]), MessageType.BCASTCONFERENCE_VIDEO.ordinal(), r9, PoolDataUploadExecutor.this.mSequence, PoolDataUploadExecutor.this.mObjSequence) : this.catfishRestAPI.conferenceSendData(PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mUsername, PoolDataUploadExecutor.this.topic_key.split(":")[0], Long.parseLong(PoolDataUploadExecutor.this.topic_key.split(":")[1]), MessageType.BCASTCONFERENCE.ordinal(), r9, PoolDataUploadExecutor.this.mSequence, PoolDataUploadExecutor.this.mObjSequence);
            if (!conferenceSendData.hasSuccess()) {
                if (conferenceSendData.hasFailure()) {
                    PoolDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                    PoolDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    return;
                }
                Log.e(PoolDataUploadExecutor.TAG, "Error Sending Data: DROP");
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class SetDsName implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private long mAge;
        private boolean mIsSent;
        public int scheduleNum;
        private boolean send;

        private SetDsName() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.send = true;
            this.mIsSent = false;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public String getMimeType(String str) {
            String fileExtensionFromUrl = MimeTypeMap.getFileExtensionFromUrl(str);
            return fileExtensionFromUrl != null ? MimeTypeMap.getSingleton().getMimeTypeFromExtension(fileExtensionFromUrl) : null;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            String safeFileName = Utils.getSafeFileName(PoolDataUploadExecutor.this.mDataFile.getName());
            int fizzlinkTypeFromExtension = FizzlinkUtil.getFizzlinkTypeFromExtension(PoolDataUploadExecutor.this.mDataFile);
            JSONObject jSONObject = new JSONObject();
            try {
                File file = new File(PoolDataUploadExecutor.this.mDataPath);
                if (PoolDataUploadExecutor.this.mMessage != null) {
                    jSONObject.put(AlbusModelObject.INTENT_DESC, PoolDataUploadExecutor.this.mMessage);
                } else {
                    jSONObject.put(AlbusModelObject.INTENT_DESC, "");
                }
                jSONObject.put("objsequencethumb", PoolDataUploadExecutor.this.mSequenceThumb);
                Log.d(PoolDataUploadExecutor.TAG, "!@@@ objsequencethumb:" + PoolDataUploadExecutor.this.mSequenceThumb + " ownerpin:" + PoolDataUploadExecutor.this.mUserpin);
            } catch (JSONException e) {
                e.printStackTrace();
            }
            String jSONObject2 = jSONObject.toString();
            Log.e(PoolDataUploadExecutor.TAG, "obyek owner:" + PoolDataUploadExecutor.this.mUserpin + " objsequence:" + PoolDataUploadExecutor.this.mSequence);
            CatfishResult dsName = this.catfishRestAPI.setDsName(PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mSequence, safeFileName, fizzlinkTypeFromExtension, jSONObject2);
            if (dsName.hasSuccess()) {
                if (PoolDataUploadExecutor.this.mThumburi == null) {
                    Log.d(PoolDataUploadExecutor.TAG, "@@@ mThumburi null");
                    PoolDataUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(), 2);
                    return;
                }
                try {
                    Uri parse = Uri.parse(PoolDataUploadExecutor.this.mThumburi);
                    File file2 = new File(parse.getPath());
                    Log.d(PoolDataUploadExecutor.TAG, "++++ myUri.getPath:" + parse.getPath() + "+++");
                    PoolDataUploadExecutor.this.mDatasize = Long.valueOf(file2.length()).intValue();
                    PoolDataUploadExecutor.this.mChunkstream = new FileInputStream(file2);
                    PoolDataUploadExecutor.this.mChunkbuffer = new byte[PoolDataUploadExecutor.mChunkMaxSize];
                    PoolDataUploadExecutor.this.mBytestart = 0;
                    PoolDataUploadExecutor.this.bNeedRead = true;
                    PoolDataUploadExecutor.this.mService.postToServiceHandler(new ThumbUploadChunk(PoolDataUploadExecutor.this.mMessage), 2);
                } catch (FileNotFoundException e2) {
                    PoolDataUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(), 2);
                    return;
                }
            } else if (dsName.hasFailure()) {
                Log.d(PoolDataUploadExecutor.TAG, "----SetDsName: FAILURE !!!: Re Schedule");
                PoolDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                PoolDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
            } else {
                Log.e(PoolDataUploadExecutor.TAG, "----SetDsName: ERROR: DROP");
            }
            dsName.cleaningup();
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class ThumbUploadChunk implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI = null;
        private volatile long mAge = System.currentTimeMillis();
        private String mMsg = null;
        public int scheduleNum = 0;

        public ThumbUploadChunk(String str) {
            this.mMsg = str;
        }

        public void dropRunnable() {
            LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void run() {
            if (PoolDataUploadExecutor.this.mChunkstream == null) {
                Log.d(PoolDataUploadExecutor.TAG, "----DPOOLSHARE_THUMB: INVALID CHUNKSTREAM (NULL): CANCELED");
                LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                PoolDataUploadExecutor.this.mChunkbuffer = null;
                return;
            }
            try {
                if (PoolDataUploadExecutor.this.bNeedRead) {
                    PoolDataUploadExecutor.this.bNeedRead = false;
                    PoolDataUploadExecutor.this.mChunksize = PoolDataUploadExecutor.this.mChunkstream.read(PoolDataUploadExecutor.this.mChunkbuffer, 0, PoolDataUploadExecutor.mChunkMaxSize);
                }
                if (PoolDataUploadExecutor.this.mChunksize <= 0) {
                    Log.d(PoolDataUploadExecutor.TAG, "----DPOOLSHARE_THUMB: SENT COMPLETE-----@@@@");
                    Log.d(PoolDataUploadExecutor.TAG, "!@@@ object sequence:" + PoolDataUploadExecutor.this.mSequenceThumb + " object owner" + PoolDataUploadExecutor.this.mUserpin);
                    LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                    Log.d(PoolDataUploadExecutor.TAG, "----DPOOLSHARE_THUMB: Post To Notify Recipients");
                    PoolDataUploadExecutor.this.mService.postToServiceHandler(new GetSlinkFromServer(), 2);
                    try {
                        PoolDataUploadExecutor.this.mChunkstream.close();
                    } catch (IOException e) {
                    }
                    PoolDataUploadExecutor.this.mChunkbuffer = null;
                } else if (PoolDataUploadExecutor.this.cancelUpload) {
                    Log.d(PoolDataUploadExecutor.TAG, "canceling upload is on progress.....");
                    LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                } else {
                    CatfishResult uploadDataChunk = this.catfishRestAPI.uploadDataChunk(PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mSequenceThumb, PoolDataUploadExecutor.this.mDatasize, PoolDataUploadExecutor.this.mBytestart, PoolDataUploadExecutor.this.mChunksize, PoolDataUploadExecutor.this.mChunkbuffer);
                    if (PoolDataUploadExecutor.this.cancelUpload) {
                        Log.d(PoolDataUploadExecutor.TAG, "canceling upload is on progress.....");
                        LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                        return;
                    }
                    if (uploadDataChunk.hasSuccess()) {
                        this.mAge = System.currentTimeMillis();
                        if (uploadDataChunk.byteend == 0) {
                            Log.d(PoolDataUploadExecutor.TAG, "----Byte End is 0: RESEND");
                            PoolDataUploadExecutor.this.bNeedRead = false;
                            this.mAge = System.currentTimeMillis();
                            PoolDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                            return;
                        } else if (PoolDataUploadExecutor.this.mChunksize != (uploadDataChunk.byteend - PoolDataUploadExecutor.this.mBytestart) + 1) {
                            Log.d(PoolDataUploadExecutor.TAG, "----TODO: HANDLE THIS BUFFERING PROBLEM: SERVER ACCEPT LESS THAN WE WANT TO.: DROP");
                            LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                            PoolDataUploadExecutor.this.mChunkbuffer = null;
                            try {
                                PoolDataUploadExecutor.this.mChunkstream.close();
                            } catch (IOException e2) {
                            }
                            uploadDataChunk.cleaningup();
                            return;
                        } else {
                            Log.d(PoolDataUploadExecutor.TAG, "Chunk Sent: " + String.valueOf(uploadDataChunk.byteend - PoolDataUploadExecutor.this.mBytestart) + " bytes: " + String.valueOf(PoolDataUploadExecutor.this.mBytestart) + "-" + String.valueOf(uploadDataChunk.byteend) + ": SELF RE-POST");
                            PoolDataUploadExecutor.this.mChunksent = PoolDataUploadExecutor.this.mChunksent + ((uploadDataChunk.byteend - PoolDataUploadExecutor.this.mBytestart) + 1);
                            PoolDataUploadExecutor.this.mBytestart = uploadDataChunk.byteend + 1;
                            int access$1700 = (PoolDataUploadExecutor.this.mBytestart * 100) / PoolDataUploadExecutor.this.mDatasize;
                            PoolDataUploadExecutor.this.bNeedRead = true;
                            PoolDataUploadExecutor.this.mService.postToServiceHandler(this, 2);
                        }
                    } else if (uploadDataChunk.hasFailure()) {
                        Log.d(PoolDataUploadExecutor.TAG, "----DPOOLSHARE_THUMB: FAILURE !!!: Re Schedule");
                        PoolDataUploadExecutor.this.bNeedRead = false;
                        PoolDataUploadExecutor.this.mServer = CatfishService.getServerHost();
                        PoolDataUploadExecutor.this.mService.scheduleRunnableToService(this, 2);
                    } else {
                        Log.e(PoolDataUploadExecutor.TAG, "----DPOOLSHARE_THUMB: ERROR: DROP");
                        LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                        PoolDataUploadExecutor.this.mChunkbuffer = null;
                        try {
                            PoolDataUploadExecutor.this.mChunkstream.close();
                        } catch (IOException e3) {
                        }
                    }
                    uploadDataChunk.cleaningup();
                }
            } catch (IOException e4) {
                Log.d(PoolDataUploadExecutor.TAG, "----DPOOLSHARE_THUMB: FAIL TO READ STREAM: CANCELED");
                LocalBroadcastManager.getInstance(PoolDataUploadExecutor.this.mService).unregisterReceiver(PoolDataUploadExecutor.this.mCancelUploadReceiver);
                PoolDataUploadExecutor.this.mChunkbuffer = null;
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    public PoolDataUploadExecutor(ICatfishClientInterface iCatfishClientInterface, CatfishService catfishService, String str, String str2, String str3, String str4, String str5, int i, String str6) {
        this.topic_key = str4;
        this.mClientInterface = iCatfishClientInterface;
        this.mService = catfishService;
        this.mServer = str;
        this.mUserpin = str2;
        this.mUsername = str3;
        this.mDataPath = str5;
        this.mSequence = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mSequenceThumb = CatfishRESTAPI.uniqueMonotonicSequence();
        this.mObjSequence = this.mSequence;
        this.datatype = i;
        this.mRawMessage = str6;
        if (str6 != null) {
            try {
                this.mMessage = str6.replace(":", new String(messageCharSubstitute, HTTP.UTF_8));
            } catch (UnsupportedEncodingException e) {
                this.mMessage = str6;
                e.printStackTrace();
            }
        }
        this.mDataFile = new File(str5);
        this.mDatasize = Long.valueOf(this.mDataFile.length()).intValue();
        Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
        intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
        intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
        LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
        LocalBroadcastManager.getInstance(this.mService).registerReceiver(this.mCancelUploadReceiver, new IntentFilter(BroadcastIntents.ACTION_CANCEL_POOL_UPLOAD));
    }

    public void run() {
        try {
            String str;
            this.mChunkstream = new FileInputStream(this.mDataFile);
            this.mChunkbuffer = new byte[mChunkMaxSize];
            if (isResumeProcess()) {
                this.mBytestart = getResumeUploadData().mBytestart;
                this.mChunksent = this.mBytestart;
                this.mSequence = Long.parseLong(getResumeUploadData().mKey);
                this.mObjSequence = this.mSequence;
                try {
                    this.mChunkstream.skip((long) this.mBytestart);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            PoolDataStorage poolDataStorage = new PoolDataStorage(this.mService);
            CatfishMessageObject catfishMessageObject = new CatfishMessageObject();
            catfishMessageObject.userpin = this.mUserpin;
            catfishMessageObject.username = this.mUsername;
            catfishMessageObject.topic_key = this.topic_key;
            if (this.datatype == PoolDataType.VOICE.ordinal()) {
                catfishMessageObject.voicefilepath = this.mDataPath;
            } else {
                catfishMessageObject.datafile_path = this.mDataPath;
            }
            try {
                if (this.mMessage != null) {
                    this.mMessage = this.mMessage.replace(new String(messageCharSubstitute, HTTP.UTF_8), ":");
                }
            } catch (UnsupportedEncodingException e2) {
                e2.printStackTrace();
            }
            if (this.mMessage == null || this.mMessage.length() <= 0) {
                catfishMessageObject.message = PoolDataStorage.messageWithMetaInfoBuilder("", this.mDataFile);
            } else {
                catfishMessageObject.message = PoolDataStorage.messageWithMetaInfoBuilder(this.mMessage, this.mDataFile);
            }
            catfishMessageObject.object_owner = this.topic_key.split(":")[0];
            catfishMessageObject.object_sequence = Long.parseLong(this.topic_key.split(":")[1]);
            catfishMessageObject.rcvtimestamp = this.mSequence;
            catfishMessageObject.sequence = this.mSequence;
            catfishMessageObject.deliverystatus = MessageDeliveryStatus.QUEUEING;
            if (this.datatype == PoolDataType.VIDEO.ordinal()) {
                catfishMessageObject.messagetype = MessageType.BCASTCONFERENCE_VIDEO;
            } else {
                catfishMessageObject.messagetype = MessageType.BCASTCONFERENCE;
            }
            if (this.datatype == PoolDataType.TOPIC_IMAGE.ordinal() || this.datatype == PoolDataType.TOPIC_ATTACH.ordinal() || this.datatype == PoolDataType.FRIEND_PP.ordinal()) {
                if (this.datatype == PoolDataType.TOPIC_IMAGE.ordinal()) {
                    new ImageThumbnailer(this.mService, catfishMessageObject.userpin, 0) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                PoolDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyThumbnailReady(uri));
                                Log.d(PoolDataUploadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                                return;
                            }
                            Log.d(PoolDataUploadExecutor.TAG, "Thumbnail FAIL to create");
                        }
                    }.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
                } else if (this.datatype == PoolDataType.TOPIC_IMAGE.ordinal()) {
                    this.mService.postToDBHandler(new PoolNotifyThumbnailReady(null));
                }
            } else if (poolDataStorage.storeSingleDiscuss(catfishMessageObject)) {
                str = catfishMessageObject.message;
                if (catfishMessageObject.message.split(":").length > 2) {
                    catfishMessageObject.message = catfishMessageObject.message.split(":")[2];
                } else {
                    catfishMessageObject.message = this.mService.getString(R.string.gallery_no_message);
                }
                catfishMessageObject.senderpin = catfishMessageObject.userpin;
                catfishMessageObject.sendername = catfishMessageObject.username;
                catfishMessageObject.message = str;
                Cursor discuss = poolDataStorage.getDiscuss(catfishMessageObject.topic_key);
                CatfishService catfishService = this.mService;
                ICatfishClientInterface iCatfishClientInterface = this.mClientInterface;
                CatfishService catfishService2 = this.mService;
                catfishService.postToMainHandler(new PoolDatabaseRespon(iCatfishClientInterface, CatfishService.GET_DISCUSS_MESSAGE_CONVERSATION_KEY, discuss));
            }
            if (this.datatype == PoolDataType.FILE.ordinal()) {
                str = this.mDataFile.getName();
                Log.d(TAG, "url :" + str);
                if (Utils.getFileTypeFromPath(str) == 1) {
                    new ImageThumbnailer(this.mService, catfishMessageObject.userpin, 0, 2.0f) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                PoolDataUploadExecutor.this.mService.postToServiceHandler(new PoolThumbnailUploader(PoolDataUploadExecutor.this.mService, PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mUsername, PoolDataUploadExecutor.this.topic_key, uri, PoolDataUploadExecutor.this.mObjSequence), 2);
                                PoolDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyThumbnailReady(uri));
                                Log.d(PoolDataUploadExecutor.TAG, "Thumbnail is created: " + uri.toString());
                                return;
                            }
                            Log.d(PoolDataUploadExecutor.TAG, "Thumbnail FAIL to create");
                        }
                    }.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
                } else if (Utils.getFileTypeFromPath(str) == 6) {
                    new ImageThumbnailer(this.mService, catfishMessageObject.userpin, 0, true, this.mDataFile.getAbsolutePath()) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                PoolDataUploadExecutor.this.mService.postToServiceHandler(new PoolThumbnailUploader(PoolDataUploadExecutor.this.mService, PoolDataUploadExecutor.this.mServer, PoolDataUploadExecutor.this.mUserpin, PoolDataUploadExecutor.this.mUsername, PoolDataUploadExecutor.this.topic_key, uri, PoolDataUploadExecutor.this.mObjSequence), 2);
                                PoolDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyThumbnailReady(uri));
                                return;
                            }
                            PoolDataUploadExecutor.this.mService.postToDBHandler(new PoolNotifyThumbnailReady(null));
                        }
                    }.execute(new Uri[]{Uri.fromFile(this.mDataFile)});
                } else {
                    this.mService.postToDBHandler(new PoolNotifyThumbnailReady(null));
                }
            }
            Intent intent = new Intent(BroadcastIntents.ACTION_UPLOAD_POOL);
            intent.putExtra(CatfishService.PROGRESS_VALUE, 0);
            intent.putExtra(ServerMessageDataStorage.SEQUENCE, this.mSequence);
            LocalBroadcastManager.getInstance(this.mService).sendBroadcast(intent);
            this.mService.postToServiceHandler(new PoolDataUploadChunk(), 2);
        } catch (FileNotFoundException e3) {
            Log.e(TAG, "----POOLBCAST FAIL TO ACCESS DATA FILE: " + e3.toString());
            this.mChunkstream = null;
        }
    }
}

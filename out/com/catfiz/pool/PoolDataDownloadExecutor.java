package com.catfiz.pool;

import android.net.Uri;
import android.os.Environment;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import com.catfiz.R;
import com.catfiz.media.ImageThumbnailer;
import com.catfiz.media.StorageDir;
import com.catfiz.pool.PoolDataUploadExecutor.PoolDataType;
import com.catfiz.service.CatfishMessageObject;
import com.catfiz.service.CatfishRESTAPI;
import com.catfiz.service.CatfishRESTAPI.CatfishResult;
import com.catfiz.service.CatfishRESTAPI.MessageDeliveryStatus;
import com.catfiz.service.CatfishService;
import com.catfiz.service.IDropableRunnable;
import com.catfiz.util.Log;
import com.catfiz.util.Utils;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import org.apache.commons.logging.impl.SimpleLog;
import org.apache.http.conn.routing.HttpRouteDirector;

public class PoolDataDownloadExecutor implements IDropableRunnable, Runnable {
    private static final String TAG = "PoolDataDownloadExecutor";
    private static int mChunkMaxSize = AccessibilityNodeInfoCompat.ACTION_COPY;
    private static String mDataPath = null;
    private static String mMessage = null;
    public static final String mParentFilePath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/pool/");
    public static final String mParentPPPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/files/");
    public static final String mParentVoicePath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/voice/");
    private static String mServer = null;
    private static String mUserpin = null;
    private CatfishRESTAPI catfishRestAPI = null;
    private int datatype = 0;
    private long mAge = 0;
    private int mByteend = 0;
    private int mBytestart = 0;
    private byte[] mChunkbuffer = null;
    private FileOutputStream mChunkstream = null;
    private File mDataFile = null;
    private int mDatasize = 0;
    private long mObjSequence = 0;
    public String mParentPath = (Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + CatfishService.FILE_PACKAGE_NAME_CATFIZ + "/pool/");
    private String mSenderpin = null;
    private long mSequence = 0;
    private CatfishService mService = null;
    private int mWriten = 0;
    private Uri photo_uri = null;
    public int scheduleNum = 0;
    private String topic_key = null;

    class GetDataStorageChunks implements IDropableRunnable, Runnable {
        private CatfishRESTAPI catfishRestAPI;
        private volatile long mAge;
        public int scheduleNum;

        private GetDataStorageChunks() {
            this.mAge = System.currentTimeMillis();
            this.catfishRestAPI = null;
            this.scheduleNum = 0;
        }

        public void dropRunnable() {
        }

        public long getAge() {
            return this.mAge;
        }

        public int getScheduleNum() {
            return this.scheduleNum;
        }

        public void incraseScheduleNum() {
            this.scheduleNum++;
        }

        public void proceedToCompleted() {
            try {
                PoolDataDownloadExecutor.this.mChunkstream.flush();
                PoolDataDownloadExecutor.this.mChunkstream.close();
            } catch (IOException e) {
            }
            if (PoolDataDownloadExecutor.this.datatype == PoolDataType.TOPIC_IMAGE.ordinal() || PoolDataDownloadExecutor.this.datatype == PoolDataType.FILE.ordinal()) {
                String name = PoolDataDownloadExecutor.this.mDataFile.getName();
                if (Utils.getFileTypeFromPath(name) == 1) {
                    new ImageThumbnailer(PoolDataDownloadExecutor.this.mService, PoolDataDownloadExecutor.this.mSenderpin, 0, 2.0f) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                PoolDataDownloadExecutor.this.photo_uri = uri;
                                PoolDataDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadCompleate());
                            }
                        }
                    }.execute(new Uri[]{Uri.fromFile(PoolDataDownloadExecutor.this.mDataFile)});
                    return;
                } else if (Utils.getFileTypeFromPath(name) == 6) {
                    new ImageThumbnailer(PoolDataDownloadExecutor.this.mService, PoolDataDownloadExecutor.this.mSenderpin, 0, true, PoolDataDownloadExecutor.this.mDataFile.getAbsolutePath()) {
                        protected void onPostExecute(Uri uri) {
                            if (uri != null) {
                                PoolDataDownloadExecutor.this.photo_uri = uri;
                                PoolDataDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadCompleate());
                                return;
                            }
                            PoolDataDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadCompleate());
                        }
                    }.execute(new Uri[]{Uri.fromFile(PoolDataDownloadExecutor.this.mDataFile)});
                    return;
                } else {
                    PoolDataDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadCompleate());
                    return;
                }
            }
            PoolDataDownloadExecutor.this.mService.postRunnableToDbThread(new PoolNotifyDownloadCompleate());
        }

        public void run() {
            Log.d(PoolDataDownloadExecutor.TAG, "Get byte range: bs=" + String.valueOf(PoolDataDownloadExecutor.this.mBytestart) + ", " + "be=" + String.valueOf(PoolDataDownloadExecutor.this.mByteend) + ", " + "size=" + String.valueOf(PoolDataDownloadExecutor.this.mDatasize) + ", " + "mWriten=" + String.valueOf(PoolDataDownloadExecutor.this.mWriten));
            CatfishResult downloadDataChunk = this.catfishRestAPI.downloadDataChunk(PoolDataDownloadExecutor.mServer, PoolDataDownloadExecutor.mUserpin, PoolDataDownloadExecutor.this.mSenderpin, PoolDataDownloadExecutor.this.mObjSequence, PoolDataDownloadExecutor.this.mBytestart, PoolDataDownloadExecutor.this.mByteend, PoolDataDownloadExecutor.this.mChunkstream);
            Log.d(PoolDataDownloadExecutor.TAG, "Chunksize: " + String.valueOf(downloadDataChunk.chunksize));
            if (downloadDataChunk.hasSuccess()) {
                if (downloadDataChunk.chunksize > 0) {
                    PoolDataDownloadExecutor.this.mWriten = PoolDataDownloadExecutor.this.mWriten + downloadDataChunk.chunksize;
                }
                if (PoolDataDownloadExecutor.this.mWriten < PoolDataDownloadExecutor.this.mDatasize) {
                    PoolDataDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.growChunkSize(PoolDataDownloadExecutor.mChunkMaxSize);
                    PoolDataDownloadExecutor.this.mBytestart = PoolDataDownloadExecutor.this.mWriten;
                    PoolDataDownloadExecutor.this.mByteend = (PoolDataDownloadExecutor.this.mBytestart + PoolDataDownloadExecutor.mChunkMaxSize) - 1;
                    this.mAge = System.currentTimeMillis();
                    PoolDataDownloadExecutor.this.mService.postToServiceHandler(this, 2);
                    downloadDataChunk.cleaningup();
                    return;
                }
                Log.d(PoolDataDownloadExecutor.TAG, "DSTORAGE RECEIVE: Get Data Chunk: DONE");
                proceedToCompleted();
                downloadDataChunk.cleaningup();
            } else if (downloadDataChunk.hasFailure()) {
                Log.d(PoolDataDownloadExecutor.TAG, "DSTORAGE RECEIVE: Get Data Chunk: FAIL: Reschedule");
                if (downloadDataChunk.chunksize > 0) {
                    PoolDataDownloadExecutor.this.mWriten = PoolDataDownloadExecutor.this.mWriten + downloadDataChunk.chunksize;
                    if (PoolDataDownloadExecutor.this.mWriten < PoolDataDownloadExecutor.this.mDatasize) {
                        PoolDataDownloadExecutor.this.mBytestart = PoolDataDownloadExecutor.this.mWriten;
                        PoolDataDownloadExecutor.this.mByteend = (PoolDataDownloadExecutor.this.mBytestart + PoolDataDownloadExecutor.mChunkMaxSize) - 1;
                        this.mAge = System.currentTimeMillis();
                        PoolDataDownloadExecutor.this.mService.postToServiceHandler(this, 2);
                        downloadDataChunk.cleaningup();
                        return;
                    }
                    Log.d(PoolDataDownloadExecutor.TAG, "DSTORAGE RECEIVE (In FAILURE): Get Data Chunk: DONE");
                    proceedToCompleted();
                    downloadDataChunk.cleaningup();
                    return;
                }
                PoolDataDownloadExecutor.mChunkMaxSize = CatfishRESTAPI.fallbackChunkSize(PoolDataDownloadExecutor.mChunkMaxSize);
                PoolDataDownloadExecutor.mServer = CatfishService.getServerHost();
                PoolDataDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
                downloadDataChunk.cleaningup();
            } else if (downloadDataChunk.hasNotFound()) {
                Log.d(PoolDataDownloadExecutor.TAG, "DSTORAGE RECEIVE: NOT FOUND, TRY TO WAIT AND GET AGAIN");
                PoolDataDownloadExecutor.this.mService.scheduleRunnableToService(this, 2);
                downloadDataChunk.cleaningup();
            } else {
                Log.d(PoolDataDownloadExecutor.TAG, "DSTORAGE RECEIVE: Get Data Chunk: ERROR: DROP");
                try {
                    PoolDataDownloadExecutor.this.mChunkstream.flush();
                    PoolDataDownloadExecutor.this.mChunkstream.close();
                } catch (IOException e) {
                }
                PoolDataDownloadExecutor.this.mChunkbuffer = null;
                downloadDataChunk.cleaningup();
            }
        }

        public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
            this.catfishRestAPI = catfishRESTAPI;
        }
    }

    class PoolNotifyDownloadCompleate implements Runnable {
        private PoolNotifyDownloadCompleate() {
        }

        public void run() {
            PoolDataStorage poolDataStorage = new PoolDataStorage(PoolDataDownloadExecutor.this.mService);
            CatfishMessageObject obtain = CatfishMessageObject.obtain();
            obtain.topic_key = PoolDataDownloadExecutor.this.topic_key;
            obtain.sequence = PoolDataDownloadExecutor.this.mSequence;
            if (PoolDataDownloadExecutor.this.datatype == PoolDataType.VOICE.ordinal()) {
                obtain.message = PoolDataDownloadExecutor.this.mService.getString(R.string.voice_received);
            } else if (PoolDataDownloadExecutor.this.datatype == PoolDataType.TOPIC_IMAGE.ordinal()) {
                poolDataStorage.deleteSingleDiscussConverence(PoolDataDownloadExecutor.this.topic_key, PoolDataDownloadExecutor.this.mSequence);
                obtain.image_path = PoolDataDownloadExecutor.this.mDataFile.getAbsolutePath();
                if (PoolDataDownloadExecutor.this.photo_uri != null) {
                    obtain.imagethumb_uri = PoolDataDownloadExecutor.this.photo_uri.toString();
                }
                poolDataStorage.updateSingleTopicContent(obtain);
            } else if (PoolDataDownloadExecutor.this.datatype == PoolDataType.TOPIC_ATTACH.ordinal()) {
                poolDataStorage.deleteSingleDiscussConverence(PoolDataDownloadExecutor.this.topic_key, PoolDataDownloadExecutor.this.mSequence);
                obtain.datafile_path = PoolDataDownloadExecutor.this.mDataFile.getAbsolutePath();
                poolDataStorage.updateSingleTopicContent(obtain);
            } else if (PoolDataDownloadExecutor.this.datatype == PoolDataType.FRIEND_PP.ordinal()) {
                poolDataStorage.deleteSingleDiscussConverence(PoolDataDownloadExecutor.this.topic_key, PoolDataDownloadExecutor.this.mSequence);
            } else {
                obtain.message = PoolDataStorage.messageWithMetaInfoBuilder(PoolDataDownloadExecutor.mMessage, PoolDataDownloadExecutor.this.mDataFile);
                if (PoolDataDownloadExecutor.this.photo_uri != null) {
                    obtain.imagethumb_uri = PoolDataDownloadExecutor.this.photo_uri.toString();
                }
            }
            obtain.deliverystatus = MessageDeliveryStatus.BCASTRECEIVED;
            obtain.rcvtimestamp = CatfishRESTAPI.uniqueMonotonicSequence();
            poolDataStorage.updateDiscussContent(obtain);
            PoolDataDownloadExecutor.this.mService.signalNewPoolMessageReceived(obtain.topic_key);
            obtain.recycle();
        }
    }

    public PoolDataDownloadExecutor(CatfishService catfishService, String str, String str2, String str3, String str4, String str5, long j, long j2) {
        this.mService = catfishService;
        mServer = str;
        mUserpin = str2;
        this.topic_key = str3;
        this.mSenderpin = str4;
        this.mSequence = j;
        this.mObjSequence = j2;
        if (str5.startsWith("file:")) {
            this.datatype = PoolDataType.FILE.ordinal();
            this.mParentPath = mParentFilePath;
        } else if (str5.startsWith("voice:")) {
            this.datatype = PoolDataType.VOICE.ordinal();
            this.mParentPath = mParentVoicePath;
        } else if (str5.startsWith("topic_image:")) {
            this.datatype = PoolDataType.TOPIC_IMAGE.ordinal();
            this.mParentPath = mParentFilePath;
        } else if (str5.startsWith("topic_attach:")) {
            this.datatype = PoolDataType.TOPIC_ATTACH.ordinal();
            this.mParentPath = mParentFilePath;
        } else if (str5.startsWith("friend_pp:")) {
            this.datatype = PoolDataType.FRIEND_PP.ordinal();
            this.mParentPath = mParentPPPath;
        }
        if (str5.split(":")[0] != null) {
            mMessage = str5.split(":")[1];
        } else {
            mMessage = str5;
        }
        switch (Utils.getFileTypeFromPath(mMessage)) {
            case e.b /*1*/:
                this.mParentPath = StorageDir.getGroupChatDir(0);
                break;
            case e.c /*2*/:
                this.mParentPath = StorageDir.getGroupChatDir(4);
                break;
            case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                this.mParentPath = StorageDir.getGroupChatDir(2);
                break;
            case SimpleLog.LOG_LEVEL_FATAL /*6*/:
                this.mParentPath = StorageDir.getGroupChatDir(1);
                break;
            default:
                this.mParentPath = StorageDir.getGroupChatDir(3);
                break;
        }
        mDataPath = this.mParentPath + String.valueOf(j) + mMessage;
        if (this.datatype == PoolDataType.FRIEND_PP.ordinal()) {
            mDataPath = this.mParentPath + mMessage;
        }
        Log.d(TAG, "(PoolDataDownload)simpan sebagai : " + mDataPath);
        this.mDataFile = new File(mDataPath);
        this.mAge = System.currentTimeMillis();
    }

    public void dropRunnable() {
    }

    public long getAge() {
        return this.mAge;
    }

    public int getScheduleNum() {
        return this.scheduleNum;
    }

    public void incraseScheduleNum() {
        this.scheduleNum++;
    }

    public void run() {
        String externalStorageState = Environment.getExternalStorageState();
        if (externalStorageState.equals("mounted")) {
            File parentFile = this.mDataFile.getParentFile();
            if (parentFile.exists() || parentFile.mkdirs()) {
                CatfishResult dataStorageInfo = this.catfishRestAPI.getDataStorageInfo(mServer, mUserpin, this.mSenderpin, this.mObjSequence);
                if (dataStorageInfo.hasFailure()) {
                    Log.d(TAG, "DSTORAGE RECEIVE: Get Info FAIL: Reschedule !!!");
                    mServer = CatfishService.getServerHost();
                    this.mService.scheduleRunnableToService(this, 2);
                    dataStorageInfo.cleaningup();
                    return;
                } else if (dataStorageInfo.hasNotFound()) {
                    Log.d(TAG, "DSTORAGE RECEIVE: NOT FOUND, TRY TO WAIT AND GET AGAIN");
                    this.mService.scheduleRunnableToService(this, 2);
                    dataStorageInfo.cleaningup();
                    return;
                } else if (dataStorageInfo.hasSuccess()) {
                    this.mDatasize = dataStorageInfo.datasize;
                    this.mByteend = mChunkMaxSize - 1;
                    try {
                        this.mChunkstream = new FileOutputStream(this.mDataFile);
                        this.mService.postToServiceHandler(new GetDataStorageChunks(), 2);
                        return;
                    } catch (FileNotFoundException e) {
                        Log.e(TAG, "VBCAST RECEIVE: " + e.toString());
                        return;
                    }
                } else {
                    Log.e(TAG, "DSTORAGE RECEIVE: ERROR: DROP !!!");
                    dataStorageInfo.cleaningup();
                    return;
                }
            }
            Log.e(TAG, "DSTORAGE RECEIVE: Path to file could not be created.");
            return;
        }
        Log.e(TAG, "DSTORAGE RECEIVE: media not mounted in is state: " + externalStorageState + ":DROP !!!");
    }

    public void setRestAPI(CatfishRESTAPI catfishRESTAPI) {
        this.catfishRestAPI = catfishRESTAPI;
    }
}

package com.catfiz.svcpersistent;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import com.catfiz.util.Log;

public class TaskDataStorage {
    public static final String ADDITIONAL_DATA = "additionaldata";
    public static final String AGE_TABLE_NAME = "agetable";
    public static final String CHANNELID = "channelid";
    public static final String CHUNKOFFSET = "chunkoffset";
    public static final String COMMONMESSAGE_TABLE_NAME = "commonmessage";
    public static final String DATASTORAGEDOWNLOAD_TABLE_NAME = "dsdownload";
    public static final String DATASTORAGEUPLOAD_TABLE_NAME = "dsupload";
    public static final String DATA_SIZE = "datasize";
    public static final String ENDBYTE = "endbyte";
    public static final String ENTITY_KEY = "entitykey";
    public static final String FILE_PATH = "filepath";
    public static final String MESSAGECONTEXT = "messagecontext";
    public static final String MESSAGETYPE = "messagetype";
    public static final String P2PDOWNLOAD_TABLE_NAME = "p2pdownload";
    public static final String P2PUPLOAD_TABLE_NAME = "p2pupload";
    public static final String RECIPIENT = "recipient";
    public static final String SENDERPIN = "senderpin";
    public static final String STARTBYTE = "startbyte";
    public static final String STREAMTYPE = "streamtype";
    private static final String TAG = "TaskDataStorage";
    public static final String TIMESTAMP = "timestamp";
    private static DatabaseHelper mDBHelper = null;
    private Context mContext;
    private SQLiteDatabase mDB = null;

    class DatabaseHelper extends SQLiteOpenHelper {
        private static final String DATABASE_NAME = "svcpersistence.db";
        private static final int DATABASE_VERSION = 15;
        private Context mContext = null;

        public DatabaseHelper(Context context) {
            super(context, DATABASE_NAME, null, DATABASE_VERSION);
            this.mContext = context;
        }

        public void buildAgeTable(SQLiteDatabase sQLiteDatabase) {
            sQLiteDatabase.execSQL("CREATE TABLE IF NOT EXISTS agetable (_id INTEGER PRIMARY KEY,timestamp INTEGER NOT NULL DEFAULT 0,UNIQUE (timestamp));");
        }

        public void buildCommonMessageTable(SQLiteDatabase sQLiteDatabase) {
            sQLiteDatabase.execSQL("CREATE TABLE IF NOT EXISTS commonmessage (_id INTEGER PRIMARY KEY,timestamp INTEGER NOT NULL DEFAULT 0,messagetype INTEGER NOT NULL DEFAULT 0,messagecontext INTEGER NOT NULL DEFAULT 0,recipient VARCHAR(10),additionaldata TEXT,entitykey VARCHAR(250),UNIQUE (entitykey));");
        }

        public void buildDataStorageDownloadTable(SQLiteDatabase sQLiteDatabase) {
            sQLiteDatabase.execSQL("CREATE TABLE IF NOT EXISTS dsdownload (_id INTEGER PRIMARY KEY,timestamp INTEGER NOT NULL DEFAULT 0,filepath TEXT,streamtype INTEGER NOT NULL DEFAULT 0,datasize INTEGER NOT NULL DEFAULT 0, additionaldata TEXT,entitykey VARCHAR(250),UNIQUE (entitykey));");
        }

        public void buildDataStorageUploadTable(SQLiteDatabase sQLiteDatabase) {
            sQLiteDatabase.execSQL("CREATE TABLE IF NOT EXISTS dsupload (_id INTEGER PRIMARY KEY,timestamp INTEGER NOT NULL DEFAULT 0,filepath TEXT,streamtype INTEGER NOT NULL DEFAULT 0,datasize INTEGER NOT NULL DEFAULT 0, startbyte INTEGER NOT NULL DEFAULT 0, additionaldata TEXT,entitykey VARCHAR(250),UNIQUE (entitykey));");
        }

        public void buildP2PDownloadTable(SQLiteDatabase sQLiteDatabase) {
            sQLiteDatabase.execSQL("CREATE TABLE IF NOT EXISTS p2pdownload (_id INTEGER PRIMARY KEY,timestamp INTEGER NOT NULL DEFAULT 0,filepath TEXT,streamtype INTEGER NOT NULL DEFAULT 0,channelid VARCHAR(250),senderpin VARCHAR(10),datasize INTEGER NOT NULL DEFAULT 0, entitykey VARCHAR(250),UNIQUE (entitykey));");
        }

        public void buildP2PUploadTable(SQLiteDatabase sQLiteDatabase) {
            sQLiteDatabase.execSQL("CREATE TABLE IF NOT EXISTS p2pupload (_id INTEGER PRIMARY KEY,timestamp INTEGER NOT NULL DEFAULT 0,filepath TEXT,startbyte INTEGER NOT NULL DEFAULT 0,endbyte INTEGER NOT NULL DEFAULT 0,streamtype INTEGER NOT NULL DEFAULT 0,channelid VARCHAR(250),recipient VARCHAR(10),datasize INTEGER NOT NULL DEFAULT 0, chunkoffset INTEGER NOT NULL DEFAULT 0, additionaldata TEXT,entitykey VARCHAR(250),UNIQUE (entitykey));");
        }

        public void onCreate(SQLiteDatabase sQLiteDatabase) {
            buildAgeTable(sQLiteDatabase);
            buildP2PUploadTable(sQLiteDatabase);
            buildP2PDownloadTable(sQLiteDatabase);
            buildDataStorageDownloadTable(sQLiteDatabase);
            buildDataStorageUploadTable(sQLiteDatabase);
            buildCommonMessageTable(sQLiteDatabase);
        }

        public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) {
            rebuildAllTables(sQLiteDatabase);
            Log.d(TaskDataStorage.TAG, "Upgrade DB from version: " + String.valueOf(i) + " to version: " + String.valueOf(i2) + " Finish");
        }

        public void rebuildAllTables(SQLiteDatabase sQLiteDatabase) {
            Log.d(TaskDataStorage.TAG, "DROPING AGE TABLE DB");
            sQLiteDatabase.execSQL("DROP TABLE IF EXISTS agetable");
            Log.d(TaskDataStorage.TAG, "DROPING P2P UPLOAD TABLE DB");
            sQLiteDatabase.execSQL("DROP TABLE IF EXISTS p2pupload");
            Log.d(TaskDataStorage.TAG, "DROPING P2P DOWNLOAD TABLE DB");
            sQLiteDatabase.execSQL("DROP TABLE IF EXISTS p2pdownload");
            Log.d(TaskDataStorage.TAG, "DROPING DATASTORAGE DOWNLOAD TABLE DB");
            sQLiteDatabase.execSQL("DROP TABLE IF EXISTS dsdownload");
            Log.d(TaskDataStorage.TAG, "DROPING DATASTORAGE UPLOAD TABLE DB");
            sQLiteDatabase.execSQL("DROP TABLE IF EXISTS dsupload");
            Log.d(TaskDataStorage.TAG, "DROPING COMMON MESSAGE TABLE DB");
            sQLiteDatabase.execSQL("DROP TABLE IF EXISTS commonmessage");
            buildAgeTable(sQLiteDatabase);
            buildP2PUploadTable(sQLiteDatabase);
            buildP2PDownloadTable(sQLiteDatabase);
            buildDataStorageDownloadTable(sQLiteDatabase);
            buildDataStorageUploadTable(sQLiteDatabase);
            buildCommonMessageTable(sQLiteDatabase);
        }
    }

    public TaskDataStorage(Context context) {
        this.mContext = context;
        if (mDBHelper == null) {
            initDBHelper(context);
        }
    }

    public static synchronized void initDBHelper(Context context) {
        synchronized (TaskDataStorage.class) {
            Log.d(TAG, "Create new DB Helper");
            mDBHelper = new DatabaseHelper(context);
        }
    }

    public void deleteAllCommonMessageInfo() {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(COMMONMESSAGE_TABLE_NAME, null, null);
            db.close();
        }
    }

    public void deleteAllDataStorageDownloadInfo() {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(DATASTORAGEDOWNLOAD_TABLE_NAME, null, null);
            db.close();
        }
    }

    public void deleteAllDataStorageUploadInfo() {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(DATASTORAGEUPLOAD_TABLE_NAME, null, null);
            db.close();
        }
    }

    public void deleteAllP2PDownloadInfo() {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(P2PDOWNLOAD_TABLE_NAME, null, null);
            db.close();
        }
    }

    public void deleteAllP2PUploadInfo() {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(P2PUPLOAD_TABLE_NAME, null, null);
            db.close();
        }
    }

    public void deleteCommonMessageInfo(CommonMessageInfo commonMessageInfo) {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(COMMONMESSAGE_TABLE_NAME, "entitykey = '" + commonMessageInfo.mKey + "'", null);
            db.close();
        }
    }

    public void deleteDataStorageDownloadInfo(DataStorageDownloadInfo dataStorageDownloadInfo) {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(DATASTORAGEDOWNLOAD_TABLE_NAME, "entitykey = '" + dataStorageDownloadInfo.mKey + "'", null);
            db.close();
        }
    }

    public void deleteDataStorageUploadInfo(DataStorageUploadInfo dataStorageUploadInfo) {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(DATASTORAGEUPLOAD_TABLE_NAME, "entitykey = '" + dataStorageUploadInfo.mKey + "'", null);
            db.close();
        }
    }

    public void deleteP2PDownloadInfo(P2PDownloadInfo p2PDownloadInfo) {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(P2PDOWNLOAD_TABLE_NAME, "entitykey = '" + p2PDownloadInfo.mKey + "'", null);
            db.close();
        }
    }

    public void deleteP2PUploadInfo(P2PUploadInfo p2PUploadInfo) {
        SQLiteDatabase db = getDB();
        if (db != null) {
            db.delete(P2PUPLOAD_TABLE_NAME, "entitykey = '" + p2PUploadInfo.mKey + "'", null);
            db.close();
        }
    }

    public CommonMessageInfo[] getAllCommonMessageInfo() {
        CommonMessageInfo[] commonMessageInfoArr = null;
        SQLiteDatabase db = getDB();
        if (db != null) {
            Cursor query = db.query(COMMONMESSAGE_TABLE_NAME, null, null, null, null, null, null);
            int count = query.getCount();
            if (count <= 0) {
                query.close();
                db.close();
            } else {
                commonMessageInfoArr = new CommonMessageInfo[query.getCount()];
                query.moveToFirst();
                int columnIndex = query.getColumnIndex(ENTITY_KEY);
                int columnIndex2 = query.getColumnIndex(TIMESTAMP);
                int columnIndex3 = query.getColumnIndex(RECIPIENT);
                int columnIndex4 = query.getColumnIndex(ADDITIONAL_DATA);
                int columnIndex5 = query.getColumnIndex(MESSAGETYPE);
                int columnIndex6 = query.getColumnIndex(MESSAGECONTEXT);
                for (int i = 0; i < count; i++) {
                    query.moveToPosition(i);
                    CommonMessageInfo obtain = CommonMessageInfo.obtain();
                    obtain.mKey = query.getString(columnIndex);
                    obtain.mTimeStamp = query.getLong(columnIndex2);
                    obtain.mRecipient = query.getString(columnIndex3);
                    obtain.mAdditionalData = query.getString(columnIndex4);
                    obtain.mMessageContext = query.getInt(columnIndex6);
                    obtain.mMessageType = query.getInt(columnIndex5);
                    commonMessageInfoArr[i] = obtain;
                }
                query.close();
                db.close();
            }
        }
        return commonMessageInfoArr;
    }

    public DataStorageDownloadInfo[] getAllDataStorageDownloadInfo() {
        DataStorageDownloadInfo[] dataStorageDownloadInfoArr = null;
        SQLiteDatabase db = getDB();
        if (db != null) {
            Cursor query = db.query(DATASTORAGEDOWNLOAD_TABLE_NAME, null, null, null, null, null, null);
            int count = query.getCount();
            if (count <= 0) {
                query.close();
                db.close();
            } else {
                dataStorageDownloadInfoArr = new DataStorageDownloadInfo[query.getCount()];
                query.moveToFirst();
                int columnIndex = query.getColumnIndex(ENTITY_KEY);
                int columnIndex2 = query.getColumnIndex(TIMESTAMP);
                int columnIndex3 = query.getColumnIndex(FILE_PATH);
                int columnIndex4 = query.getColumnIndex(DATA_SIZE);
                int columnIndex5 = query.getColumnIndex(STREAMTYPE);
                int columnIndex6 = query.getColumnIndex(ADDITIONAL_DATA);
                for (int i = 0; i < count; i++) {
                    query.moveToPosition(i);
                    DataStorageDownloadInfo obtain = DataStorageDownloadInfo.obtain();
                    obtain.mKey = query.getString(columnIndex);
                    obtain.mTimeStamp = query.getLong(columnIndex2);
                    obtain.mFilePath = query.getString(columnIndex3);
                    obtain.mDataSize = query.getInt(columnIndex4);
                    obtain.mStreamType = query.getInt(columnIndex5);
                    obtain.mAdditionalData = query.getString(columnIndex6);
                    dataStorageDownloadInfoArr[i] = obtain;
                }
                query.close();
                db.close();
            }
        }
        return dataStorageDownloadInfoArr;
    }

    public DataStorageUploadInfo[] getAllDataStorageUploadInfo() {
        SQLiteDatabase db = getDB();
        if (db == null) {
            return null;
        }
        Cursor query = db.query(DATASTORAGEUPLOAD_TABLE_NAME, null, null, null, null, null, null);
        int count = query.getCount();
        if (count <= 0) {
            query.close();
            db.close();
            return null;
        }
        DataStorageUploadInfo[] dataStorageUploadInfoArr = new DataStorageUploadInfo[query.getCount()];
        query.moveToFirst();
        int columnIndex = query.getColumnIndex(ENTITY_KEY);
        int columnIndex2 = query.getColumnIndex(TIMESTAMP);
        int columnIndex3 = query.getColumnIndex(FILE_PATH);
        int columnIndex4 = query.getColumnIndex(DATA_SIZE);
        int columnIndex5 = query.getColumnIndex(STARTBYTE);
        int columnIndex6 = query.getColumnIndex(STREAMTYPE);
        int columnIndex7 = query.getColumnIndex(ADDITIONAL_DATA);
        for (int i = 0; i < count; i++) {
            query.moveToPosition(i);
            DataStorageUploadInfo obtain = DataStorageUploadInfo.obtain();
            obtain.mKey = query.getString(columnIndex);
            obtain.mTimeStamp = query.getLong(columnIndex2);
            obtain.mFilePath = query.getString(columnIndex3);
            obtain.mDataSize = query.getInt(columnIndex4);
            obtain.mBytestart = query.getInt(columnIndex5);
            obtain.mStreamType = query.getInt(columnIndex6);
            obtain.mAdditionalData = query.getString(columnIndex7);
            dataStorageUploadInfoArr[i] = obtain;
        }
        query.close();
        db.close();
        return dataStorageUploadInfoArr;
    }

    public P2PDownloadInfo[] getAllP2PDownloadInfo() {
        SQLiteDatabase db = getDB();
        if (db == null) {
            return null;
        }
        Cursor query = db.query(P2PDOWNLOAD_TABLE_NAME, null, null, null, null, null, null);
        int count = query.getCount();
        if (count <= 0) {
            query.close();
            db.close();
            return null;
        }
        P2PDownloadInfo[] p2PDownloadInfoArr = new P2PDownloadInfo[query.getCount()];
        query.moveToFirst();
        int columnIndex = query.getColumnIndex(ENTITY_KEY);
        int columnIndex2 = query.getColumnIndex(TIMESTAMP);
        int columnIndex3 = query.getColumnIndex(FILE_PATH);
        int columnIndex4 = query.getColumnIndex(DATA_SIZE);
        int columnIndex5 = query.getColumnIndex(STREAMTYPE);
        int columnIndex6 = query.getColumnIndex(SENDERPIN);
        int columnIndex7 = query.getColumnIndex(CHANNELID);
        for (int i = 0; i < count; i++) {
            query.moveToPosition(i);
            P2PDownloadInfo obtain = P2PDownloadInfo.obtain();
            obtain.mKey = query.getString(columnIndex);
            obtain.mTimeStamp = query.getLong(columnIndex2);
            obtain.mFilePath = query.getString(columnIndex3);
            obtain.mDataSize = query.getInt(columnIndex4);
            obtain.mStreamType = query.getInt(columnIndex5);
            obtain.mSenderpin = query.getString(columnIndex6);
            obtain.mChannelID = query.getString(columnIndex7);
            p2PDownloadInfoArr[i] = obtain;
        }
        query.close();
        db.close();
        return p2PDownloadInfoArr;
    }

    public P2PUploadInfo[] getAllP2PUploadInfo() {
        SQLiteDatabase db = getDB();
        if (db == null) {
            return null;
        }
        Cursor query = db.query(P2PUPLOAD_TABLE_NAME, null, null, null, null, null, null);
        int count = query.getCount();
        if (count <= 0) {
            query.close();
            db.close();
            return null;
        }
        P2PUploadInfo[] p2PUploadInfoArr = new P2PUploadInfo[query.getCount()];
        query.moveToFirst();
        int columnIndex = query.getColumnIndex(ENTITY_KEY);
        int columnIndex2 = query.getColumnIndex(TIMESTAMP);
        int columnIndex3 = query.getColumnIndex(STARTBYTE);
        int columnIndex4 = query.getColumnIndex(ENDBYTE);
        int columnIndex5 = query.getColumnIndex(FILE_PATH);
        int columnIndex6 = query.getColumnIndex(DATA_SIZE);
        int columnIndex7 = query.getColumnIndex(CHUNKOFFSET);
        int columnIndex8 = query.getColumnIndex(STREAMTYPE);
        int columnIndex9 = query.getColumnIndex(CHANNELID);
        int columnIndex10 = query.getColumnIndex(ADDITIONAL_DATA);
        int columnIndex11 = query.getColumnIndex(RECIPIENT);
        for (int i = 0; i < count; i++) {
            query.moveToPosition(i);
            P2PUploadInfo obtain = P2PUploadInfo.obtain();
            obtain.mKey = query.getString(columnIndex);
            obtain.mTimeStamp = query.getLong(columnIndex2);
            obtain.mBytestart = query.getInt(columnIndex3);
            obtain.mEndByte = query.getInt(columnIndex4);
            obtain.mChunkOffset = query.getInt(columnIndex7);
            obtain.mFilePath = query.getString(columnIndex5);
            obtain.mDataSize = query.getInt(columnIndex6);
            obtain.mStreamType = query.getInt(columnIndex8);
            obtain.mChannelID = query.getString(columnIndex9);
            obtain.mAdditionalData = query.getString(columnIndex10);
            obtain.mRecipient = query.getString(columnIndex11);
            p2PUploadInfoArr[i] = obtain;
        }
        query.close();
        db.close();
        return p2PUploadInfoArr;
    }

    public SQLiteDatabase getDB() {
        SQLiteDatabase writableDatabase = mDBHelper.getWritableDatabase();
        writableDatabase.acquireReference();
        return writableDatabase;
    }

    public boolean storeCommonMessageInfo(CommonMessageInfo commonMessageInfo) {
        if (commonMessageInfo == null) {
            return false;
        }
        SQLiteDatabase db = getDB();
        if (db == null) {
            return false;
        }
        ContentValues contentValues = new ContentValues();
        contentValues.put(TIMESTAMP, Long.valueOf(commonMessageInfo.mTimeStamp));
        contentValues.put(RECIPIENT, commonMessageInfo.mRecipient);
        contentValues.put(MESSAGECONTEXT, Integer.valueOf(commonMessageInfo.mMessageContext));
        contentValues.put(MESSAGETYPE, Integer.valueOf(commonMessageInfo.mMessageType));
        contentValues.put(ENTITY_KEY, commonMessageInfo.mKey);
        contentValues.put(ADDITIONAL_DATA, commonMessageInfo.mAdditionalData);
        long update = (long) db.update(COMMONMESSAGE_TABLE_NAME, contentValues, "entitykey = '" + commonMessageInfo.mKey + "'", null);
        if (update <= 0) {
            update = db.insert(COMMONMESSAGE_TABLE_NAME, null, contentValues);
        }
        db.close();
        return update > 0;
    }

    public boolean storeDataStorageDownloadInfo(DataStorageDownloadInfo dataStorageDownloadInfo) {
        if (dataStorageDownloadInfo == null || dataStorageDownloadInfo.mFilePath == null) {
            return false;
        }
        SQLiteDatabase db = getDB();
        if (db == null) {
            return false;
        }
        ContentValues contentValues = new ContentValues();
        contentValues.put(TIMESTAMP, Long.valueOf(dataStorageDownloadInfo.mTimeStamp));
        contentValues.put(FILE_PATH, dataStorageDownloadInfo.mFilePath);
        contentValues.put(DATA_SIZE, Integer.valueOf(dataStorageDownloadInfo.mDataSize));
        contentValues.put(STREAMTYPE, Integer.valueOf(dataStorageDownloadInfo.mStreamType));
        contentValues.put(ENTITY_KEY, dataStorageDownloadInfo.mKey);
        if (dataStorageDownloadInfo.mAdditionalData != null) {
            contentValues.put(ADDITIONAL_DATA, dataStorageDownloadInfo.mAdditionalData);
        } else {
            contentValues.put(ADDITIONAL_DATA, "{}");
        }
        long update = (long) db.update(DATASTORAGEDOWNLOAD_TABLE_NAME, contentValues, "entitykey = '" + dataStorageDownloadInfo.mKey + "'", null);
        if (update <= 0) {
            update = db.insert(DATASTORAGEDOWNLOAD_TABLE_NAME, null, contentValues);
        }
        db.close();
        return update > 0;
    }

    public boolean storeDataStorageUploadInfo(DataStorageUploadInfo dataStorageUploadInfo) {
        if (dataStorageUploadInfo == null || dataStorageUploadInfo.mFilePath == null) {
            return false;
        }
        SQLiteDatabase db = getDB();
        if (db == null) {
            return false;
        }
        ContentValues contentValues = new ContentValues();
        contentValues.put(TIMESTAMP, Long.valueOf(dataStorageUploadInfo.mTimeStamp));
        contentValues.put(FILE_PATH, dataStorageUploadInfo.mFilePath);
        contentValues.put(DATA_SIZE, Integer.valueOf(dataStorageUploadInfo.mDataSize));
        contentValues.put(STARTBYTE, Integer.valueOf(dataStorageUploadInfo.mBytestart));
        contentValues.put(STREAMTYPE, Integer.valueOf(dataStorageUploadInfo.mStreamType));
        contentValues.put(ENTITY_KEY, dataStorageUploadInfo.mKey);
        if (dataStorageUploadInfo.mAdditionalData != null) {
            contentValues.put(ADDITIONAL_DATA, dataStorageUploadInfo.mAdditionalData);
        } else {
            contentValues.put(ADDITIONAL_DATA, "{}");
        }
        long update = (long) db.update(DATASTORAGEUPLOAD_TABLE_NAME, contentValues, "entitykey = '" + dataStorageUploadInfo.mKey + "'", null);
        if (update <= 0) {
            update = db.insert(DATASTORAGEUPLOAD_TABLE_NAME, null, contentValues);
        }
        db.close();
        return update > 0;
    }

    public boolean storeP2PDownloadInfo(P2PDownloadInfo p2PDownloadInfo) {
        if (p2PDownloadInfo == null) {
            return false;
        }
        SQLiteDatabase db = getDB();
        if (db == null) {
            return false;
        }
        ContentValues contentValues = new ContentValues();
        contentValues.put(TIMESTAMP, Long.valueOf(p2PDownloadInfo.mTimeStamp));
        contentValues.put(FILE_PATH, p2PDownloadInfo.mFilePath);
        contentValues.put(DATA_SIZE, Integer.valueOf(p2PDownloadInfo.mDataSize));
        contentValues.put(STREAMTYPE, Integer.valueOf(p2PDownloadInfo.mStreamType));
        contentValues.put(ENTITY_KEY, p2PDownloadInfo.mKey);
        contentValues.put(SENDERPIN, p2PDownloadInfo.mSenderpin);
        contentValues.put(CHANNELID, p2PDownloadInfo.mChannelID);
        long update = (long) db.update(P2PDOWNLOAD_TABLE_NAME, contentValues, "entitykey = '" + p2PDownloadInfo.mKey + "'", null);
        if (update <= 0) {
            update = db.insert(P2PDOWNLOAD_TABLE_NAME, null, contentValues);
        }
        db.close();
        return update > 0;
    }

    public boolean storeP2PUploadInfo(P2PUploadInfo p2PUploadInfo) {
        if (p2PUploadInfo == null || p2PUploadInfo.mFilePath == null) {
            return false;
        }
        SQLiteDatabase db = getDB();
        if (db == null) {
            return false;
        }
        ContentValues contentValues = new ContentValues();
        contentValues.put(TIMESTAMP, Long.valueOf(p2PUploadInfo.mTimeStamp));
        contentValues.put(STARTBYTE, Integer.valueOf(p2PUploadInfo.mBytestart));
        contentValues.put(ENDBYTE, Integer.valueOf(p2PUploadInfo.mEndByte));
        contentValues.put(CHUNKOFFSET, Integer.valueOf(p2PUploadInfo.mChunkOffset));
        contentValues.put(FILE_PATH, p2PUploadInfo.mFilePath);
        contentValues.put(DATA_SIZE, Integer.valueOf(p2PUploadInfo.mDataSize));
        contentValues.put(CHANNELID, p2PUploadInfo.mChannelID);
        contentValues.put(ADDITIONAL_DATA, p2PUploadInfo.mAdditionalData);
        contentValues.put(RECIPIENT, p2PUploadInfo.mRecipient);
        contentValues.put(STREAMTYPE, Integer.valueOf(p2PUploadInfo.mStreamType));
        contentValues.put(ENTITY_KEY, p2PUploadInfo.mKey);
        long update = (long) db.update(P2PUPLOAD_TABLE_NAME, contentValues, "entitykey = '" + p2PUploadInfo.mKey + "'", null);
        if (update <= 0) {
            update = db.insert(P2PUPLOAD_TABLE_NAME, null, contentValues);
        }
        db.close();
        return update > 0;
    }
}

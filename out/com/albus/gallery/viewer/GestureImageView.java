package com.albus.gallery.viewer;

import android.app.ProgressDialog;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BitmapFactory.Options;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.Matrix;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.AsyncTask;
import android.support.v4.view.MotionEventCompat;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.MeasureSpec;
import android.view.View.OnClickListener;
import android.view.View.OnTouchListener;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import com.catfiz.util.Log;
import java.io.InputStream;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import org.apache.http.conn.routing.HttpRouteDirector;

public class GestureImageView extends ImageView {
    public static final String GLOBAL_NS = "http://schemas.android.com/apk/res/android";
    public static final String LOCAL_NS = "http://schemas.polites.com/android";
    private static final String TAG = "GestureImageView";
    private int alpha;
    private Animator animator;
    private float centerX;
    private float centerY;
    private ColorFilter colorFilter;
    private OnTouchListener customOnTouchListener;
    private int deviceOrientation;
    private int displayHeight;
    private int displayWidth;
    private final Semaphore drawLock;
    private Drawable drawable;
    private float fitScaleHorizontal;
    private float fitScaleVertical;
    private GestureImageViewListener gestureImageViewListener;
    private GestureImageViewTouchListener gestureImageViewTouchListener;
    private int hHeight;
    private int hWidth;
    private int imageOrientation;
    private boolean layout;
    private Context mContext;
    private float maxScale;
    private float minScale;
    private OnClickListener onClickListener;
    private boolean recycle;
    private int resId;
    private float rotation;
    private float scale;
    private float scaleAdjust;
    private Float startX;
    private Float startY;
    private float startingScale;
    private boolean strict;
    private float x;
    private float y;

    /* synthetic */ class AnonymousClass2 {
        static final /* synthetic */ int[] $SwitchMap$android$widget$ImageView$ScaleType = new int[ScaleType.values().length];

        static {
            try {
                $SwitchMap$android$widget$ImageView$ScaleType[ScaleType.CENTER.ordinal()] = 1;
            } catch (NoSuchFieldError e) {
            }
            try {
                $SwitchMap$android$widget$ImageView$ScaleType[ScaleType.CENTER_CROP.ordinal()] = 2;
            } catch (NoSuchFieldError e2) {
            }
            try {
                $SwitchMap$android$widget$ImageView$ScaleType[ScaleType.CENTER_INSIDE.ordinal()] = 3;
            } catch (NoSuchFieldError e3) {
            }
        }
    }

    class SetImageBitmapTask extends AsyncTask {
        int mImageOrientation;
        ProgressDialog mProgress;

        private SetImageBitmapTask() {
            this.mImageOrientation = 0;
        }

        protected Bitmap doInBackground(Uri... uriArr) {
            Bitmap bitmap;
            Throwable e;
            Throwable th;
            InputStream inputStream;
            Uri uri = uriArr[0];
            try {
                String[] strArr = new String[]{"orientation"};
                Cursor query = GestureImageView.this.getContext().getContentResolver().query(uri, strArr, null, null, null);
                if (query != null && query.moveToFirst()) {
                    this.mImageOrientation = query.getInt(query.getColumnIndex(strArr[0]));
                }
                try {
                    InputStream openInputStream = GestureImageView.this.getContext().getContentResolver().openInputStream(uri);
                    try {
                        Bitmap decodeStream = BitmapFactory.decodeStream(openInputStream);
                        if (this.mImageOrientation != 0) {
                            Matrix matrix = new Matrix();
                            matrix.postRotate((float) this.mImageOrientation);
                            Bitmap createBitmap = Bitmap.createBitmap(decodeStream, 0, 0, decodeStream.getWidth(), decodeStream.getHeight(), matrix, true);
                            decodeStream.recycle();
                            bitmap = createBitmap;
                        } else {
                            bitmap = decodeStream;
                        }
                        if (openInputStream != null) {
                            try {
                                openInputStream.close();
                            } catch (Exception e2) {
                                e = e2;
                                Log.w(GestureImageView.TAG, "Unable to open content: " + uri, e);
                                return bitmap;
                            }
                        }
                        if (query != null) {
                            query.close();
                        }
                        return bitmap;
                    } catch (Throwable th2) {
                        th = th2;
                        inputStream = openInputStream;
                        if (inputStream != null) {
                            try {
                                inputStream.close();
                            } catch (Throwable th3) {
                                e = th3;
                                bitmap = null;
                                Log.w(GestureImageView.TAG, "Unable to open content: " + uri, e);
                                return bitmap;
                            }
                        }
                        if (query != null) {
                            query.close();
                        }
                        throw th3;
                    }
                } catch (Throwable th4) {
                    th3 = th4;
                    inputStream = null;
                    if (inputStream != null) {
                        inputStream.close();
                    }
                    if (query != null) {
                        query.close();
                    }
                    throw th3;
                }
            } catch (Throwable th32) {
                e = th32;
                bitmap = null;
                Log.w(GestureImageView.TAG, "Unable to open content: " + uri, e);
                return bitmap;
            }
        }

        protected void onPostExecute(Bitmap bitmap) {
            if (bitmap != null) {
                this.mProgress.dismiss();
                GestureImageView.this.setImageDrawable(new BitmapDrawable(GestureImageView.this.getResources(), bitmap));
            }
        }

        protected void onPreExecute() {
            super.onPreExecute();
            this.mProgress = ProgressDialog.show(GestureImageView.this.mContext, "", "Loading...", true);
        }
    }

    class SetImageDrawableTask extends AsyncTask {
        private ProgressDialog mProgress;

        private SetImageDrawableTask() {
        }

        protected Bitmap doInBackground(Uri... uriArr) {
            Uri parse = Uri.parse("file://" + uriArr[0]);
            try {
                Bitmap createScaledBitmap;
                InputStream openInputStream = GestureImageView.this.mContext.getContentResolver().openInputStream(parse);
                Options options = new Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeStream(openInputStream, null, options);
                openInputStream.close();
                int i = 1;
                while (((double) (options.outWidth * options.outHeight)) * (1.0d / Math.pow((double) i, 2.0d)) > 1200000.0d) {
                    i++;
                }
                Log.d(GestureImageView.TAG, "scale = " + i + ", orig-width: " + options.outWidth + ", orig-height: " + options.outHeight);
                InputStream openInputStream2 = GestureImageView.this.mContext.getContentResolver().openInputStream(parse);
                if (i > 1) {
                    i--;
                    options = new Options();
                    options.inSampleSize = i;
                    Bitmap decodeStream = BitmapFactory.decodeStream(openInputStream2, null, options);
                    i = decodeStream.getHeight();
                    int width = decodeStream.getWidth();
                    Log.d(GestureImageView.TAG, "1th scale operation dimenions - width: " + width + ",height: " + i);
                    double sqrt = Math.sqrt(1200000.0d / (((double) width) / ((double) i)));
                    createScaledBitmap = Bitmap.createScaledBitmap(decodeStream, (int) ((sqrt / ((double) i)) * ((double) width)), (int) sqrt, true);
                    decodeStream.recycle();
                    System.gc();
                } else {
                    createScaledBitmap = BitmapFactory.decodeStream(openInputStream2);
                }
                openInputStream2.close();
                Log.d(GestureImageView.TAG, "bitmap size - width: " + createScaledBitmap.getWidth() + ", height: " + createScaledBitmap.getHeight());
                return createScaledBitmap;
            } catch (Throwable e) {
                Log.e(GestureImageView.TAG, e.getMessage(), e);
                return null;
            }
        }

        protected void onPostExecute(Bitmap bitmap) {
            Log.d("Image", "bitmap=" + bitmap);
            if (bitmap != null) {
                this.mProgress.dismiss();
                BitmapDrawable bitmapDrawable = new BitmapDrawable(GestureImageView.this.mContext.getResources(), bitmap);
                GestureImageView.this.layout = false;
                GestureImageView.this.setImageBitmap(bitmap);
            }
        }

        protected void onPreExecute() {
            super.onPreExecute();
            this.mProgress = ProgressDialog.show(GestureImageView.this.mContext, "", "Loading...", true);
        }
    }

    public GestureImageView(Context context) {
        super(context);
        this.drawLock = new Semaphore(0);
        this.x = 0.0f;
        this.y = 0.0f;
        this.layout = false;
        this.scaleAdjust = 1.0f;
        this.startingScale = -1.0f;
        this.scale = 1.0f;
        this.maxScale = 5.0f;
        this.minScale = 0.75f;
        this.fitScaleHorizontal = 1.0f;
        this.fitScaleVertical = 1.0f;
        this.rotation = 0.0f;
        this.resId = -1;
        this.recycle = false;
        this.strict = false;
        this.alpha = MotionEventCompat.ACTION_MASK;
        this.deviceOrientation = -1;
        Log.d(TAG, "on GestureImageView(context)");
        setScaleType(ScaleType.CENTER_INSIDE);
        initImage();
    }

    public GestureImageView(Context context, AttributeSet attributeSet) {
        super(context, attributeSet);
        this.drawLock = new Semaphore(0);
        this.x = 0.0f;
        this.y = 0.0f;
        this.layout = false;
        this.scaleAdjust = 1.0f;
        this.startingScale = -1.0f;
        this.scale = 1.0f;
        this.maxScale = 5.0f;
        this.minScale = 0.75f;
        this.fitScaleHorizontal = 1.0f;
        this.fitScaleVertical = 1.0f;
        this.rotation = 0.0f;
        this.resId = -1;
        this.recycle = false;
        this.strict = false;
        this.alpha = MotionEventCompat.ACTION_MASK;
        this.deviceOrientation = -1;
        Log.d(TAG, "on GestureImageView(context, atributeset, int)");
        this.mContext = context;
        String attributeValue = attributeSet.getAttributeValue(GLOBAL_NS, "scaleType");
        if (attributeValue == null || attributeValue.trim().length() == 0) {
            setScaleType(ScaleType.CENTER_INSIDE);
        }
        attributeValue = attributeSet.getAttributeValue(LOCAL_NS, "start-x");
        String attributeValue2 = attributeSet.getAttributeValue(LOCAL_NS, "start-y");
        if (attributeValue != null && attributeValue.trim().length() > 0) {
            this.startX = Float.valueOf(Float.parseFloat(attributeValue));
        }
        if (attributeValue2 != null && attributeValue2.trim().length() > 0) {
            this.startY = Float.valueOf(Float.parseFloat(attributeValue2));
        }
        setStartingScale(attributeSet.getAttributeFloatValue(LOCAL_NS, "start-scale", this.startingScale));
        setMinScale(attributeSet.getAttributeFloatValue(LOCAL_NS, "min-scale", this.minScale));
        setMaxScale(attributeSet.getAttributeFloatValue(LOCAL_NS, "max-scale", this.maxScale));
        setStrict(attributeSet.getAttributeBooleanValue(LOCAL_NS, "strict", this.strict));
        setRecycle(attributeSet.getAttributeBooleanValue(LOCAL_NS, "recycle", this.recycle));
        initImage();
    }

    public GestureImageView(Context context, AttributeSet attributeSet, int i) {
        this(context, attributeSet);
    }

    public void animationStart(Animation animation) {
        if (this.animator != null) {
            this.animator.play(animation);
        }
    }

    public void animationStop() {
        if (this.animator != null) {
            this.animator.cancel();
        }
    }

    protected void computeCropScale(int i, int i2, int i3, int i4) {
        Log.d(TAG, "imagewidth:" + i + " imageheight:" + i2);
        this.fitScaleHorizontal = ((float) i3) / ((float) i);
        this.fitScaleVertical = ((float) i4) / ((float) i2);
    }

    protected void computeStartingScale(int i, int i2, int i3, int i4) {
        switch (AnonymousClass2.$SwitchMap$android$widget$ImageView$ScaleType[getScaleType().ordinal()]) {
            case e.b /*1*/:
                this.startingScale = 1.0f;
                return;
            case e.c /*2*/:
                this.startingScale = Math.max(((float) i4) / ((float) i2), ((float) i3) / ((float) i));
                return;
            case HttpRouteDirector.TUNNEL_TARGET /*3*/:
                if (((float) i) / ((float) i3) > ((float) i2) / ((float) i4)) {
                    this.startingScale = this.fitScaleHorizontal;
                } else {
                    this.startingScale = this.fitScaleVertical;
                }
                Log.d(TAG, "start:" + this.startingScale + " horizontal:" + this.fitScaleHorizontal + " vertical:" + this.fitScaleVertical);
                return;
            default:
                return;
        }
    }

    public float getCenterX() {
        return this.centerX;
    }

    public float getCenterY() {
        return this.centerY;
    }

    public int getDeviceOrientation() {
        return this.deviceOrientation;
    }

    public Drawable getDrawable() {
        return this.drawable;
    }

    public GestureImageViewListener getGestureImageViewListener() {
        return this.gestureImageViewListener;
    }

    public int getImageHeight() {
        return this.drawable != null ? this.drawable.getIntrinsicHeight() : 0;
    }

    public Matrix getImageMatrix() {
        if (!this.strict) {
            return super.getImageMatrix();
        }
        throw new UnsupportedOperationException("Not supported");
    }

    public int getImageWidth() {
        return this.drawable != null ? this.drawable.getIntrinsicWidth() : 0;
    }

    public float getImageX() {
        return this.x;
    }

    public float getImageY() {
        return this.y;
    }

    public float getScale() {
        return this.scaleAdjust;
    }

    public int getScaledHeight() {
        return Math.round(((float) getImageHeight()) * getScale());
    }

    public int getScaledWidth() {
        return Math.round(((float) getImageWidth()) * getScale());
    }

    protected void initImage() {
        if (this.drawable != null) {
            Log.d(TAG, "init image drawable not null");
            this.drawable.setAlpha(this.alpha);
            this.drawable.setFilterBitmap(true);
            if (this.colorFilter != null) {
                this.drawable.setColorFilter(this.colorFilter);
            }
        }
        if (!this.layout) {
            Log.d(TAG, "init image has layout:" + this.layout);
            requestLayout();
            redraw();
        }
    }

    public void invalidateDrawable(Drawable drawable) {
        if (this.strict) {
            throw new UnsupportedOperationException("Not supported");
        }
        super.invalidateDrawable(drawable);
    }

    public boolean isLandscape() {
        return getImageWidth() >= getImageHeight();
    }

    public boolean isOrientationAligned() {
        return this.deviceOrientation == 2 ? isLandscape() : this.deviceOrientation == 1 ? isPortrait() : true;
    }

    public boolean isPortrait() {
        return getImageWidth() <= getImageHeight();
    }

    public boolean isRecycle() {
        return this.recycle;
    }

    protected boolean isRecycled() {
        if (this.drawable != null && (this.drawable instanceof BitmapDrawable)) {
            Bitmap bitmap = ((BitmapDrawable) this.drawable).getBitmap();
            if (bitmap != null) {
                return bitmap.isRecycled();
            }
        }
        return false;
    }

    public boolean isStrict() {
        return this.strict;
    }

    public void moveBy(float f, float f2) {
        this.x += f;
        this.y += f2;
    }

    protected void onAttachedToWindow() {
        this.animator = new Animator(this, "GestureImageViewAnimator");
        this.animator.start();
        if (this.resId >= 0 && this.drawable == null) {
            setImageResource(this.resId);
        }
        super.onAttachedToWindow();
    }

    public int[] onCreateDrawableState(int i) {
        if (!this.strict) {
            return super.onCreateDrawableState(i);
        }
        throw new UnsupportedOperationException("Not supported");
    }

    protected void onDetachedFromWindow() {
        if (this.animator != null) {
            this.animator.finish();
        }
        if (!(!this.recycle || this.drawable == null || isRecycled())) {
            recycle();
            this.drawable = null;
        }
        super.onDetachedFromWindow();
    }

    protected void onDraw(Canvas canvas) {
        Log.d(TAG, "on draw");
        if (this.layout) {
            if (!(this.drawable == null || isRecycled())) {
                canvas.save();
                float f = this.scale * this.scaleAdjust;
                Log.d(TAG, "scale:" + this.scale + " scaleAdjust:" + this.scaleAdjust + " adjustedscale:" + f);
                canvas.translate(this.x, this.y);
                if (this.rotation != 0.0f) {
                    canvas.rotate(this.rotation);
                }
                if (f != 1.0f) {
                    Log.d(TAG, "adjustscale");
                    canvas.scale(f, f);
                }
                this.drawable.draw(canvas);
                canvas.restore();
            }
            if (this.drawLock.availablePermits() <= 0) {
                this.drawLock.release();
            }
        }
    }

    protected void onLayout(boolean z, int i, int i2, int i3, int i4) {
        super.onLayout(z, i, i2, i3, i4);
        if (z || !this.layout) {
            setupCanvas(this.displayWidth, this.displayHeight, getResources().getConfiguration().orientation);
        }
    }

    protected void onMeasure(int i, int i2) {
        if (this.drawable == null) {
            this.displayHeight = MeasureSpec.getSize(i2);
            this.displayWidth = MeasureSpec.getSize(i);
        } else if (getResources().getConfiguration().orientation == 2) {
            this.displayHeight = MeasureSpec.getSize(i2);
            if (getLayoutParams().width == -2) {
                this.displayWidth = Math.round((((float) getImageWidth()) / ((float) getImageHeight())) * ((float) this.displayHeight));
            } else {
                this.displayWidth = MeasureSpec.getSize(i);
            }
        } else {
            this.displayWidth = MeasureSpec.getSize(i);
            if (getLayoutParams().height == -2) {
                this.displayHeight = Math.round((((float) getImageHeight()) / ((float) getImageWidth())) * ((float) this.displayWidth));
            } else {
                this.displayHeight = MeasureSpec.getSize(i2);
            }
        }
        setMeasuredDimension(this.displayWidth, this.displayHeight);
    }

    protected void recycle() {
        if (this.recycle && this.drawable != null && (this.drawable instanceof BitmapDrawable)) {
            Bitmap bitmap = ((BitmapDrawable) this.drawable).getBitmap();
            if (bitmap != null) {
                bitmap.recycle();
            }
        }
    }

    public void redraw() {
        postInvalidate();
    }

    public void reset() {
        this.x = this.centerX;
        this.y = this.centerY;
        this.scaleAdjust = this.startingScale;
        if (this.gestureImageViewTouchListener != null) {
            this.gestureImageViewTouchListener.reset();
        }
        redraw();
    }

    public void setAdjustViewBounds(boolean z) {
        if (this.strict) {
            throw new UnsupportedOperationException("Not supported");
        }
        super.setAdjustViewBounds(z);
    }

    public void setAlpha(int i) {
        this.alpha = i;
        if (this.drawable != null) {
            this.drawable.setAlpha(i);
        }
    }

    public void setColorFilter(ColorFilter colorFilter) {
        this.colorFilter = colorFilter;
        if (this.drawable != null) {
            this.drawable.setColorFilter(colorFilter);
        }
    }

    public void setGestureImageViewListener(GestureImageViewListener gestureImageViewListener) {
        this.gestureImageViewListener = gestureImageViewListener;
    }

    public void setImageBitmap(Bitmap bitmap) {
        this.drawable = new BitmapDrawable(getResources(), bitmap);
        initImage();
    }

    public void setImageDrawable(Drawable drawable) {
        Log.d(TAG, "on setImageDrawable:" + drawable);
        this.drawable = drawable;
        initImage();
    }

    public void setImageLevel(int i) {
        if (this.strict) {
            throw new UnsupportedOperationException("Not supported");
        }
        super.setImageLevel(i);
    }

    public void setImageMatrix(Matrix matrix) {
        if (this.strict) {
            throw new UnsupportedOperationException("Not supported");
        }
    }

    public void setImageResource(int i) {
        if (this.drawable != null) {
            recycle();
        }
        if (i >= 0) {
            this.resId = i;
            setImageDrawable(getContext().getResources().getDrawable(i));
        }
    }

    public void setImageState(int[] iArr, boolean z) {
        if (this.strict) {
            throw new UnsupportedOperationException("Not supported");
        }
    }

    public void setImageURI(Uri uri) {
        if ("content".equals(uri.getScheme())) {
            new SetImageBitmapTask().execute(new Uri[]{uri});
        } else {
            new SetImageDrawableTask().execute(new Uri[]{uri});
        }
        if (this.drawable == null) {
            Log.e(TAG, "resolveUri failed on bad bitmap uri: " + uri);
        }
    }

    public void setMaxScale(float f) {
        this.maxScale = f;
        if (this.gestureImageViewTouchListener != null) {
            this.gestureImageViewTouchListener.setMaxScale(this.startingScale * f);
        }
    }

    public void setMinScale(float f) {
        this.minScale = f;
        if (this.gestureImageViewTouchListener != null) {
            this.gestureImageViewTouchListener.setMinScale(this.fitScaleHorizontal * f);
        }
    }

    public void setOnClickListener(OnClickListener onClickListener) {
        this.onClickListener = onClickListener;
        if (this.gestureImageViewTouchListener != null) {
            this.gestureImageViewTouchListener.setOnClickListener(onClickListener);
        }
    }

    public void setOnTouchListener(OnTouchListener onTouchListener) {
        this.customOnTouchListener = onTouchListener;
    }

    public void setPosition(float f, float f2) {
        this.x = f;
        this.y = f2;
    }

    public void setRecycle(boolean z) {
        this.recycle = z;
    }

    public void setRotation(float f) {
        this.rotation = f;
    }

    public void setScale(float f) {
        this.scaleAdjust = f;
    }

    public void setScaleType(ScaleType scaleType) {
        if (scaleType == ScaleType.CENTER || scaleType == ScaleType.CENTER_CROP || scaleType == ScaleType.CENTER_INSIDE) {
            super.setScaleType(scaleType);
        } else if (this.strict) {
            throw new UnsupportedOperationException("Not supported");
        }
    }

    public void setSelected(boolean z) {
        if (this.strict) {
            throw new UnsupportedOperationException("Not supported");
        }
        super.setSelected(z);
    }

    public void setStartingPosition(float f, float f2) {
        this.startX = Float.valueOf(f);
        this.startY = Float.valueOf(f2);
    }

    public void setStartingScale(float f) {
        this.startingScale = f;
    }

    public void setStrict(boolean z) {
        this.strict = z;
    }

    protected void setupCanvas(int i, int i2, int i3) {
        if (this.deviceOrientation != i3) {
            this.layout = false;
            this.deviceOrientation = i3;
        }
        if (this.drawable != null && !this.layout) {
            int imageWidth = getImageWidth();
            int imageHeight = getImageHeight();
            this.hWidth = Math.round(((float) imageWidth) / 2.0f);
            this.hHeight = Math.round(((float) imageHeight) / 2.0f);
            int paddingLeft = i - (getPaddingLeft() + getPaddingRight());
            int paddingTop = i2 - (getPaddingTop() + getPaddingBottom());
            Log.d(TAG, "width:" + this.hWidth + " height:" + this.hHeight);
            Log.d(TAG, "pleft:" + getPaddingLeft() + " pright:" + getPaddingRight() + " mwidth:" + paddingLeft);
            Log.d(TAG, "ptop:" + getPaddingTop() + " pbottom:" + getPaddingBottom() + " mheight:" + paddingTop);
            computeCropScale(imageWidth, imageHeight, paddingLeft, paddingTop);
            if (this.startingScale <= 0.0f) {
                computeStartingScale(imageWidth, imageHeight, paddingLeft, paddingTop);
            }
            this.scaleAdjust = this.startingScale;
            this.centerX = ((float) paddingLeft) / 2.0f;
            this.centerY = ((float) paddingTop) / 2.0f;
            if (this.startX == null) {
                this.x = this.centerX;
            } else {
                this.x = this.startX.floatValue();
            }
            if (this.startY == null) {
                this.y = this.centerY;
            } else {
                this.y = this.startY.floatValue();
            }
            this.gestureImageViewTouchListener = new GestureImageViewTouchListener(this, paddingLeft, paddingTop);
            if (isLandscape()) {
                this.gestureImageViewTouchListener.setMinScale(this.minScale * this.fitScaleHorizontal);
            } else {
                this.gestureImageViewTouchListener.setMinScale(this.minScale * this.fitScaleVertical);
            }
            this.gestureImageViewTouchListener.setMaxScale(this.maxScale * this.startingScale);
            this.gestureImageViewTouchListener.setFitScaleHorizontal(this.fitScaleHorizontal);
            this.gestureImageViewTouchListener.setFitScaleVertical(this.fitScaleVertical);
            this.gestureImageViewTouchListener.setCanvasWidth(paddingLeft);
            this.gestureImageViewTouchListener.setCanvasHeight(paddingTop);
            this.gestureImageViewTouchListener.setOnClickListener(this.onClickListener);
            this.drawable.setBounds(-this.hWidth, -this.hHeight, this.hWidth, this.hHeight);
            super.setOnTouchListener(new OnTouchListener() {
                public boolean onTouch(View view, MotionEvent motionEvent) {
                    if (GestureImageView.this.customOnTouchListener != null) {
                        GestureImageView.this.customOnTouchListener.onTouch(view, motionEvent);
                    }
                    return GestureImageView.this.gestureImageViewTouchListener.onTouch(view, motionEvent);
                }
            });
            this.layout = true;
        }
    }

    public boolean waitForDraw(long j) {
        return this.drawLock.tryAcquire(j, TimeUnit.MILLISECONDS);
    }
}

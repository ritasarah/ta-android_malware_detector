import libsvm.*;
import sun.org.mozilla.javascript.internal.Evaluator;
import weka.attributeSelection.*;
import weka.classifiers.Evaluation;
import weka.core.Instances;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.Remove;
//import weka.filters.Filter;
//import weka.filters.supervised.attribute.AttributeSelection;

import java.io.*;
import java.util.ArrayList;
import java.util.Map;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by Rita on 5/24/2016.
 */
public class ClassificationUtil {

    private svm_parameter param;

    private int[][] confusionMatrix;

    private double accuracy;

    private double[] recall;
    private double[] precision;
    private double[] f;

    private double avgRecall;
    private double avgPrecision;
    private double avgF;

    private int num_class;

    public ClassificationUtil() {
        this.param = new svm_parameter();

        accuracy = 0;
        avgRecall = 0;
        avgPrecision = 0;
        avgF = 0;
        num_class = 0;

        confusionMatrix = null;
        recall = null;
        precision = null;
        f = null;

    }

    public Instances loadARFF(String filename, int classIndex) {
        FileReader file = null;
        Instances newInstances = null;
        try {
            file = new FileReader(filename);
            try (BufferedReader reader = new BufferedReader(file)) {
                newInstances = new Instances(reader);
            }
            // setting class attribute
            newInstances.setClassIndex(classIndex);
            num_class = newInstances.classAttribute().numValues();
        } catch (IOException ex) {
            Logger.getLogger(ClassificationUtil.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                if (file!=null) {
                    file.close();
                }
            } catch (IOException ex) {
                Logger.getLogger(ClassificationUtil.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        return newInstances;
    }

    public void setParam() {
        param.kernel_type = 0; //linear
        param.svm_type = 0; //classification
        param.cache_size = 40;
        param.eps = 0.001;
        param.C = 1;
        param.nr_weight = 0;
    }
    /**
     * convert the instances into svm problem
     * @param instances the instances
     */
    public svm_problem defineProblem(Instances instances) {
        svm_problem prob = new svm_problem();
        prob.l = instances.size(); // jmlh data
        prob.x = new svm_node[prob.l][]; //data tanpa kls
        prob.y = new double[prob.l]; //kls

        for (int i = 0; i < instances.size(); i++) {
            prob.x[i] = new svm_node[instances.get(i).numValues() - 1];
            for (int j = 0; j < instances.get(i).numValues(); j++) {
                if (j == 0) {
                    prob.y[i] = instances.get(i).valueSparse(j);
//                    System.out.println(prob.y[i]);
                } else {
                        prob.x[i][j-1] = new svm_node();
                        prob.x[i][j-1].index = instances.get(i).index(j) + 1;
                        prob.x[i][j-1].value = instances.get(i).valueSparse(j);
                }
            }
        }
        return prob;
    }

    /**
     * build model to create classifier
     * @param prob the svm problem to be solved
     */
    public svm_model trainClassifier(svm_problem prob) {
        System.out.println(libsvm.svm.svm_check_parameter(prob, param));
        return libsvm.svm.svm_train(prob, param);
    }

    public void initializeConfusionMatrix(int rowSize, int columnSize) {
        confusionMatrix = new int[columnSize][rowSize];
        recall = new double[columnSize];
        precision = new double[columnSize];
        f = new double[columnSize];

        for (int i = 0; i < columnSize; i++) {
            for (int j = 0; j < rowSize; j++) {
                confusionMatrix[i][j] = 0;
            }
            recall[i] = 0;
            precision[i] = 0;
            f[i] = 0;
        }
    }

    public void computeAccuracy(int nr_class) {
        int[] TP = new int[nr_class];
        int[] FP = new int[nr_class];
        int[] FN = new int[nr_class];

        for (int i = 0; i < nr_class; i++) {
            for (int j = 0; j < nr_class; j++) {
                FP[j] += confusionMatrix[i][j];
                FN[i] += confusionMatrix[i][j];
                if (i==j) {
                    TP[i] = confusionMatrix[i][j];
                    FP[j] -= confusionMatrix[i][j];
                    FN[i] -= confusionMatrix[i][j];
                }
            }
        }

        double a,b;
        for (int i = 0; i < nr_class; i++) {
            a = (double) TP[i]; b = (double) (TP[i] + FN[i]);
            recall[i] = (Double.compare(b, 0) == 0) ? 0 : a/b;

            a = (double) TP[i]; b = (double) (TP[i] + FP[i]);
            precision[i] = (Double.compare(b, 0) == 0) ? 0 : a/b;

            a = (2*recall[i]*precision[i]); b = (recall[i]+precision[i]);
            f[i] = (Double.compare(b, 0) == 0) ? 0 : a/b;

            avgRecall += recall[i];
            avgPrecision += precision[i];
            avgF += f[i];
        }

        avgRecall = avgRecall/nr_class;
        avgPrecision = avgPrecision/nr_class;
        avgF = avgF/nr_class;
    }

    /**
     * test the model with n-cros fold validation
     * @param prob - the svm problem
     * @param nr_fold - number of fold
     */
    public void crossValidation(svm_problem prob, int nr_fold, int numClass) {
        int total_correct = 0;
        int false_positive = 0;
        int false_negative= 0;
        double[] target = new double[prob.l];

        libsvm.svm.svm_cross_validation(prob, param, nr_fold, target);
        initializeConfusionMatrix(numClass, numClass);

        int i;
        for(i = 0; i < prob.l; ++i) {
            if (Double.compare(target[i], prob.y[i]) == 0) {
                ++total_correct;
            }
            else if (target[i]<prob.y[i]) {
                ++false_positive;
            }
            else if (prob.y[i]< target[i]){
                ++false_negative;
            }
            confusionMatrix[(int)prob.y[i]][(int)target[i]]++;
        }

        accuracy = (double) total_correct / (double)prob.l;

        System.out.println("==============================================");

        computeAccuracy(numClass);

        System.out.println("Cross Validation Accuracy = " + (int)(100.0D * accuracy) + "%");
        System.out.println("FPR = "+(int)(100.0D * false_positive/prob.l) + "%");
        System.out.println("FNR = "+(int)(100.0D * false_negative/prob.l) + "%");

//        try {
//            PrintWriter writer = new PrintWriter(new FileOutputStream(new File("crossvalr200.txt"), true));
//            writer.println("Cross Validation Accuracy = " + (int)(100.0D * accuracy) + "%");
//            writer.close();
//        } catch (FileNotFoundException e) {
//            e.printStackTrace();
//        }

//        System.out.println("recall: " + (int)(100.0D * avgRecall) + "%");
//        System.out.println("precision: " + (int)(100.0D * avgPrecision) + "%");
//        System.out.println("f-measure: " + (int)(100.0D * avgF) + "%");
    }

    public void buildConfusionMatrix(svm_model model, svm_problem test_problem) {
        initializeConfusionMatrix(num_class, num_class);
        double pred;
        int match = 0;

        for (int i = 0; i < test_problem.l; i++) {
            pred = libsvm.svm.svm_predict_values(model, test_problem.x[i], new double[model.nr_class * (model.nr_class - 1) / 2]);
//            dataClass.put(i, pred);
            if (Double.compare(pred, test_problem.y[i]) == 0) {
                match++;
//                System.out.println(i + " " + pred);
            }
            System.out.println(test_problem.y[i]);
            System.out.println((int)pred);
            System.out.println(confusionMatrix[(int)test_problem.y[i]][(int)pred]);
            confusionMatrix[(int)test_problem.y[i]][(int)pred]++;
        }

        for (int i = 0; i < confusionMatrix.length; i++) {
            for (int j = 0; j < confusionMatrix[i].length; j++) {
                System.out.print(confusionMatrix[i][j] + "\t");
            }
            System.out.println();
        }

        accuracy = (double) match / (double)test_problem.l;
        computeAccuracy(num_class);
    }

    public int getAccuracy(){
        return (int)(100.0D * accuracy);
    }

    /**
     * testSchema main (sparsed data)
     * @param trainPath the train instances
     * @param testPath the test instances
     */
    public void test(String trainPath, int classIndexTrain, String testPath, int classIndexTest) {
        Instances train = loadARFF(trainPath, classIndexTrain);
        System.out.println("train size: " + train.size());
        Instances test = loadARFF(testPath, classIndexTest);

        setParam();
        svm_problem train_problem = defineProblem(train);
        svm_problem test_problem = defineProblem(test);

        svm_model model = trainClassifier(train_problem);
        System.out.println();

        System.out.println("==============================================");
        buildConfusionMatrix(model, test_problem);
        System.out.println("Accuracy: " + (int)(100.0D * accuracy) + "%");
        System.out.println("recall: " + (int)(100.0D * avgRecall) + "%");
        System.out.println("precision: " + (int)(100.0D * avgPrecision) + "%");
        System.out.println("f-measure: " + (int)(100.0D * avgF) + "%");
        System.out.println("number of train data used: " + train_problem.l);
    }

    public String test(Instances train, String testPath, int classIndexTest) {
        Instances test = loadARFF(testPath, classIndexTest);
        StringBuilder sb = new StringBuilder();

        setParam();
        svm_problem train_problem = defineProblem(train);
        svm_problem test_problem = defineProblem(test);

        svm_model model = trainClassifier(train_problem);

        buildConfusionMatrix(model, test_problem);
        sb.append("==============================================").append("\n");
        sb.append("Accuracy: ").append((int) (100.0D * accuracy)).append("%").append("\n");
        sb.append("recall: ").append((int) (100.0D * avgRecall)).append("%").append("\n");
        sb.append("precision: ").append((int) (100.0D * avgPrecision)).append("%").append("\n");
        sb.append("f-measure: ").append((int) (100.0D * avgF)).append("%").append("\n");
        sb.append("number of train data used: ").append(train_problem.l).append("\n");

        return sb.toString();
    }

    public void saveClassifier(svm_model model, String filePath) {
        try {
            libsvm.svm.svm_save_model(filePath, model);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public svm_problem classifyInstances(svm_model model, Instances test) {
        svm_problem test_problem = defineProblem(test);
        double[] d = new double[model.nr_class * (model.nr_class - 1) / 2];

        for (int i = 0; i < test_problem.l; i++) {
            double pred = svm.svm_predict_values(model, test_problem.x[i], d);
            test_problem.y[i] = pred;
        }


        return test_problem;
    }

    public Instances removeAttr (String arffPath,int idx){
        Instances inst = null;
        Instances instNew = null;
        Remove remove;

        try {
            inst   = new Instances(new BufferedReader(new FileReader(arffPath)));
        } catch (IOException e) {
            e.printStackTrace();
        }
        remove = new Remove();
        remove.setAttributeIndices(String.valueOf(idx));
        remove.setInvertSelection(false);
        try {
            remove.setInputFormat(inst);
            instNew = Filter.useFilter(inst, remove);

        } catch (Exception e) {
            e.printStackTrace();
        }
        instNew.setClassIndex(0);

//        System.out.println(instNew);
        return instNew;
    }

    public Instances removeAttrs (String arffPath,int[] idxs){
        Instances inst = null;
        Instances instNew = null;
        Remove remove;

        try {
            inst   = new Instances(new BufferedReader(new FileReader(arffPath)));
        } catch (IOException e) {
            e.printStackTrace();
        }
        remove = new Remove();
        remove.setAttributeIndicesArray(idxs);
        remove.setInvertSelection(false);
        try {
            remove.setInputFormat(inst);
            instNew = Filter.useFilter(inst, remove);

        } catch (Exception e) {
            e.printStackTrace();
        }
        instNew.setClassIndex(0);

//        System.out.println(instNew);
        return instNew;
    }

    public void classifyInstancesEval(svm_model model, Instances test) {
        svm_problem test_problem = defineProblem(test);
        double[] d = new double[model.nr_class * (model.nr_class - 1) / 2];
        double pred;
        int match = 0;
        int false_negative = 0 ;
        int false_positive = 0 ;

        for (int i = 0; i < test_problem.l; i++) {
            pred = libsvm.svm.svm_predict_values(model, test_problem.x[i], new double[model.nr_class * (model.nr_class - 1) / 2]);
//            System.out.println("test poblem"+test_problem.y[i]);
//            System.out.println("pret"+pred)
//                 if( pred == 1){
//                     System.out.println("Hasil : Malware");
//                 }else if (pred == 2 ){
//                     System.out.println("Hasil : Beign");
//                 }
            if (Double.compare(pred, test_problem.y[i]) == 0) {
                match++;
                System.out.println("match");
            }else {
                 if( pred == 1){
                     false_negative++;
                     System.out.println(i + "FN");
                 }else if (pred == 2 ){
                     false_positive++;
                     System.out.println( i+" FP");
                 }
            }
        }

        accuracy = (double) match / (double)test_problem.l;
        System.out.println("Accuracy: " + (int)(100.0D * accuracy) + "%");
        System.out.println("False Positive Rate: " + (int)(100.0D * false_negative/test_problem.l) + "%");
        System.out.println("False Negative Rate: " + (int)(100.0D * false_positive/test_problem.l) + "%");
    }




    public svm_model loadModel(String filePath){
        svm_model model = null;
        try {
            model = svm.svm_load_model(filePath);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return model;
    }

    public void AttrRanker(Instances ins,String evaltype){
        String[] options = null;
        AttributeSelection attributeSelection = new AttributeSelection();
        InfoGainAttributeEval eval = new InfoGainAttributeEval();
        SymmetricalUncertAttributeEval eval2 = new SymmetricalUncertAttributeEval();
        GainRatioAttributeEval eval3 = new GainRatioAttributeEval();
        CorrelationAttributeEval eval4 = new CorrelationAttributeEval();

        Ranker search = new Ranker();
        try {
            search.setNumToSelect(200);

            if(evaltype.equalsIgnoreCase("symmetrical")) {
                attributeSelection.setEvaluator(eval2);
            }else if(evaltype.equalsIgnoreCase("gainratio")){
                attributeSelection.setEvaluator(eval3);
            }else if (evaltype.equalsIgnoreCase("correlation")){
                attributeSelection.setEvaluator(eval4);
            }else { //eq infogain
                attributeSelection.setEvaluator(eval);
            }

            attributeSelection.setSearch(search);
            attributeSelection.SelectAttributes(ins);

            System.out.println(attributeSelection.toResultsString());

        } catch (Exception e) {
            e.printStackTrace();
        }

    }
//    public void createTestInstances(ArrayList<ExtractedFeatures> arr,String filePath) {
//        PrintWriter writer;
//        ExtractedFeatures manifest = new ExtractedFeatures();
//        int i = 0 ;
//        int j = 0 ;
//        try {
//            writer = new PrintWriter(filePath, "UTF-8");
//            writer.println("@relation 'datamasukan-weka.filters.unsupervised.attribute.NominalToString-Cfirst-weka.filters.unsupervised.attribute.NumericToNominal-Rfirst-last-weka.filters.unsupervised.attribute.Remove-R8,18'\n" +
//                    "\n" );
//            writer.println("@attribute malware {null,true,false}");
//            for (Map.Entry<String,Boolean> entry : manifest.permission.entrySet())
//            {
//                writer.println("@attribute " + entry.getKey() + " numeric" );
//            }
//            for (Map.Entry<String,Boolean> entry : manifest.sAPICall.entrySet())
//            {
//                writer.println("@attribute " + entry.getKey() + " numeric" );
//            }
//            writer.println("\n" + "'@data");
//
//            while(i < arr.size() ){
//                j = 0 ;
//                writer.print("{");
//
//                if (arr.get(i).isMalware()){
//                    writer.print(j + " true,");
//                }
//
//                for (Map.Entry<String,Boolean> entry : arr.get(i).permission.entrySet())
//                {
//                    if (entry.getValue()){
//                        writer.print(j + " 1,");
//                    }
//                    j++;
//                }
//
//                for (Map.Entry<String,Boolean> entry : arr.get(i).sAPICall.entrySet())
//                {
//                    if (i == manifest.sAPICall.size()){
//                        if (entry.getValue()){
//                            writer.print( j +" 1");
//                        }
//                    }else {
//                        if (entry.getValue()){
//                            writer.print( j +" 1,");
//                        }
//                        j++;
//                    }
//                }
//
//                writer.println("}");
//                i++;
//            }
//            writer.close();
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//    }

}
